<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从集成学习谈起</title>
      <link href="/2022/07/21/%E4%BB%8E%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E8%B0%88%E8%B5%B7/"/>
      <url>/2022/07/21/%E4%BB%8E%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E8%B0%88%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[<p>在机器学习中的常规算法，都是作为一个独立模型发挥作用，而集成学习就是让这些单独的模型一起解决问题，实现“3 个臭皮匠顶个诸葛亮”的效果”。集成学习归属于机器学习，是一种训练思路，并不是某种具体的方法或者算法。</p><p>集成学习通过将多个弱学习器进行结合，通常可以获得比单一学习器显著优越的泛化性能。要想获得好的集成，需要个体学习器“好而不同”，即个体学习器要有一定的“准确性”，即学习器不能太坏，并且要有“多样性”，即学习器之间有差异性。假设个体学习器之间的错误率相互独立，那随着集成中的个体learner数目增加，集成后的错误率将指数下降。在实际情况下，准确性和多样性存在冲突。如何产生“好而不同”的个体learner，是集成学习的研究核心。</p><p>根据个体learner的生成方式，可以把集成学习分为两类，一类是个体learner之间存在强依赖关系，必须串行生成的序列化方法。一类是learner之间不存在强依赖关系，可以同时生成的并行化方法。前者的代表是boosting，后者的代表是Bagging以及随机森林(Random Forest) 1. boosting 2. bagging（bootstrap aggregating的缩写，也称作“套袋法”）</p><p>Boosting 和 bagging 最本质的差别在于他对基础模型不是一致对待的，而是经过不停的考验和筛选来挑选出「精英」，然后给精英更多的投票权，表现不好的基础模型则给较少的投票权，然后综合所有人的投票得到最终结果。</p><h2 id="boosting">boosting</h2><p>主流的方法有Adaboost和Gradient Boost</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从决策树谈起</title>
      <link href="/2022/07/19/%E4%BB%8E%E5%86%B3%E7%AD%96%E6%A0%91%E8%B0%88%E8%B5%B7/"/>
      <url>/2022/07/19/%E4%BB%8E%E5%86%B3%E7%AD%96%E6%A0%91%E8%B0%88%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[<p>决策树是一种逻辑简单的机器学习算法，具有一种树形结构，因此得名。决策树是最简单的机器学习算法，它易于实现，可解释性强，完全符合人类的直观思维，有着广泛的应用。决策树模型既可以做分类也可以做回归。</p><ul><li>对于分类问题。测试样本点到达的叶子节点上所有类别中样本点最多的类别，即为测试样本点的类别；</li><li>对于回归问题。测试样本点到达的叶子节点上所有样本点输出值的平均值，即为测试样本点的输出值；</li></ul><table><thead><tr class="header"><th>节点</th><th>内容</th></tr></thead><tbody><tr class="odd"><td>根节点</td><td>包含样本全集</td></tr><tr class="even"><td>内部节点</td><td>对应特征属性</td></tr><tr class="odd"><td>叶节点</td><td>决策结果</td></tr></tbody></table><p>决策树有三个步骤 1. 特征选择</p><p>特征选择决定了使用哪些特征来做判断。在训练数据集中，每个样本的属性可能有很多个，不同属性的作用有大有小。因而特征选择的作用就是筛选出跟分类结果相关性较高的特征，也就是分类能力较强的特征。在特征选择中通常使用的准则是：信息增益。</p><ol start="2" type="1"><li>决策树生成</li></ol><p>选择好特征后，就从根节点触发，对节点计算所有特征的信息增益，选择信息增益最大的特征作为节点特征，根据该特征的不同取值建立子节点；对每个子节点使用相同的方式生成新的子节点，直到信息增益很小或者没有特征可以选择为止。</p><ol start="3" type="1"><li>决策树剪枝</li></ol><p>剪枝的主要目的是对抗“过拟合”，通过主动去掉部分分支来降低过拟合的风险。</p><h2 id="决策树分类">决策树分类</h2><p>根据使用的特征选择算法不同，我们将决策树分为三类</p><ol type="1"><li><p>ID3 使用信息增益作为特征选择，只能处理分类问题，loss函数的评价是使用信息熵</p></li><li><p>C4.5 它是ID3的改进版本，使用信息增益比作为特征选择依据。只能处理分类问题，理由同上</p></li><li><p>CART(Classification and Regression Tree) 采用Gini系数时可以处理分类问题，采用variance系数时可以用于回归问题，如果是一个回归问题，那么每一次特征选择后，其方差更小，那么叶节点内的均值就是一个回归值。</p></li></ol><h2 id="决策树的样本处理">决策树的样本处理</h2><h3 id="gini系数">Gini系数</h3><p>假设我们在使用Gini系数处理分类问题，对于连续特征值的特征，通过取相邻样本的平均值作为划分点，比如m个样本的连续特征A有m个，从小到大排列为<span class="math inline">\(a_1,a_2,\dots a_m\)</span>则CART算法取相邻两样本值的平均数，一共取得m-1个划分点，其中第i个划分点<span class="math inline">\(T_i\)</span>表示为 <span class="math inline">\(T_i = \frac{a_i + a_{i+1}}{2}\)</span>,然后就是对于这m-1个点，分别计算以该点作为二元分类点时的基尼系数。选择基尼系数最小的点作为该连续特征的二元离散分类点。比如取到的基尼系数最小的点为𝑎𝑡,则小于𝑎𝑡的值为类别1，大于𝑎𝑡的值为类别2，这样我们就做到了连续特征的离散化。要注意的是，与ID3或者C4.5处理离散属性不同的是，如果当前节点为连续属性，则该属性后面还可以参与子节点的产生选择过程。</p><p>对于CART分类树离散值的处理问题，采用的思路是不停的二分离散特征。</p><p>回忆下ID3或者C4.5，如果某个特征A被选取建立决策树节点，如果它有A1,A2,A3三种类别，我们会在决策树上一下建立一个三叉的节点。这样导致决策树是多叉树。但是CART分类树使用的方法不同，他采用的是不停的二分，还是这个例子，CART分类树会考虑把A分成{𝐴1}和{𝐴2,𝐴3}, {𝐴2}和{𝐴1,𝐴3}, {𝐴3}和{𝐴1,𝐴2}三种情况，找到基尼系数最小的组合，比如{𝐴2}和{𝐴1,𝐴3},然后建立二叉树节点，一个节点是A2对应的样本，另一个节点是{A1,A3}对应的节点。同时，由于这次没有把特征A的取值完全分开，后面我们还有机会在子节点继续选择到特征A来划分A1和A3。这和ID3或者C4.5不同，在ID3或者C4.5的一棵子树中，离散特征只会参与一次节点的建立。</p><p>在真实世界中，常常会面临样本具有特征缺失的情况。我们需要解决两个问题 (1)如何在属性值缺失的情况下进行划分属性选择 (2)给定划分属性，若样本在该属性上的值缺失，如何对样本划分？</p><h3 id="variance系数">variance系数</h3><p>分类时，如果待分类样本有缺失变量，而决策树决策过程中没有用到这些变量，则决策过程和没有缺失的数据一样；否则，如果决策要用到缺失变量，决策树也可以在当前节点做多数投票来决定。回归的话，多数投票会换成局部回归等类似的方法。这样决策树就能给缺失变量的样本一个预测了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程-parser和generator</title>
      <link href="/2021/08/26/%E7%BC%96%E7%A8%8B-parser%E5%92%8Cgenerator/"/>
      <url>/2021/08/26/%E7%BC%96%E7%A8%8B-parser%E5%92%8Cgenerator/</url>
      
        <content type="html"><![CDATA[<p>最近在有关NLP相关的内容，不知怎的居然逐渐投入到计算机语言的研究去了，特别是编译原理。看来自然语言和计算机语言也是有某种互通吧。看的东西很多也很杂。感觉好多知识都是似曾相识。不管怎样，先写一篇博客，稍稍记录一下我的学习成果。</p><span id="more"></span><h2 id="parser是什么">parser是什么</h2><p>从某种程度上来说，parser并不难。从整个编译技术栈来看，parser的地位非常靠前，它的结果很重要，难度却并不高。所谓 parser，一般是指把某种格式的文本（字符串）转换成某种数据结构的过程。最常见的 parser，是把程序文本转换成编译器内部的一种叫做“抽象语法树”（AST）的数据结构。也有简单一些的 parser，用于处理 CSV，JSON，XML 之类的格式。</p><h2 id="语言">语言</h2><p>在讲语言之前，我们先引入下面两个概念:</p><ol type="1"><li><p>字母表 字母表我们用<span class="math inline">\(\Sigma\)</span>表示，是一个有穷的字符集合。比如对于英语，是一个26个字母(假设不分大小写)组成的字母表。又比如计算机常见的ASCII字符集。</p></li><li><p>符号串 由字母表中的符号组成的任何有穷序列称为符号串。串 s 的长度，通常记作 |s| ，是指 s 中符号的个数。例：|aab|=3。 空串是长度为 0 的串，用<span class="math inline">\(\epsilon\)</span> 表示，<span class="math inline">\(|\epsilon|=0\)</span>。</p></li></ol><p>大体上语言可以分为形式语言和自然语言，在这篇文章中出现的语言都是指形式语言。形式语言（Formal Language）是为了特定应用而人为设计的语言。例如数学家用的数字和运算符号、化学家用的分子式等。编程语言也是一种形式语言，是专门设计用来表达计算过程的形式语言。</p><p>从字面上看，每个程序都是一个“基本符号”串，设有一基本符号串，那么编程语言可看成是在这个基本符号集上定义的，按一定规则构成的一切基本符号串组成的集合。</p><p>字母表相关的运算:</p><ul><li><p>字母表与字母表的乘积 <img src="alphabetproduct.png" /></p></li><li><p>字母表的n次幂: 长度为n的符号串构成的集合 <img src="alphabetNpower.png" /></p></li><li><p>字母表的正闭包：长度正数的符号串构成的集合 <img src="alphabetPositiveClosure.png" /></p></li><li><p>字母表的克林闭包：任意符号串（长度可以为零）构成的集合 <img src="alphabetKleeneClosure.png" /></p></li><li><p>串的幂运算：将 n 个 串连接起来。 <img src="strPower.png" /></p></li></ul><h2 id="文法语法grammer">文法(语法)Grammer</h2><p>文法是台湾地区的习惯用法。</p><h3 id="语法的形式化定义">语法的形式化定义</h3><p><span class="math inline">\(G=(V_T,V_N,P,S)\)</span></p><ul><li>G表示文法，文法由一个四元组定义</li><li><span class="math inline">\(V_T\)</span>: 终结符集合<ul><li>终结符(terminal symbol)是文法所定义的语言的基本符号，有时也称为token。</li><li>例如：<span class="math inline">\(V_T = \{ a p p l e , b o y , e a t , l i t t l e \}\)</span> ​</li></ul></li><li><span class="math inline">\(V_N\)</span>：非终结符集合<ul><li>非终结符(nonterminal) 是用来表示语法成分的符号，有时也称为“语法变量</li><li>例如 <span class="math inline">\(V_N =\{&lt;句子&gt;,&lt;名词短语&gt;,&lt;动词短语&gt;,&lt;名词&gt;,…\}\)</span></li><li>因为从它们可以推出其他的语法成分，所以被称为非终结符</li></ul></li><li>终结符集合和非终结符集合都是字母表</li><li>终结符集合与非终结符集合是不相交的，<span class="math inline">\(V_T \bigcap V_N = \phi\)</span></li><li>而终结符集合与非终结符集合的并集是文法符号集，<span class="math inline">\(V_T \bigcup V_N\)</span>: 文法符号集 ​</li><li>P：产生式集合，产生式描述了将终结符和非终结符组合成串的方法。<ul><li>产生式的一般形式：<span class="math inline">\(\alpha \rightarrow{\beta}\)</span></li><li>读作：<span class="math inline">\(\alpha\)</span> 定义为 <span class="math inline">\(\beta\)</span></li><li><span class="math inline">\(\alpha \in (V_T \cup V_N)^+\)</span>且 <span class="math inline">\(\alpha\)</span>中至少包含<span class="math inline">\(V_N\)</span>中的一个元素：称为产生式的头(head)或左部(left side)。</li><li><span class="math inline">\(\beta \in (V_T \cup V_N)^*\)</span> : 称为产生式的体（body）或者右部（right side）</li></ul></li><li><span class="math inline">\(S \in V_N\)</span> 开始符号表示的是该文法中最大的语法成分。<ul><li>例如：S=<句子></li></ul></li><li>a对一组有相同左部的<span class="math inline">\(\alpha\)</span>产生式，<span class="math inline">\(\alpha \rightarrow \beta_1,\alpha \rightarrow \beta_2 .... \alpha \rightarrow \beta_n\)</span> 可以简记 <span class="math inline">\(\alpha \rightarrow \beta_1 | \beta_2 |...|\beta_n\)</span>, <span class="math inline">\(\beta_1, \beta_2 ... \beta_n\)</span> 被称作<span class="math inline">\(\alpha\)</span>的候选式</li></ul><h3 id="符号约定">符号约定</h3><ul><li>下列符号是终结符<ul><li>字母表中排在前面的小写字母，如a、b、c</li><li>运算符，如+，*等</li><li>标点符号，如逗号，括号等</li><li>数字，0、1、2…、9</li><li>粗体字符串，如id、if等</li></ul></li><li>下列符号是非终结符<ul><li>字母表中排在前面的大写字母，如A、B、C</li><li>字母S，通常表示开始符号</li><li>小写、斜体的名字，如expr、stmt等</li><li>代表程序构造的大写字母。如E（表达式）、T（项）和F（因子）</li></ul></li><li>字母表中排在后面的大写字母（如X、Y、Z）表示文法符号（即终结符或非终结符）</li><li>字母表中排在后面的小写字母（主要是u、v、…、z）表示终结符号串（包括空串）</li><li>小写希腊字母，如α 、β 、γ ，表示文法符号串（包括空串）</li><li>如非特别说明，第一个产生式的左部就是开始符号</li></ul><h3 id="推导和规约">推导和规约</h3><p>在编译原理的总结之中，我们知道一个句子可能存在多种推导方式，所以我们约定两种特殊的推导方式（顺序），即最左推导和最右推导。句子的推导是我们从开始符号，推出我们想要的句子的过程。与之相反，拿到一个句子，我们反推回开始符号，这个过程是句子的规约。因此，最左推导和最右推导分别对应最右规约和最左规约。上述概念的形式化定义如下</p><ul><li><p>最右推导（规范推导）： 对于直接推导 <span class="math inline">\(x \rightarrow y\)</span>，如果y只包含终结符号或者为空符号串（相当于右边已经没有可以被拆分的非终结符了），那么，就把这种直接推导称为规范推导。</p></li><li><p>最左推导： 与最右推导相反。</p></li><li><p>最左规约： 为最右推导的逆过程，对于一个句子，每次都从最左端，可规约的符号或符号串（句柄）来规约。</p></li></ul><p><img src="derivation.png" /></p><p><img src="Nderive.png" /></p><p><img src="derivereduce.png" /></p><p>对于所有合法的推导过程，都能通过语法树的形式进行表示（多对一）。例如给定文法: E::= E＋E|E * E|(E)|i，那么对于一个句子 S = i + i * i 存在不同的规范推导 <img src="2derive.png" /></p><h3 id="短语简单短语与句柄">短语、简单短语与句柄</h3><p>给定一个句子S（如i+i * i），找到它的短语、简单短语与句柄主要依靠其语法树。其中短语是语法树子树的所有叶节点组成的符号串，也就是说有多少个子树，就有多少个短语。简单短语是语法树简单子（高度为2）的所有叶节点组成的符号串。句柄是最左简单子树（高度为2）的所有叶节点组成的符号串。</p><p>我们不妨看上图左边的语法树。对于句子i + i * i，短语有i+i * i, i, i * i。简单短语有i（三个），句柄为最左边的i</p><p>所以短语 简单短语 句柄的定义如下</p><ul><li><p>短语：一个句型的语法树中任一子树的叶节点所组成的符号串都是该句型的短语</p></li><li><p>简单短语: 一个句型的语法树中任一最小子树的叶节点所组成的符号串都是该句型的短语</p></li><li><p>句柄： 句柄是最左边的直接短语</p></li></ul><p>给定一个句型，其分析树中的每一颗子树的边缘称为该句型的一个短语。</p><p>如果子树只有父子两代节点，那么这课子树的边缘称为该句型的一个直接短语。</p><p><img src="phrase.png" /></p><h3 id="句型和句子">句型和句子</h3><p><img src="sen.png" /></p><p><img src="sens.png" /></p><h3 id="语言的形式化定义">语言的形式化定义</h3><p><img src="L.png" /></p><p><img src="Lcompute.png" /></p><h2 id="文法分类">文法分类</h2><h3 id="型文法无限制文法">0型文法，无限制文法</h3><p><img src="type0.png" /></p><h3 id="型文法上下文有关文法">1型文法，上下文有关文法</h3><p><img src="type1.png" /></p><h3 id="型文法上下文无关文法">2型文法，上下文无关文法</h3><p><img src="type2.png" /></p><h3 id="型文法正则文法">3型文法，正则文法</h3><p><img src="type3.png" /></p><h3 id="种文法总结">4种文法总结</h3><ol type="1"><li><p>0型文法 限制最少，其实就是，<span class="math inline">\(\rightarrow\)</span>的左边，是非终结符和终结符的组合，由于终结符是有<span class="math inline">\(\epsilon\)</span>这个空存在的，所以，这就相当于只要有一个非终结符，其他怎么样都行。<span class="math inline">\(rightarrow\)</span>的右边，没有任何限制。</p></li><li><p>1型文法 1型加的限制就是，对任一产生式<span class="math inline">\(\alpha \rightarrow \beta\)</span>，都有<span class="math inline">\(|\beta| &gt;= |\alpha|\)</span>， 仅仅 <span class="math inline">\(S \rightarrow \epsilon\)</span> 除外，其生成式的一般表达式应该为：α1Aα2→α1βα2，A在终结符集合中，剩下的符号都是任意的（终结符和非终结符的集合）举个例子来说明：</p><pre><code> A→aB S→abc bB→bc aB→bB</code></pre></li></ol><p>我们在上述例子的第一个规则中A→aB中，想把B给替换掉，但是我们发现，没有B→这样的规则，然而，聪明的我们又发现，有aB→这样的式子，所以我们就把aB替换成了bB，然后bB又可以替换成bc。 这其实就表达了这样一个意思，我要换这个B啊，必须得和他周围的东西一起换掉，就好像超市，B单独一个东西卖不出去，只有打包才行，所以，1型文法又称为上下文有关文法。</p><ol start="3" type="1"><li><p>2型文法 2型文法的限制就是，→的左边，都只能存在一个非终结符，那种AA，aB，aBc之类的就不能存在了，左边必须单身狗，→的右边依旧很自由，什么都可以（终结符和非终结符的集合） 比如： A→aB</p><pre><code> S→bAA B→a C→abA</code></pre></li></ol><p>大家会发现，当我要在A→aB中，把B替换掉的时候，由于存在B→a，所以直接就可以替换掉B，而不用在乎A→aB这个式子的B的旁边有没有别的东西，所以，2型文法又叫做上下文无关文法。</p><ol start="4" type="1"><li><p>3型文法 又称为正规文法，它的限制可就十分之死板了，它只允许两种形式的产生式存在，一个是A→aB，一个是A向右a，A和B都是非终结符，a则是终结符。举个例子： S→aA</p><pre><code> S→a A→bB A→b</code></pre></li></ol><p>反正就是只有两种格式(左线性文法 右线性文法)的式子允许存在，所以正规文法其实是很少的。</p><h3 id="种文法关系">4种文法关系</h3><p><img src="typeRelation.png" /></p><p><img src="cfg.png" /></p><p>分析树是推导的图形化表示</p><p><img src="cfgderive.png" /></p><h2 id="二义性文法">二义性文法</h2><p>如果一个文法可以为某个句子生成多棵分析树，则称这个文法是二义性的。</p><p><img src="ambiguity.png" /></p><h3 id="二义性文法的判定">二义性文法的判定</h3><p>对于任意一个上下文无关文法，不存在一个算法，判断它是无二义性的，但能给出一组充分条件，满足这组充分条件的文法是无二义性的。 * 满足，肯定无二义性 * 不满足，也未必就是有二义性的</p><h2 id="基于scala-parser-combinator实现parser">基于Scala parser combinator实现parser</h2><h3 id="语法格式描述规范">语法格式描述规范</h3><ul><li><p>BNF 是最原始，最简单的方法，主要用于理论背景的学术论文中，以与人类进行交流。（与在编译器/解析器中使用相反）。BNF 没有确切的规范。</p></li><li><p>EBNF 是 Extended BNF （扩展的BNF）的缩写。没有一个标准的 EBNF，因为每个作者或程序都定义了自己的稍有不同的 EBNF 变体。</p></li><li><p>ABNF 是 augmented BNF（增强型BNF）的缩写，ABNF 的语法 与 BNF 完全不同，但是更加标准化，利于解析器的翻译，但不利于阅读；</p></li></ul><p>但是 BNF、EBNF、ABNF 这三者的表达能力是等效的；它们只是语法上的差异。</p><ul><li><p>举例1：在传统的 BNF 中，左式 和 右式 的 分隔符（即：定义符）通常是::=，而在书籍中通常是 →，在 EBNF 和 ABNF 中是 =；</p></li><li><p>举例2：在传统的 BNF 中，非终结符用尖括号括起来，例如，<EXPR>终结符不用加任何额外的符号，用普通字符表示即可。而在 ABNF 中，非终结符用普通字符表示，终结符需要用双引号括起来，例如&quot;+&quot; ；</p></li><li><p>举例3：在 BNF 和 EBNF 中，替代符号（选项符号）是 |，在 ABNF 中，替代符号是 /；</p></li><li><p>举例4：EBNF 和 ABNF 还具有快捷语法语法，比如指定 0个 或 多个 重复项。要将其用 BNF 表示，则需要引入更多规则。</p></li></ul><h3 id="bnf规则">BNF规则</h3><table><colgroup><col style="width: 10%" /><col style="width: 30%" /><col style="width: 60%" /></colgroup><thead><tr class="header"><th>符号</th><th>含义</th><th>举例</th></tr></thead><tbody><tr class="odd"><td>::=</td><td>是“被定义为”的意思</td><td>示例：字符串 ::= 用引号包围的字符序列，表示 字符串 就是 用引号包围的字符序列 json ::= &quot;{&quot; [members] &quot;}&quot;</td></tr><tr class="even"><td>&quot;...&quot;</td><td>终结符，即引号中的字符序列本身，并非指代其它字。而终结符双引号 &quot; 用 double_quote 用来表示</td><td>示例：函数调用 ::= 名字 &quot;()&quot; 表示 函数的调用 是 由 名字 加上左右括号字符 () 组成</td></tr><tr class="odd"><td>语法部分</td><td></td><td>示例：基本类型 ::= 字符串</td></tr><tr class="even"><td>&lt;...&gt;</td><td>必选项</td><td>示例：名字 ::= [姓] <名> 表示 名字 中的 名 是必须要有的，但 姓 是可有可无的，即：姓 名 是 名字，名 也是 名字</td></tr><tr class="odd"><td>[...]</td><td>可选，可有可无</td><td>示例：名字 ::= [姓] <名> 表示 名字 中的 名 是必须要有的，但 姓 是可有可无的，即：姓 名 是 名字，名 也是 名字</td></tr><tr class="even"><td>{...}</td><td>重复，0 或 任意次重复</td><td>示例：AB ::= &quot;a&quot; {&quot;b&quot;}，表示 AB 是由 一个 a 后面跟上任意数量（包括0个）个 b 组成，如 a、a b、a bb、a bbb</td></tr><tr class="odd"><td>(...)</td><td>分组，用来控制表达式的优先级</td><td>示例：AX ::= &quot;a&quot; (&quot;m&quot;|&quot;n&quot;)，表示 AX 是由 一个 a 后面跟上 m 或 n 组成</td></tr><tr class="even"><td>|</td><td>替换，即 或 的意思</td><td>示例：布尔 ::= &quot;true&quot; | &quot;false&quot;，表示 true 或 false 都是 布尔</td></tr><tr class="odd"><td>...</td><td>表示各种列举或省略的代码片断</td><td>示例：a...z 表示 从 a 到 z 的字符，&quot;...&quot; 表示 由 双引号 &quot; 包围起来的任意字符</td></tr></tbody></table><p>基于BNF我们可以写出json的文法规则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">json ::= <span class="string">&quot;&#123;&quot;</span> [members] <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">array ::= <span class="string">&quot;[&quot;</span> [values] <span class="string">&quot;]&quot;</span></span><br><span class="line">members ::= member &#123;<span class="string">&quot;,&quot;</span> member&#125;</span><br><span class="line">member ::= stringLiteral <span class="string">&quot;:&quot;</span> value</span><br><span class="line">values ::= value &#123;<span class="string">&quot;,&quot;</span> value&#125;</span><br><span class="line">value ::= json | array | stringLiteral | floatingPointNumber |<span class="string">&quot;null&quot;</span> | <span class="string">&quot;true&quot;</span> | <span class="string">&quot;false&quot;</span></span><br></pre></td></tr></table></figure><h3 id="ebnf">EBNF</h3><p>用 EBNF范式 来描述 EBNF 的语法</p><table><colgroup><col style="width: 7%" /><col style="width: 46%" /><col style="width: 46%" /></colgroup><thead><tr class="header"><th>符号</th><th>含义</th><th>举例</th></tr></thead><tbody><tr class="odd"><td>=</td><td>定义</td><td>示例：字符串 = 用引号包围的字符序列，表示 字符串 就是 用引号包围的字符序列</td></tr><tr class="even"><td>,</td><td>串接</td><td>示例：张三= 'zhang', 'san' 表示 张三 是由 zhang 和 san 组成</td></tr><tr class="odd"><td>;</td><td>终止，表示一个定义语句结束了，在没有歧义的情况下可省略</td><td>示例：变量名字 = 标识符 ; 类型名字 = 标识符</td></tr><tr class="even"><td>|</td><td>替换，即 或 的意思</td><td>示例：布尔 = 'true'</td></tr><tr class="odd"><td>[...]</td><td>可选，可有可无</td><td>示例：名字 = [姓] 名 表示 名字 中的 姓 是可有可无的，即：姓 名 是 名字，名 也是 名字；</td></tr><tr class="even"><td>{...}</td><td>重复，0 或 任意次重复</td><td>示例：AB = 'a' {'b'}，表示 AB 是由 一个 a 后面跟上任意数量（包括0个）个 b 组成，如 a、a b、a bb、a bbb</td></tr><tr class="odd"><td>(...)</td><td>分组，用来控制表达式的优先级</td><td>示例：AX = 'a' ('m'|'n')，表示 AX 是由 一个 a 后面跟上 m 或 n 组成</td></tr><tr class="even"><td>'...'</td><td>终结符，即引号中的字符序列本身，并非指代其它字</td><td>示例：函数调用 = 名字 '()' 表示 函数的调用 是 由 名字 加上左右括号字符 () 组成</td></tr><tr class="odd"><td>&quot;...&quot;</td><td>终结符</td><td>同 '...'</td></tr><tr class="even"><td>(<em>...</em>)</td><td>注释</td><td>说明性文本，不表示任何语法</td></tr><tr class="odd"><td>?...?</td><td>特殊序列</td><td></td></tr><tr class="even"><td>-</td><td>排除</td><td>除去</td></tr></tbody></table><p>EBNF语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">生成式 = 生成式名 <span class="string">&#x27;=&#x27;</span> [ 表达式 ] [<span class="string">&#x27;;&#x27;</span>] ;</span><br><span class="line">表达式 = 选择项 &#123; <span class="string">&#x27;|&#x27;</span> 选择项 &#125; ;</span><br><span class="line">选择项 = 条目 &#123; 条目 &#125; ;</span><br><span class="line">条目   = 生成式名 | 标记 [ <span class="string">&#x27;…&#x27;</span> 标记 ] | 分组 | 可选项 | 重复项 ;</span><br><span class="line">分组   = <span class="string">&#x27;(&#x27;</span> 表达式 <span class="string">&#x27;)&#x27;</span> ;</span><br><span class="line">可选项 = <span class="string">&#x27;[&#x27;</span> 表达式 <span class="string">&#x27;]&#x27;</span> ;</span><br><span class="line">重复项 = <span class="string">&#x27;&#123;&#x27;</span> 表达式 <span class="string">&#x27;&#125;&#x27;</span> ;</span><br></pre></td></tr></table></figure><p>生成式由表达式构造，表达式通过术语及以下操作符构造，自上而下优先级递增（低=&gt;高):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|   选择</span><br><span class="line">()  分组</span><br><span class="line">[]  可选（<span class="number">0</span> 或 <span class="number">1</span> 次）</span><br><span class="line">&#123;&#125;  重复（<span class="number">0</span> 到 n 次）</span><br></pre></td></tr></table></figure><h3 id="增强型巴科斯范式abnf">增强型巴科斯范式ABNF</h3><p>RFC2234 定义了增加型巴科斯范式(ABNF)。近年来在Internet的定义中 ABNF 被广泛使用。ABNF 做了更多的改进。增强型巴科斯-瑙尔范式(ABNF)基于了巴科斯-瑙尔范式(BNF)，但由它自己的语法和推导规则构成。这种元语言的发起原则是描述作为通信协议(双向规范)的语言的形式系统。它建档于 RFC 4234 中通常充当 IETF 通信协议的定义语言。</p><table><colgroup><col style="width: 11%" /><col style="width: 33%" /><col style="width: 55%" /></colgroup><thead><tr class="header"><th>符号</th><th>含义</th><th>事例</th></tr></thead><tbody><tr class="odd"><td>=</td><td>规则 = 定义</td><td></td></tr><tr class="even"><td></td><td>空白被用来分隔定义的各个元素 要使空格被识别为分割符则必须明确的包含它。</td><td></td></tr><tr class="odd"><td>规则1 规则2</td><td>串联 规则可以通过列出一序列的规则名字来定义。</td><td>fu = %x61; a <br> bar = %x62; b <br> mumble = fu bar fu</td></tr><tr class="even"><td>/</td><td>选择 规则1 / 规则2</td><td>fubar = fu / bar</td></tr><tr class="odd"><td>规则1 =/ 规则2</td><td>递增选择 可以通过使用在规则名字和定义之间的“=/”来向一个规则增加补充选择。</td><td>ruleset = alt1 / alt2 / alt3 / alt4 / alt5 等价于 <br> ruleset = alt1 / alt2<br>ruleset =/ alt3 <br> ruleset =/ alt4 / alt5</td></tr><tr class="even"><td>%c##-##</td><td>数值范围可以通过使用连字符(“-”)来指定。</td><td>OCTAL = &quot;0&quot; / &quot;1&quot; / &quot;2&quot; / &quot;3&quot; / &quot;4&quot; / &quot;5&quot; / &quot;6&quot; / &quot;7&quot; 等价于<br> OCTAL = %x30-37</td></tr><tr class="odd"><td>(规则1 规则2)</td><td>元素可以放置在圆括号中来组合定义中的规则。</td><td>要匹配“elem fubar snafu”或“elem tarfu snafu”可以构造下列规则：<br> group = elem (fubar / tarfu) snafu</td></tr><tr class="even"><td>n*m规则</td><td>规则重复最小n次 最大m次</td><td></td></tr></tbody></table><p>上述操作符有从最紧绑定(binding)到最松绑定的给定优先级:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 字符串，名字形成(formation)</span><br><span class="line"><span class="bullet">2.</span> 注释</span><br><span class="line"><span class="bullet">3.</span> 值范围</span><br><span class="line"><span class="bullet">4.</span> 重复</span><br><span class="line"><span class="bullet">5.</span> 分组，可选</span><br><span class="line"><span class="bullet">6.</span> 串联</span><br><span class="line"><span class="bullet">7.</span> 选择</span><br></pre></td></tr></table></figure><h3 id="scala-parser-combinator">scala parser combinator</h3><p>在使用这个解析库时，只需要写出BNF，对照着翻译成代码，那么scala就会根据递归下降自动完成解析。非常方便，这种方便依赖于scala提供的pattern match。和BNF的对照关系见下表</p><table><colgroup><col style="width: 16%" /><col style="width: 83%" /></colgroup><thead><tr class="header"><th>scala操作符号</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>~</td><td>连接词，用于连接两个token，实际上是一个case类，定义：case class ~<a href="_1:%20a,%20_2:%20b">+a, +b</a></td></tr><tr class="even"><td>|</td><td>或操作，和BNF中的|等同</td></tr><tr class="odd"><td>rep</td><td>用于替换BNF中的大括号，该函数返回Parser[List]，此外还有一个rep1，和rep的区别是：rep表示0或多个，而rep1是一或多个</td></tr><tr class="even"><td>^^</td><td>转换parser的结果，即^^后面的函数处理parser解析的值，可以理解为map函数</td></tr><tr class="odd"><td>&lt;~</td><td>提取器，因为 '~' 会出现在字面量中，需要进一步case匹配对应的 '~' ，为提取更快捷，提供 '~&gt;' 用于提取右边的结果、'&lt;~'提取其左边的结果，一般配对使用</td></tr></tbody></table><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.<span class="type">Map</span></span><br><span class="line"><span class="keyword">import</span> scala.util.parsing.combinator.<span class="type">JavaTokenParsers</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonParser</span> <span class="keyword">extends</span> <span class="title">JavaTokenParsers</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">json</span></span>: <span class="type">Parser</span>[<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Any</span>]] = <span class="string">&quot;&#123;&quot;</span> ~&gt; repsep(member, <span class="string">&quot;,&quot;</span>) &lt;~ <span class="string">&quot;&#125;&quot;</span> ^^ &#123;</span><br><span class="line">    <span class="type">Map</span>() ++ _</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">member</span></span>: <span class="type">Parser</span>[(<span class="type">String</span>, <span class="type">Any</span>)] = stringLiteral ~ <span class="string">&quot;:&quot;</span> ~ value ^^ &#123; <span class="keyword">case</span> k ~ <span class="string">&quot;:&quot;</span> ~ v =&gt; (k, v) &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: <span class="type">Parser</span>[<span class="type">Any</span>] = json | array | stringLiteral | floatingPointNumber ^^ &#123;</span><br><span class="line">    _.toDouble</span><br><span class="line">  &#125; |</span><br><span class="line">    <span class="string">&quot;null&quot;</span> ^^ &#123; _ =&gt; <span class="literal">null</span> &#125; | <span class="string">&quot;true&quot;</span> ^^ &#123; _ =&gt; <span class="literal">true</span> &#125; | <span class="string">&quot;false&quot;</span> ^^ &#123; _ =&gt; <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">array</span></span>: <span class="type">Parser</span>[<span class="type">List</span>[<span class="type">Any</span>]] = <span class="string">&quot;[&quot;</span> ~&gt; repsep(value, <span class="string">&quot;,&quot;</span>) &lt;~ <span class="string">&quot;]&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(str: java.lang.<span class="type">CharSequence</span>) = <span class="keyword">super</span>.parseAll(json, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>又比如一个加减乘除计算器</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.<span class="type">Map</span></span><br><span class="line"><span class="keyword">import</span> scala.util.parsing.combinator.<span class="type">JavaTokenParsers</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * * expr ::= term &#123;&quot;+&quot; term | &quot;-&quot; term&#125;</span></span><br><span class="line"><span class="comment"> * * term ::= factor &#123;&quot;*&quot; factor | &quot;/&quot; factor&#125;</span></span><br><span class="line"><span class="comment"> * * factor ::= floatingPointNumber | &quot;(&quot; expr &quot;)&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Calculator2</span> <span class="keyword">extends</span> <span class="title">JavaTokenParsers</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">expr</span></span>: <span class="type">Parser</span>[<span class="type">Double</span>] = term ~ rep((<span class="string">&quot;+&quot;</span> | <span class="string">&quot;-&quot;</span>) ~ term) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> n ~ r =&gt; r.foldRight(n) &#123;</span><br><span class="line">      (a, b) =&gt;</span><br><span class="line">        a <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;+&quot;</span> ~ x =&gt; b + x</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;-&quot;</span> ~ x =&gt; b - x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">term</span></span>: <span class="type">Parser</span>[<span class="type">Double</span>] = factor ~ rep((<span class="string">&quot;*&quot;</span> | <span class="string">&quot;/&quot;</span>) ~ factor) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> n ~ r =&gt; r.foldRight(n) &#123;</span><br><span class="line">      (a, b) =&gt;</span><br><span class="line">        a <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;*&quot;</span> ~ x =&gt; b * x</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;/&quot;</span> ~ x =&gt; b / x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">factor</span></span>: <span class="type">Parser</span>[<span class="type">Double</span>] = floatingPointNumber ^^ &#123;</span><br><span class="line">    _.toDouble</span><br><span class="line">  &#125; | <span class="string">&quot;(&quot;</span> ~&gt; expr &lt;~ <span class="string">&quot;)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="generator">Generator</h2><p>相比于parser，generator就简单多了，还是充分利用pattern match的特性 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(x: <span class="type">Any</span>): <span class="type">String</span> = &#123;</span><br><span class="line">  x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> j: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Any</span>] =&gt; <span class="string">&quot;&#123;&quot;</span> + j.map &#123; <span class="keyword">case</span> (k, v) =&gt; <span class="string">&quot;\&quot;&quot;</span> + k + <span class="string">&quot;\&quot;&quot;</span> + <span class="string">&quot;:&quot;</span> + foo(v) &#125;.mkString(<span class="string">&quot;,&quot;</span>) + <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">    <span class="keyword">case</span> j: <span class="type">List</span>[<span class="type">Any</span>] =&gt; <span class="string">&quot;[&quot;</span> + j.map(v =&gt; foo(v)).mkString(<span class="string">&quot;,&quot;</span>) + <span class="string">&quot;]&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">null</span> =&gt; <span class="string">&quot;null&quot;</span></span><br><span class="line">    <span class="keyword">case</span> j: <span class="type">String</span> =&gt; <span class="string">&quot;\&quot;&quot;</span> + j + <span class="string">&quot;\&quot;&quot;</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; x.toString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> m = <span class="type">Map</span>(<span class="string">&quot;1&quot;</span> -&gt; <span class="type">List</span>(<span class="number">2.0</span>, <span class="number">3.0</span>), <span class="string">&quot;2&quot;</span> -&gt; <span class="type">List</span>(<span class="type">Map</span>(<span class="string">&quot;3&quot;</span> -&gt; <span class="literal">true</span>, <span class="string">&quot;5&quot;</span> -&gt; <span class="literal">null</span>), <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="string">&quot;asfasf&quot;</span>))</span><br><span class="line"><span class="comment">//val m = List(1, 2, 3)</span></span><br><span class="line">println(m, foo(m))</span><br></pre></td></tr></table></figure></p><h2 id="小结">小结</h2><ol type="1"><li>四种文法定义以及关系</li><li>描述文法的方法有BNF，EBNF，ABNF</li><li>写出某文法的BNF表达式，并基于scala parser combinator 即可开发出相应的parser</li><li>parser 和generator 都是充分使用了scala的pattern match</li></ol><p>参考:</p><ol type="1"><li><p><a href="https://blog.csdn.net/Jurbo/article/details/78012604" class="uri">https://blog.csdn.net/Jurbo/article/details/78012604</a></p></li><li><p><a href="https://blog.csdn.net/zgljl2012/article/details/53883459" class="uri">https://blog.csdn.net/zgljl2012/article/details/53883459</a></p></li><li><p><a href="http://www.360doc.com/content/16/1225/10/38836195_617479642.shtml" class="uri">http://www.360doc.com/content/16/1225/10/38836195_617479642.shtml</a></p></li><li><p><a href="https://www.jianshu.com/p/15efcb0c06c8" class="uri">https://www.jianshu.com/p/15efcb0c06c8</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-embedding之word2vec</title>
      <link href="/2021/07/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-embedding%E4%B9%8Bword2vec/"/>
      <url>/2021/07/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-embedding%E4%B9%8Bword2vec/</url>
      
        <content type="html"><![CDATA[<p>2014年的那篇 <a href="https://arxiv.org/pdf/1301.3781.pdf">Efficient Estimation of Word Representations in Vector Space</a> 第一次提出了将序列数据映射成向量的方法，自此也拉开了对于embedding技术的深度讨论。这篇文章将会总结word2vec背后的技术原理以及细节。 <span id="more"></span></p><h2 id="语言模型">语言模型</h2><h3 id="n-gram模型">N-gram模型</h3><p>N-gram本质上是一个统计模型，它的思想很简单。假设一个长度M的词序列为<span class="math inline">\(w_1^M = {w_1, w_2, ..w_M}\)</span>那么我们有</p><p><span class="math display">\[P(W) = \prod_{m=1}^M P(w_m|w_1^{m-1})\]</span></p><p>上面这个条件概率的意思是第m个单词的概率由它之前的m-1个单词决定(一个句子内)。我们稍微把<span class="math inline">\(P(w_m|w_1^{m-1})\)</span> 近似成<span class="math inline">\(P(w_m|w_{m-n+1}^{m-1})\)</span>。也就是说，下一个单词的概率只和之前的N个单词有关。 N-gram模型是一个N-阶的马尔可夫链，每一个状态只依赖之前的N-1个时刻，与更久远的历史无关。</p><p>在实际对语料库进行统计时，我们会采用以下近似</p><p><span class="math display">\[p(w_k|w_1, w_2, ..., W_{k-1}) \simeq \frac{count(w_{k- n + 1}, ... ,w_{k})}{count(w_{k-n+1}, ..., w_{k-1})}\]</span></p><p>一般N-gram模型我们会取N=3, 计算出所有概率。另外，n-gram模型中还有一个叫做平滑化的重要环节。试想如果某个组合的count为0，我们能认为概率为0吗？在这种情况下需要使用平滑技术。</p><p>总结起来，n-gram模型是这样一种模型，其主要工作是在语料中统计各种词串出现的次数以及平滑化处理。概率值计算好之后就存储起来，下次需要计算一个句子的概率时，只需找到相关的概率参数，将它们连乘起来就好了。</p><h3 id="神经网络语言模型">神经网络语言模型</h3><p>词向量是训练神经网络的副产品，对于词汇表中的任一个单词，我们用一个低秩向量表示。训练一个以得到词向量为目标的神经网络，会从以下方面考虑</p><ol type="1"><li>词语之间的相似性可以通过词向量来体现</li><li>相似的”的词对应的词向量也是相似的</li><li>概率函数关于词向量是光滑的，即词向量中的一个小变化对概率的影响也只是一个小变化。这样一来，对于下面这些句子， 只要在语料库中出现一个，其他句子的概率也会相应的增大</li></ol><blockquote><p>A dog is running in the room<br />A cat is running in the room<br />The cat is running in a room<br />A dog is walking in a bedroom<br />The dog was walking in the room</p></blockquote><p>常见的词向量表示方式有 one-hot representation 和 Distributed representation</p><h4 id="one-hot-representation">one-hot representation</h4><p>一种最简单的词向量方式是One-Hot编码 ，就是用一个很长的向量来表示一个词，向量的长度为词典的大小，向量中只有一个 1 ， 其他全为 0 ，1 的位置对应该词在词典中的位置。 但是这种方法存在一些问题</p><ol type="1"><li>容易出现维灾</li><li>无法表达词和词之间的相似性</li><li>稀疏性无法保证有效训练 存在训练不充分的问题</li></ol><h4 id="distributed-representation">distributed representation</h4><p>Distributed Representation最早是Hinton于1986年提出的，可以克服One-Hot Representation的上述缺点。其基本想法是：通过训练将某种语言中的每一个词 映射成一个固定长度的短向量（当然这里的“短”是相对于One-Hot Representation的“长”而言的），所有这些向量构成一个词向量空间，而每一个向量则可视为 该空间中的一个点，在这个空间上引入“距离”，就可以根据词之间的距离来判断它们之间的语法、语义上的相似性了。Word2Vec中采用的就是这种Distributed Representation 的词向量。</p><h3 id="word2vec">word2vec</h3><p>word2vec本质是一个分类任务，中心词和上下文词的共现性来刻画词和词之间的相似性。损失函数可以从最大似然函数或者最小交叉熵(二者是一致的，似然函数maxmize可以通过添加符号做形式变换整理成最小交叉熵的形式)。 同时机器学习使用的交叉熵损失函数和信息论的交叉熵略有不同</p><ol type="1"><li><p>在机器学习看来，信息论里的交叉熵仅仅是针对一个样本的交叉熵，在机器学习进行优化时，会把所有样本的交叉熵值做一个平均，即机器学习的交叉熵损失函数定义为：假设有N个样本 <span class="math inline">\(J = -\frac{1}{N}\sum_{n=1}^N H(p_n, q_n)\)</span></p></li><li><p>因为交叉熵常用于解决分类问题，而分类问题(我们一般说分类问题，是指单标签多分类问题)的概率本质是计算类别变量的广义的伯努利分布，所以机器学习采用的是交叉熵的离散形式<span class="math inline">\(J = -\frac{1}{N}\sum_{n=1}^N \sum _{i=1}t_i\ln{s_i}\)</span>. 其中， <span class="math inline">\(t_i\)</span>是期望的类别标签，<span class="math inline">\(s_i\)</span>是模型对第<span class="math inline">\(i\)</span>个类别计算得到的score，通常在计算损失之前，我们会用激活函数(sigmoid 或者 softmax)加以转换。</p></li></ol><blockquote><p>为什么说分类问题的概率本质是计算类别变量的广义伯努利分布呢？</p></blockquote><p>因为对于分类问题，假设模型的输出层上只有2个输出结点，而且是一个二分类单标签问题，如果输出层用符号<span class="math inline">\(Y\)</span>表示，那么Y服从0-1分布(是二项分布的特例，或称伯努利分布，二元分布)，即随机变量<span class="math inline">\(Y\)</span>的样本空间有两个样本点(分别对应输出层的两个输出结点)，每个样本点就是一个类别。我们希望机器学习模型训练出的分布是某个类别的概率为1，另一个类别的概率为0。推广到多分类单标签问题，那么<span class="math inline">\(Y\)</span>服从广义的伯努利分布(是多项式分布的特例，或称Category分布，范畴分布，类别分布，Multinoulli分布)</p><h4 id="伯努利分布及其极大似然和交叉熵">伯努利分布及其极大似然和交叉熵</h4><p>假设伯努利分布 <span class="math inline">\(Y \in \{0, 1\}\)</span>, 并假y=1的概率为<span class="math inline">\(P(y=1) = p\)</span>，那么其概率质量函数(Probability Mass Function，PMF): <span class="math inline">\(P(Y|p) = p^Y(1-p)^{1-y}\)</span>, 假设<span class="math inline">\(D =\{y_1, y_2, \dots y_N \}\)</span> 是来自<span class="math inline">\(Y\)</span>的并且样本容量为N的样本，那么似然函数为:</p><p><span class="math display">\[\begin{equation}P(D|p) = \prod_{i = 1}^{N} p^{y_i}(1-p)^{1 - y_i}\end{equation}\]</span></p><p>在机器学习中，我们会创建参数为<span class="math inline">\(\theta\)</span>的模型，所以之前的概率<span class="math inline">\(p\)</span>会写成一个函数的形式<span class="math inline">\(p(Y = 1|\theta, x)\)</span>,那么最新的似然函数是</p><p><span class="math display">\[\begin{equation}\begin{split}P(D|\theta, X) &amp;= \prod_{i = 1}^N p(Y=1|\theta, x_i)^{y_i}(1 - p(Y=1|\theta, x_i))^{1-y_i} \\\end{split}\end{equation}\]</span></p><p>所以我们从PMF得到对数似然函数(log-likelyhood): <span class="math display">\[\begin{equation}\begin{split}L(\mathbf{\theta}|D,X) &amp;= \log{\prod_{i = 1}^N p(Y=1|\theta, x_i)^{y_i}(1 - p(Y=1|\theta, x_i))^{1-y_i}} \\&amp;= \sum_{i = 1}^N y_i \ln{p(Y=1|\theta, x_i)} + (1 - y_i)\ln{(1 - p(Y=1|\theta, x_i))} \\\end{split}\end{equation}\]</span></p><p>下面我们将说明最大似然函数和最小交叉熵损失其实是同一个损失函数，一般的我们把机器学习模型输出的结果记为<span class="math inline">\(\hat{y}\)</span></p><p><span class="math display">\[\begin{equation}\begin{split}\theta  &amp;= \mathop{\arg\max}_{\theta} \ \ \sum_{i = 1}^N y_i \ln{p(Y=1|\theta, x_i)} + (1 - y_i)\ln{(1 - p(Y=1|\theta, x_i))}\\&amp;= \mathop{\arg\max}_{\theta} \ \ \sum_{i = 1}^N y_i \ln{\hat{y}_i} + (1 - y_i)\ln{(1 - \hat{y}_i)} \\&amp;= \mathop{\arg\min}_{\theta} \ \ -\sum_{i = 1}^N y_i \ln{\hat{y}_i} + (1 - y_i)\ln{(1 - \hat{y}_i)} \\&amp;= \mathop{\arg\min}_{\theta} \ \ \sum_{i=1}^N H(y_i, \hat{y}_i)\end{split}\end{equation}\]</span></p><h4 id="广义伯努利分布及其极大似然和交叉熵">广义伯努利分布及其极大似然和交叉熵</h4><p>广义伯努利分布又被称做categorical分布，它的一般形式如下</p><p><span class="math display">\[\begin{equation}\begin{split}P(X_k=1|\theta_1,\theta_2, \dots, \theta_K) &amp;= \prod_{k=1}^K \theta_k^{x_k} \\\sum_{k=1}^K \theta_k &amp;= 1 \\x_k \in \{0, 1\}, \sum_{k=1}^K x_k &amp;= 1 \\\end{split}\end{equation}\]</span></p><p>我们常用one-hot向量表示选中的category, 同样假设<span class="math inline">\(D =\{y_1, y_2, \dots y_N \}\)</span> 是来自<span class="math inline">\(Y\)</span>的并且样本容量为N的样本。 PMF函数为 <span class="math display">\[\begin{split}P(Y|p_1,p_2, \dots, p_k) &amp;= \prod_{i=1}^K p_i^{y_i} \\y_i &amp;\in \{0, 1\}\end{split}\]</span></p><p>引入模型参数那么新的似然函数为</p><p><span class="math display">\[\begin{equation}P(D|\theta, \mathbf{X}) =\prod_{i=1}^N \prod_{j=1}^K p_j(\theta, x_i)^{y_j}\end{equation}\]</span></p><p>其对数似然函数 <span class="math display">\[\begin{equation}\begin{split}L(\theta|D, X) &amp;= \sum_{i=1}^N \sum_{j=1}^K y_i^{(j)}\ln{p_j(\theta, x_j)} \\&amp;= \sum_{i=1}^N \sum_{j=1}^K y_i^{(j)}\ln{\hat{y}_i^{(j)}}\end{split}\end{equation}\]</span></p><p>其目标优化函数 <span class="math display">\[\begin{equation}\begin{split}\theta &amp;= \mathop{\arg\max}_{\theta} \ \ \sum_{i=1}^N \sum_{j=1}^K y_i^{(j)}\ln{\hat{y}_i^{(j)}} \\&amp;= \mathop{\arg\min}_{\theta} \ \ -\sum_{i=1}^N \sum_{j=1}^K y_i^{(j)}\ln{\hat{y}_i^{(j)}} \\&amp;= \mathop{\arg\min}_{\theta} \ \ \sum_{i=1}^NH(y_i, \hat{y}_i)\end{split}\end{equation}\]</span></p><p>稍微小结一下:</p><ol type="1"><li>最大似然函数和最小交叉熵都是描述的同一个损失函数</li><li>机器学习中的多分类问题是本质是一个广义伯努利分布(categorical分布)</li></ol><h3 id="候选采样candidate-sampling">候选采样candidate sampling</h3><p>在word2vec论文中提出了两种模型，Continuous Bag-of-words Model 和 Continuous Skip-gram Model，俩者的主要区别在于输入和输出。CBOW输入是上下文词，输出是中心词。SG正好相反。 在开始讲模型之前还要多铺垫一个知识，candidate sampling。</p><p>在机器学习中，经常用一个softmax层来处理多分类任务, 输出是一个one-hot编码向量。</p><p><span class="math display">\[\begin{equation}\begin{split}\hat{y}_i &amp;= \frac{e^{z_i}}{\sum_{j=1}^K e^{z_j} } \\J &amp;= -\sum_{i=1}^K y_i\ln{\hat{y}_i} \\&amp;=  -\ln{\frac{e^{z_{pos}}}{\sum_{i=1}^K e^{z_i}}} \\&amp;= -z_{pos} + \ln{\sum_{i=1}^K e^{z_i}}\end{split}\end{equation}\]</span></p><p>假设<span class="math inline">\(z = -\xi{(w)}\)</span>, 那么 <span class="math display">\[J = \xi{(w_{pos})} + \ln\sum_{i=1}^K e^{-\xi{(w_i)}}\]</span> 注意上面式子的理解, <span class="math inline">\(w_{pos}\)</span>是对应的正例(label值为1的)。那么对其求导可以得到</p><p><span class="math display">\[\begin{equation}\label{eq:gradent}\begin{split}\nabla_{\theta}J &amp;= \nabla_{\theta} \xi{(w_{pos})} + \nabla_{\theta}\ln\sum_{i=1}^K e^{-\xi{(w_i)}} \\&amp;= \nabla_{\theta} \xi{(w_{pos})} + \frac{1}{\sum_{i=1}^K e^{-\xi{(w_i)}}}\nabla_{\theta}\sum_{i=1}^K e^{-\xi{(w_i)}} \\&amp;= \nabla_{\theta} \xi{(w_{pos})} + \frac{1}{\sum_{i=1}^K e^{-\xi{(w_i)}}}\sum_{i=1}^K e^{-\xi{(w_i)}} \nabla_{\theta}{-\xi{(w_i)}} \\&amp;= \nabla_{\theta} \xi{(w_{pos})} - \sum_{i=1}^K\frac{e^{-\xi{(w_i)}}}{\sum_{i=1}^K e^{-\xi{(w_i)}}}  \nabla_{\theta}{\xi{(w_i)}} \\\end{split}\end{equation}\]</span></p><p>上述公式<span class="math inline">\(\ref{eq:gradent}\)</span>中，说明了两件事</p><ol type="1"><li><span class="math inline">\(\nabla_{\theta} \xi{(w_{pos})}\)</span>是关于正样本的梯度，可以理解为对目标词的正面优化</li><li>剩下的右边部分是所有样本概率对应梯度的累加和(想一想为什么有个负号 是不是值越小对应概率越大?) 可以理解为其它词汇的负向优化。在基于采样的优化当中，我们不需要计算所有类别的累加，只需要通过采样求到<span class="math inline">\(\nabla_{\theta}{(\xi{(w_i))}}\)</span>在分布的期望即可，这个分布指<span class="math inline">\(p{(w_i|c)}\)</span></li></ol><p><span class="math display">\[\sum_{i=1}^K\frac{e^{-\xi{(w_i)}}}{\sum_{i=1}^K e^{-\xi{(w_i)}}}  \nabla_{\theta}{\xi{(w_i)}} = \sum_{i=1}^K p(w_i|c) \nabla_{\theta}{\xi{(w_i)}} = \mathbb{E}_{w_i \sim p}[\nabla_{\theta}{\xi{(w_i)}}]\]</span></p><p>那么接下来的问题就变成了如何准确的计算梯度在概率分布<span class="math inline">\(p(w_i)\)</span>上的期望:</p><p><span class="math display">\[\mathbb{E}_{w_i \sim p(w_i)}[\nabla_{\theta}{\xi{(w_i)}}]\]</span></p><h4 id="importance-sampling">Importance Sampling</h4><p>关于采样这块，经典书籍PRML有对其完整的介绍，我们直接给出importance sampling的具体做法，以后我会把所有的samling做一个归纳和总结</p><p>\begin{split} r(w) &amp;=  \ _{w_i p} &amp;  \</p><p>&amp; =  \end{split}</p><p>其中<span class="math inline">\(Q(w)\)</span>是一个一元分布(比如一个均匀分布)</p><p>impoatance sampling 可以把不可计算的期望变得可算，但是似乎还没有减少计算量，还有其它办法来减少计算吗？</p><h4 id="noise-contrastive-estimation">Noise Contrastive Estimation</h4><p>在NCE中，完全推翻上述方法并从试图从另外一个角度来解决多分类问题loss计算的问题——我们能否找到一个损失函数用于替代原来的损失计算，从而避免softmax中归一化因子的计算。</p><p>NCE的基本思想是将多分类问题转换成为二分类问题，从噪音分布中采样，减少优化过程的计算复杂度。它是importance Sampling的改良升级方法。基本思想是将最终问题转换为一个二分类代理问题，将target词和非target词做一个二分类任务标签。通常我们将非target词叫做noise examples，即噪声数据。而这些noise样本会服从某个noise分布Q(w),这个Q(w)需要我们人工引入。相对的，我们的target词也是来自于一个分布，这个分布我们通常叫做emprical分布，即经验分<span class="math inline">\(\tilde{p}(w|c), \tilde{p}(c)\)</span>。我们的目的就是要学习参数<span class="math inline">\(\theta\)</span>, 使得我们计算得到的<span class="math inline">\(p_{theta}(w|c)\)</span>无限逼近经验分布<span class="math inline">\(\tilde{p}(w|c)\)</span>。</p><p>下面来看如何得到新的二分类问题的训练集</p><ol type="1"><li>从经验分布即原数据集 <span class="math inline">\(\tilde{p}(c)\)</span> 中采样得到context词c</li><li>从经验分布即原数据集 <span class="math inline">\(\tilde{p}(w|c)\)</span> 中采样一个正确的样本w，即target词，标签记为d=1 从noise分布中采样K个noise样本，即非target词，标签记为d=0</li></ol><p>给定context词 (d,w)的联合概率为</p><p><span class="math display">\[\begin{equation}p(d, w|c) = \begin{cases}\frac{K}{1+K} * Q(w), &amp; \text{if d = 0} \\\frac{1}{1 + K} * \tilde{p}(w|c), &amp;\text{if d = 1}\end{cases}\end{equation}\]</span></p><p>利用条件概率公式，可以将上述概率式子转换为d给定w和c的条件概率公式 <span class="math display">\[\begin{equation}\begin{split}p(d=0|w, c) &amp;= \frac{p(d=0, w|c)}{p(w|c)} = \frac{ \frac{K}{1+K}*Q(w)}{\frac{1}{1+K}*\tilde{p}(w|c) +\frac{K}{1+K}*Q(w)} = \frac{K*Q(w)}{\tilde{p}(w|c) + K*Q(w)} \\p(d=1|w, c) &amp;= \frac{p(d=1, w|c)}{p(w|c)} = \frac{ \frac{1}{1+K}*\tilde{p}(w|c)}{\frac{1}{1+K}*\tilde{p}(w|c) +\frac{K}{1+K}*Q(w)} = \frac{\tilde{p}(w,|c)}{\tilde{p}(w|c) + K*Q(w)}\end{split}\end{equation}\]</span></p><p>NCE通过学习<span class="math inline">\(p_{\theta}\)</span>来逼近替代<span class="math inline">\(\tilde{p}(w|c)\)</span> ，而学习的过程就是去最大化上述条件概率式的过程。</p><p>说到这里，貌似NCE还没解决做除法的高成本问题，目前为止只是通过增加一些noise负样本将目标函数做了转化。因此NCE还引入了两个假设。</p><blockquote><ol type="1"><li>将分母<span class="math inline">\(z_{\theta}(c)\)</span>近似估计为一个参数<span class="math inline">\(z_c\)</span> ,这样对任意一个样本context词c来说，都只引入了同一个参数。</li><li>对于神经网络参数繁多的情况，当我们令<span class="math inline">\(z_c\)</span>固定为1时，能够有效地减小参数的数量，同时鼓励模型对输出进行自标准化。</li></ol></blockquote><p>引入上述两条假设后， 重写概率公式 <span class="math inline">\(\tilde{p}(w|c)\approx \frac{e^{s_{\theta}(w, c)}}{\sum_{w^{&#39;}} s_{\theta}(w^{&#39;}, c) }\)</span></p><p>此时</p><p><span class="math display">\[\begin{equation}\begin{split}p(d=0|w, c) &amp;= \frac{K*Q(w)}{e^{s_{\theta}(w, c)} + K*Q(w)} \\p(d=1|w, c) &amp;= \frac{e^{s_{\theta}(w, c)}}{e^{s_{\theta}(w, c)} + K*Q(w)}\end{split}\end{equation}\]</span></p><p>假设我们的原始语料样本为T，接下来就是将所有样本的条件概率结合起来，同时应用log函数，防止数据下溢，得到我们的目标优化函数(针对单个样本)</p><p><span class="math display">\[\begin{equation}\label{eq:nceloss}\begin{split}J &amp;=  \ln{p(d=1|w, c)} + K * E_{w^{&#39;} \sim Q} \ln{p(d=0|w, c)} \\&amp;=  \ln{p(d=1|w, c)} + K * \sum_{i=1, w^{&#39;} \sim Q}^K \frac{1}{K}\ln{p(d=0|w, c)} \\&amp;=  \ln{p(d=1|w, c)} + \sum_{i=1, w^{&#39;} \sim Q}^K \ln{p(d=0|w, c)}\end{split}\end{equation}\]</span></p><p>上述式子中加法的前一项很简单没问题，但是后一项求解期望的计算量还是比较大的，需要在给定context词c条件下，在词库V中引入的noise分布中采样生成一个负样本，并计算概率的期望值，对整个词库还是有一个次遍历。因此最后一步，NCE使用了Monte Carlo估计来替代这个概率期望。这样就不需要遍历整个词库了，只需要从Q分布的部分词集计算就可以了。</p><h4 id="negative-sampling">negative sampling</h4><p>上面的NCE可能还是有些复杂，因此有的学者又在此基础上做了简化，Mikolov在2012年的paper上介绍了在word2vec中使用的采样方法——Negative Sampling，又叫负采样。</p><p>基本思想在于：每采样一个target词，就采样k个非target词（即负样本）。可以看到他跟NCE的基本思想是类似的，但是具体实现的时候又有不同。</p><p>不同于NCE，负采样在定义p(d|w,c)时采取了更加简单的实现：</p><p><span class="math display">\[\begin{equation}\begin{split}p(d=0|w, c) &amp;= \frac{1}{e^{s_{\theta}(w, c)} + 1} \\p(d=1|w,c) &amp;= \frac{e^{s_{\theta}(w, c)}}{e^{s_{\theta}(w, c)} + 1} \\\end{split}\end{equation}\]</span></p><p>其实它与NCE的概率式子是有联系的，即在NCE中，令K=|V|,且Q分布是一个均匀分布，那么就可以得到负采样的式子。最后列一下负采样的目标函数</p><p><span class="math display">\[\begin{split}J &amp;=  \ln{p(d=1|w, c)} + K * \sum_{i=1, w^{&#39;} \sim Q}^K \frac{1}{K}\ln{p(d=0|w, c)} \\&amp;=  \ln{\sigma{(s_{\theta}(w, c))}} + \sum_{i=1, w^{&#39;} \sim Q}^K \ln{\sigma{(-s_{\theta}(w^{&#39;}, c))}}\end{split}\]</span></p><p>所以最终我们的优化目标函数长这样(针对一个batch N个样本) <span class="math display">\[\begin{equation}\begin{split}\mathop{\arg\max}_{\theta} &amp; \frac{1}{N}\sum_{( w, c \in T)}( \ln{\sigma{(s_{\theta}(w, c))}} + \sum_{i=1, w^{&#39;} \sim Q}^K \ln{\sigma{(-s_{\theta}(w^{&#39;}, c))}} )\\\mathop{\arg\min}_{\theta} &amp; - \frac{1}{N} \sum_{( w, c \in T)} (\ln{\sigma{(s_{\theta}(w, c))}} - \sum_{i=1, w^{&#39;} \sim Q}^K \ln{\sigma{(-s_{\theta}(w^{&#39;}, c))}})\end{split}\end{equation}\]</span></p><blockquote><p>抛一次硬币，正面朝上的概率，这是伯努利分布。<br />抛<span class="math inline">\(n\)</span>次硬币，正面朝上出现了<span class="math inline">\(m\)</span>次的概率，这是二项分布。<br />抛一次骰子，第<span class="math inline">\(k\)</span>面朝上的概率，这是categorical分布。<br />抛<span class="math inline">\(n\)</span>次骰子， 第<span class="math inline">\(1\)</span>面朝上出现了<span class="math inline">\(m_1\)</span>次 ，第<span class="math inline">\(2\)</span>面朝上出现了<span class="math inline">\(m_2\)</span>次......第<span class="math inline">\(k\)</span>面朝上出现了<span class="math inline">\(m_k\)</span>次的概率，这是多项分布。</p></blockquote><h2 id="关于word2vec若干问题的思考">关于Word2Vec若干问题的思考</h2><ol type="1"><li><p>Word2Vec两个算法模型的原理是什么，网络结构怎么画？ 如果仔细浏览一下论文附带的<a href="https://github.com/tmikolov/word2vec">C源码</a>。会发现不论是CBOW模型还是skip-gram模型，都是用context(也就是上下文词)作为输入， 中心词word(也就是论文里提到的中心词)作为输出。唯一的差别就在于CBOW取了context词的平均。这其实是一种朴素的思想: 环境决定结果。所以context输入，中心词word输出</p></li><li><p>怎么做的subsampling subsampling的做法是对最原始的序列根据概率做discard，然后再根据pair的方式，生成样本对。这样做的原因是一方面可以打击过热，另一面引入了一些其它的“化学反应”。这就是为什么先做了discard然后 做pair，否则我们先做pair再discard，就不会出现一些离得稍为远一些的词组成的pair。根据<a href="https://github.com/tmikolov/word2vec">C源码</a>，先discard再pair。</p></li><li><p>我们到底应该把那个矩阵当作需要的词向量呢 我提出几个关键词，共现，交叉熵。那么对于一个输出矩阵来说，如果其中的两个向量相似，说明它们的context上下文有相似的pattern(比如有共现的context词和非context词)，同样的对于输入矩阵来说， 如果其中两个向量相似，说明在他们代表的含义空间里相似，这个含义可能就是:这两个向量有共现的中心词和非中心词。对于CBOW方法来说，输出矩阵还是可以用上面所说的理解方式去理解，输入矩阵由于 取了平均值观上不是很好理解了(含义空间很奇怪)。 最后，我的观点,不论是CBOW还是SG, 输入矩阵和输出矩阵都可以作为词向量，但是含义空间各不相同，输出矩阵可能更好理解一点。</p></li><li><p>怎么确定discard和负采样的采样函数 这里面用了带有parameter的经验公式</p></li></ol><p><span class="math display">\[\begin{equation}\begin{split}p(w_i) &amp;= \sqrt{\frac{z(w_i)}{0.001} + 1} * \frac{0.001}{z(w_i)} \\n(w_i) &amp;= \frac{z(w_i)^{0.75}}{\sum_{j=0}^n (z(w_i)^{0.75})}\end{split}\end{equation}\]</span></p><ol start="5" type="1"><li>word2vec有哪些缺陷 Word2Vec只考虑到上下文信息，而忽略的全局信息； Word2Vec只考虑了上下文的共现性，而忽略的了彼此之间的顺序性；</li></ol><h2 id="小结">小结</h2><ol type="1"><li>明确word2vec的思想，以及它的损失函数</li><li>通过negative sampling方式 把需要大量的分母计算规避，加速计算，是一种candidate sampling思想的运用</li><li>注意在构造样本时的采样概率函数构造</li></ol><p>参考:</p><ol type="1"><li><p><a href="https://zhuanlan.zhihu.com/p/114538417" class="uri">https://zhuanlan.zhihu.com/p/114538417</a></p></li><li><p><a href="http://demo.clab.cs.cmu.edu/cdyer/nce_notes.pdf" class="uri">http://demo.clab.cs.cmu.edu/cdyer/nce_notes.pdf</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/261694402" class="uri">https://zhuanlan.zhihu.com/p/261694402</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/51099880" class="uri">https://zhuanlan.zhihu.com/p/51099880</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/261694402" class="uri">https://zhuanlan.zhihu.com/p/261694402</a></p></li><li><p><a href="http://mccormickml.com/2017/01/11/word2vec-tutorial-part-2-negative-sampling/" class="uri">http://mccormickml.com/2017/01/11/word2vec-tutorial-part-2-negative-sampling/</a></p></li><li><p><a href="http://mccormickml.com/2016/04/19/word2vec-tutorial-the-skip-gram-model/" class="uri">http://mccormickml.com/2016/04/19/word2vec-tutorial-the-skip-gram-model/</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统-YouTubeDNN详解</title>
      <link href="/2021/07/22/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-YouTubeDNN%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/07/22/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-YouTubeDNN%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>最近阅读了一篇2016年的推荐经典论文<a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/45530.pdf">Deep Neural Network for YouTobe Recommendations</a>, 网上也有关于这篇文章的许多讨论，特写此篇博客用以记录我对此模型的理解以及上线经历。</p><span id="more"></span><h2 id="候选集生成">候选集生成</h2><p>这部分和word2vec的做法非常相似，可以参考我的这篇<a href="https://matt90luo.github.io/2021/07/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-embedding%E4%B9%8Bword2vec/">博客</a>，把召回过程看作是一个多分类问题，整个模型结构如下图所示 <img src="recall.png" /></p><p>可以看到最后一层是softmax层，然后在实际求解中使用NCE方法。最终可以通过基于LSH(局部哈希敏感)算法的ANN引擎做线上的召回。和word2vec不同的地方在多了两层非线性的隐藏层，全联接形式。 整个输入向量可以分为两大类：embedding向量和连续维度的数值。其中提出的example age这个特征比较特别，它的含义是上架时间到生成样本所经过的时长。所以会含有一个英文单词age，这就是年龄的含义。 在实际inference时，我们会给一个0值或者很小的负值。这样做的目的是让新鲜的视频有更多曝光的机会。有利于召回上传时间短，但是视频内容与用户兴趣更相关的新视频。 其实加入这个特征的原因是上架越早的视频，更有机会成为热门的视频，与大多数用户相关，因此在训练时加入该特征，有利于该特征的权重较大，而在线上召回时，将该特征的权重进行打压，则有利于其他相关性特征，因此对上传时间较短的新视频的召回有一定的帮助。</p><h2 id="排序模型">排序模型</h2><p>排序模型使用的weighed LR模型，具体结构如下</p><p><img src="sort.png" /></p><p>weighed LR有两种实现方式</p><ol type="1"><li><p>up-sampling方式 上采样通过增加正样本数量达到加权目的</p></li><li><p>magnify weight 这种方法就是在计算损失函数是引入权重。典型的如tensorflow提供的函数weighted_cross_entropy_with_logits</p></li></ol><p>我们来复习一些概念</p><p><span class="math display">\[\begin{equation}\begin{split}y = \frac{1}{1 + e^{-w^Tx+ b}} \\odds = e^{w^Tx+b} = \frac{p(y=1|x)}{p(y=0|x)} \\p = \frac{odds}{odd + 1}\end{split}\end{equation}\]</span></p><p>odds 表示一件事情的发生比，是该事件发生和不发生的比率。logit就是对这个比率取对数。其中<span class="math inline">\(odds = e^{w^Tx+b} = \frac{p(y=1|x)}{p(y=0|x)}\)</span> 在weighted logistic regression中，<span class="math inline">\(odds = \frac{\sum{T_i}}{N-k}\)</span>，解释一下含义，假设总共的曝光次数为N，有观看的次数为k，我们把观看时长<span class="math inline">\(T_i\)</span>看成权重，没有观看的曝光的权重是单位1 同样每一次曝光的观看时长的期望可以写做 <span class="math inline">\(E(T) = \frac{\sum T_i}{N}\)</span>, 这个式子也很好理解，从古典概型的角度去看。所以我们会有</p><p><span class="math display">\[E(T)=\frac{\sum T_i}{N} = \frac{\frac{\sum T_i}{N-k}}{\frac{N}{N-k}} =\frac{odds}{\frac{N}{N-k}}\]</span></p><p>因为一般情况下k远小于N，所以<span class="math inline">\(E(T) \simeq odds\)</span> 或者通过级数的角度理解</p><p><span class="math display">\[odds = E(T)\frac{N}{N-k} = E(T)\frac{1}{1-p} \simeq E(T)*(1+p) \simeq E(T)\]</span></p><ol start="3" type="1"><li>tensorflow 小试牛刀 tensorflow是google推出的深度学习框架，实现了底层线性代数运算方法。我们使用tensorflow实现了召回和排序模型，一些核心代码如下</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sort_model</span>(tf.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>().__init__(name=name)</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">&quot;sort&quot;</span>):</span><br><span class="line">            self.weight = tf.compat.v1.placeholder(tf.float32)</span><br><span class="line">            self.label = tf.compat.v1.placeholder(tf.float32)</span><br><span class="line">            self.input_embedding = tf.compat.v1.placeholder(tf.float32)</span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(<span class="string">&quot;sort&quot;</span>, reuse=tf.AUTO_REUSE):</span><br><span class="line">                self.hidden_layer_0 = tf.get_variable(<span class="string">&#x27;hidden_layer_0&#x27;</span>, initializer=tf.random.normal([<span class="number">512</span>, <span class="number">256</span>], <span class="number">0.0</span>, <span class="number">1.0</span>), )</span><br><span class="line">                self.hidden_layer_1 = tf.get_variable(<span class="string">&#x27;hidden_layer_1&#x27;</span>, initializer=tf.random.normal([<span class="number">256</span>, <span class="number">128</span>], <span class="number">0.0</span>, <span class="number">1.0</span>))</span><br><span class="line">                self.output_layer = tf.get_variable(<span class="string">&#x27;output_layer&#x27;</span>, initializer=tf.random.normal([<span class="number">128</span>, <span class="number">1</span>], <span class="number">0.0</span>, <span class="number">1.0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self</span>):</span><br><span class="line">        tmp = tf.nn.swish(</span><br><span class="line">            tf.matmul(</span><br><span class="line">                tf.nn.swish(tf.matmul(self.input_embedding, self.hidden_layer_0)), self.hidden_layer_1))  <span class="comment"># shape T, 128</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tf.matmul(tmp, self.output_layer) <span class="comment">#logit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cost_func</span>(<span class="params">self</span>):</span><br><span class="line">        tmp = tf.nn.swish(</span><br><span class="line">            tf.matmul(</span><br><span class="line">                tf.nn.swish(tf.matmul(self.input_embedding, self.hidden_layer_0)), self.hidden_layer_1))  <span class="comment"># shape T, 128</span></span><br><span class="line"></span><br><span class="line">        cost = tf.reduce_mean(</span><br><span class="line">            tf.squeeze(</span><br><span class="line">                tf.nn.weighted_cross_entropy_with_logits(labels=self.label, logits=tf.matmul(tmp, self.output_layer),</span><br><span class="line">                                                         pos_weight=self.weight)))</span><br><span class="line">        <span class="keyword">return</span> cost</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">recall_model</span>(tf.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, VOCABULARY_NUM, HIDDEN_NUM, name=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>().__init__(name=name)</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">&quot;recall&quot;</span>):</span><br><span class="line">            self.pos = tf.compat.v1.placeholder(tf.int32)</span><br><span class="line">            self.input_embedding = tf.compat.v1.placeholder(tf.float32)</span><br><span class="line">            self.neg = tf.compat.v1.placeholder(tf.int32)</span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(<span class="string">&quot;recall&quot;</span>, reuse=tf.AUTO_REUSE):</span><br><span class="line">                self.hidden_layer_0 = tf.get_variable(<span class="string">&#x27;hidden_layer_0&#x27;</span>, initializer=tf.random.normal([<span class="number">256</span>, <span class="number">512</span>], <span class="number">0.0</span>, <span class="number">1.0</span>), )</span><br><span class="line">                self.hidden_layer_1 = tf.get_variable(<span class="string">&#x27;hidden_layer_1&#x27;</span>, initializer=tf.random.normal([<span class="number">512</span>, <span class="number">256</span>], <span class="number">0.0</span>, <span class="number">1.0</span>))</span><br><span class="line">                self.output_layer = tf.get_variable(<span class="string">&#x27;output_layer&#x27;</span>, initializer=tf.zeros([VOCABULARY_NUM, HIDDEN_NUM]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        tmp_softmax_input = tf.expand_dims(</span><br><span class="line">            tf.nn.swish(tf.matmul(tf.nn.swish(tf.matmul(self.input_embedding, self.hidden_layer_0)), self.hidden_layer_1)),</span><br><span class="line">            axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmp_softmax_input</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cost_func</span>(<span class="params">self</span>):</span><br><span class="line">        tmp_pos = tf.nn.embedding_lookup(self.output_layer, self.pos)  <span class="comment"># shape T,1,256</span></span><br><span class="line">        tmp_neg = tf.nn.embedding_lookup(self.output_layer, self.neg)  <span class="comment"># shape T,K,256</span></span><br><span class="line">        tmp_softmax_input = self.forward()</span><br><span class="line"></span><br><span class="line">        p = tf.matmul(tmp_softmax_input, tf.transpose(tmp_pos, perm=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]))  <span class="comment"># shape T, 1, 1</span></span><br><span class="line"></span><br><span class="line">        n = tf.matmul(tmp_softmax_input, tf.transpose(tmp_neg, perm=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]))  <span class="comment"># shape T, 1, k</span></span><br><span class="line"></span><br><span class="line">        pos_part = tf.compat.v1.reduce_sum(</span><br><span class="line">            tf.math.log(</span><br><span class="line">                tf.nn.sigmoid(</span><br><span class="line">                    tf.clip_by_value(p, -<span class="number">8</span>, <span class="number">8</span>))), axis=<span class="number">1</span>)  <span class="comment"># shape T,1</span></span><br><span class="line"></span><br><span class="line">        neg_part = tf.compat.v1.reduce_sum(</span><br><span class="line">            tf.math.log(<span class="number">1</span> -</span><br><span class="line">                        tf.nn.sigmoid(</span><br><span class="line">                            tf.clip_by_value(n, -<span class="number">8</span>, <span class="number">8</span>))), axis=<span class="number">1</span>)  <span class="comment"># shape T,K</span></span><br><span class="line"></span><br><span class="line">        cost = - tf.reduce_mean(</span><br><span class="line">            tf.compat.v1.reduce_sum(pos_part, axis=<span class="number">1</span>) + tf.compat.v1.reduce_sum(neg_part, axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure><p>下面我简单汇总一下使用tensorflow过程中的注意点</p><ol type="1"><li><p>variable_scope vs name_scope 作为一种图式计算引擎，应该使用命名空间来做变量隔离。name_scope只会决定对象属于哪个范围，并不会对对象的作用范围产生任何影响。通常name_scope配合tensorboard可视化使用 variable_scope 配合 get_variable 使用。可以共享变量</p></li><li><p>一些有用的tf函数 在使用tf时，始终要保证shape的运算准确性，有一些函数可以方便的改变tensor的shape。tf.sqeeze可以去除所有度量为1的维度，比如shape(1,4,1)变成shape(4,). tf.reduce_sum 对应axis的维度做sum操作。</p></li><li><p>模型部署 tf的模型部署(单机)并不复杂，比较绕的地方在它的配置文件，在进行模型热更新的时候，至少需要两步，第一步新模型load，第二步修改label的绑定。这样模型才会正式生效</p></li></ol><h2 id="小结">小结</h2><ol type="1"><li>youTubeDNN的召回模型需要类比word2vec，样本的生成同样考虑subsampling，优化手段也是negative sampling</li><li>排序模型是使用的weighted LR，计算出的odds 就是观看时长的期望。这样一个优化目标符合视频网站的业务要求</li><li>使用tensorflow serving作为模型的上线部署，注意其配置文件的修改顺序。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>scala-模式匹配</title>
      <link href="/2021/07/15/scala-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/2021/07/15/scala-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>模式匹配是检查某个值（value）是否匹配某一个模式的机制，一个成功的匹配同时会将匹配值解构为其组成部分。它是Java中的switch语句的升级版，同样可以用于替代一系列的 if/else 语句。</p></blockquote><p>scala的模式匹配是其非常出彩的一个点。</p><span id="more"></span><h2 id="模式匹配语法">模式匹配语法</h2><p>一个模式匹配语句包括一个待匹配的值，match关键字，以及至少一个case语句。 match 对应 Java 里的 switch，但是写在选择器表达式之后。即： 选择器 match {备选项}。 match 表达式通过以代码编写的先后次序尝试每个模式来完成计算，只要发现有一个匹配的case，剩下的case不会继续匹配。 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.<span class="type">Random</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x: <span class="type">Int</span> = <span class="type">Random</span>.nextInt(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="string">&quot;zero&quot;</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">&quot;one&quot;</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">&quot;two&quot;</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">&quot;other&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上述代码中的val x是一个0到10之间的随机整数，将它放在match运算符的左侧对其进行模式匹配，match的右侧是包含4条case的表达式，其中最后一个case _表示匹配其余所有情况，在这里就是其他可能的整型值。 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matchTest</span></span>(x: <span class="type">Int</span>): <span class="type">String</span> = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">&quot;one&quot;</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">&quot;two&quot;</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">&quot;other&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">matchTest(<span class="number">3</span>)  <span class="comment">// other</span></span><br><span class="line">matchTest(<span class="number">1</span>)  <span class="comment">// one</span></span><br></pre></td></tr></table></figure> 这个match表达式是String类型的，因为所有的情况（case）均返回String，所以matchTest函数的返回值是String类型。</p><h2 id="模式匹配种类">模式匹配种类</h2><h3 id="通配符匹配">通配符匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通配符匹配</span></span><br><span class="line"><span class="comment">    * @param x</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">m1</span></span>(x: <span class="type">Any</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>(<span class="number">0</span>, _, _) =&gt; <span class="string">&quot;匹配 0 元素开头的list&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>, _*) =&gt; <span class="string">&quot;匹配 1 元素开头的list&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Vector</span>(<span class="number">1</span>, _*) =&gt; <span class="string">&quot;匹配 1 元素开头的vector&quot;</span></span><br><span class="line">    <span class="keyword">case</span> m: <span class="type">Map</span>[_, _] =&gt; m.toString</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  println(m1(<span class="type">List</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>))) <span class="comment">//匹配 0 元素开头的list</span></span><br><span class="line">  println(m1(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>))) <span class="comment">//匹配 1 元素开头的list</span></span><br><span class="line">  println(m1(<span class="type">Vector</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))) <span class="comment">//匹配 1 元素开头的vector</span></span><br></pre></td></tr></table></figure><h3 id="常量匹配">常量匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m2</span></span>(x:<span class="type">Any</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span> =&gt; println(<span class="string">&quot;zero&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="literal">true</span> =&gt; println(<span class="string">&quot;true&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span> =&gt; println(<span class="string">&quot;you said &#x27;hello&#x27;&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Nil</span> =&gt; println(<span class="string">&quot;an empty List&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;unknow&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(m2(<span class="string">&quot;hello&quot;</span>)) <span class="comment">//you said &#x27;hello&#x27;</span></span><br><span class="line">println(m2(<span class="literal">true</span>)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="变量匹配">变量匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">30</span></span><br><span class="line"><span class="number">20</span> <span class="keyword">match</span> &#123; <span class="keyword">case</span> a =&gt; <span class="number">1</span> &#125; <span class="comment">// 1， a是模式变量，不是10</span></span><br><span class="line"><span class="comment">//为了使用变量a，必须用`a`:</span></span><br><span class="line"><span class="number">20</span> <span class="keyword">match</span> &#123; <span class="keyword">case</span> `a` =&gt; <span class="number">1</span>; <span class="keyword">case</span> `b` =&gt; <span class="number">-1</span> &#125; <span class="comment">// -1，`a`是变量10</span></span><br><span class="line"><span class="comment">//或者用大写的变量</span></span><br></pre></td></tr></table></figure><h3 id="构造函数匹配">构造函数匹配</h3><p>构造器模式不只检查顶层对象是否一致，还会检查对象的内容是否匹配内层的模式。由于额外的模式自身可以形成构造器模式，因此可以使用它们检查到对象内部的任意深度。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">name: <span class="type">String</span>, color: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">name: <span class="type">String</span>, color: <span class="type">String</span>, age: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">what</span></span>(animal: <span class="type">Animal</span>): <span class="type">String</span> = animal <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Cat</span>(name: <span class="type">String</span>, color: <span class="type">String</span>) =&gt; <span class="string">s&quot;cat&#x27;s is <span class="subst">$name</span>,color <span class="subst">$color</span>&quot;</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Dog</span>(name: <span class="type">String</span>, color: <span class="type">String</span>, age: <span class="type">Int</span>) =&gt; <span class="string">s&quot;dog&#x27;s is <span class="subst">$name</span>,color <span class="subst">$color</span> ,age <span class="subst">$age</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> a1 = <span class="type">Cat</span>(<span class="string">&quot;多啦A梦&quot;</span>, <span class="string">&quot;白色&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> s1 = what(a1)</span><br><span class="line">println(s1) <span class="comment">//a cat name is 多啦A梦,color is 白色</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> a2 = <span class="type">Dog</span>(<span class="string">&quot;多啦B梦&quot;</span>, <span class="string">&quot;白色&quot;</span>, <span class="number">500</span>)</span><br><span class="line"><span class="keyword">val</span> s2 = what(a2)</span><br><span class="line">println(s2) <span class="comment">//a dog name is 多啦B梦,color is 白色 ,age is 500</span></span><br></pre></td></tr></table></figure><h3 id="集合类型匹配">集合类型匹配</h3><p>数组匹配 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m5</span></span>(arr: <span class="type">Array</span>[<span class="type">Int</span>]) = arr <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">1</span>, x, y) =&gt; println(<span class="string">&quot;匹配以1 开头,有三个元素的数组&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>) =&gt; println(<span class="string">&quot;匹配只有 0 这个元素的数组&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>, _*) =&gt; println(<span class="string">&quot;匹配以0 开头任意多个元素的数组&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> arr <span class="keyword">if</span> arr.length == <span class="number">2</span> =&gt; println(<span class="string">&quot;length = 2&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;unknow&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 序列匹配 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m5_1</span></span>(list: <span class="type">List</span>[<span class="type">Int</span>]) = list <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span> :: <span class="type">Nil</span> =&gt; println(<span class="string">&quot;匹配只有 5 这个元素的序列&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> x :: y :: <span class="type">Nil</span> =&gt; println(<span class="string">&quot;匹配只有两个元素的序列&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> list <span class="keyword">if</span> list.last == <span class="number">1</span> =&gt; println(<span class="string">&quot;结尾是1的列表&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> x :: tail =&gt; println(<span class="string">&quot;匹配任意多个元素的数组&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;unknow&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m5_1(<span class="type">List</span>(<span class="number">5</span>)) <span class="comment">//匹配只有 5 这个元素的序列</span></span><br><span class="line">m5_1(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>)) <span class="comment">//匹配只有两个元素的序列</span></span><br><span class="line">m5_1(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>)) <span class="comment">//结尾是1的列表</span></span><br></pre></td></tr></table></figure></p><h3 id="tuple类型匹配">tuple类型匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m6</span></span>(tuple: <span class="type">Any</span>) = tuple <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> (x, y, <span class="number">7</span>) =&gt; println(<span class="string">&quot;匹配有三个元素并且以7 结尾的元组&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">2</span>, x, y) =&gt; println(<span class="string">&quot;匹配以2 开头有三个元素的元组&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;unknow&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(m6((<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>))) <span class="comment">//匹配有三个元素并且以7 结尾的元组</span></span><br><span class="line">println(m6((<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>))) <span class="comment">//匹配以2 开头有三个元素的元组</span></span><br></pre></td></tr></table></figure><h3 id="类型匹配">类型匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m7</span></span>(x: <span class="type">Any</span>): <span class="type">String</span> = x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> x: <span class="type">String</span> =&gt; x</span><br><span class="line">    <span class="keyword">case</span> x: <span class="type">Int</span> <span class="keyword">if</span> x &gt; <span class="number">5</span> =&gt; x.toString <span class="comment">//带if守卫条件的匹配</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">&quot;unknow&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(m7(<span class="string">&quot;hello&quot;</span>)) <span class="comment">//hello</span></span><br><span class="line">println(m7(<span class="number">9</span>)) <span class="comment">// 9 </span></span><br><span class="line">println(m7(<span class="number">2</span>)) <span class="comment">// unknow ,(虽然2满足Int类型, 但是不满足守卫条件&quot;大于5&quot;,所以往下匹配)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m7_1</span></span>(v: <span class="type">Any</span>) = v <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">null</span> =&gt; <span class="string">&quot;null&quot;</span></span><br><span class="line">    <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i * <span class="number">100</span></span><br><span class="line">    <span class="keyword">case</span> s: <span class="type">String</span> =&gt; s</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">&quot;others&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：上面case中的i、s都叫模式变量</span></span><br><span class="line">println(m7_1(<span class="literal">null</span>)) <span class="comment">// &quot;null&quot;</span></span><br><span class="line">println(m7_1(<span class="number">5</span>)) <span class="comment">// 500</span></span><br><span class="line">println(m7_1(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">println(m7_1(<span class="number">3.14</span>)) <span class="comment">// &quot;others&quot;</span></span><br></pre></td></tr></table></figure><h2 id="模式匹配的应用">模式匹配的应用</h2><h3 id="递归">递归</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fac1</span></span>(n:<span class="type">Int</span>):<span class="type">Int</span> = n <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="number">1</span> </span><br><span class="line">    <span class="keyword">case</span> _ =&gt; n * fac1( n - <span class="number">1</span> )</span><br><span class="line">&#125;</span><br><span class="line">fac1(<span class="number">5</span>) <span class="comment">//120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fac2</span></span>: <span class="type">Int</span> =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> n =&gt; n * fac2( n - <span class="number">1</span> )</span><br><span class="line">&#125;</span><br><span class="line">fac2(<span class="number">5</span>) <span class="comment">//120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同 使用尾递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fac3</span></span>: (<span class="type">Int</span>,<span class="type">Int</span>) =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">0</span>,y) =&gt; y</span><br><span class="line">    <span class="keyword">case</span> (x,y) =&gt; fac3(x<span class="number">-1</span>, x*y)</span><br><span class="line">&#125;</span><br><span class="line">fac3(<span class="number">5</span>,<span class="number">1</span>) <span class="comment">// 120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同 reduceLeft</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fac4</span></span>(n:<span class="type">Int</span>) = <span class="number">1</span> to n reduceLeft( _ * _ )</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(n:<span class="type">Int</span>) = <span class="keyword">new</span> &#123; <span class="function"><span class="keyword">def</span> <span class="title">!</span> </span>= fac4(n) &#125;</span><br><span class="line"><span class="number">5</span>! <span class="comment">// 120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fac5</span></span>(n:<span class="type">Int</span>) = (<span class="number">1</span>:<span class="type">BigInt</span>) to n product</span><br><span class="line">fac5(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><h3 id="模式匹配和二叉数遍历">模式匹配和二叉数遍历</h3><p>利用scala的模式匹配和递归可以轻松实现二叉树的遍历 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *       1</span></span><br><span class="line"><span class="comment"> *   2      3</span></span><br><span class="line"><span class="comment"> * 4  5       6</span></span><br><span class="line"><span class="comment"> *   7 8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">bTreeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params">value: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                  left: <span class="type">BinaryTree</span> = null, right: <span class="type">BinaryTree</span> = null</span>) <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">traverse</span></span>(t: <span class="type">BinaryTree</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    t <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="literal">null</span> =&gt; <span class="type">Unit</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">Node</span>(v, left, right) =&gt; traverse(left);println(v);traverse(right) <span class="comment">// 中序</span></span><br><span class="line">      <span class="comment">//case Node(v, left, right) =&gt; println(v); traverse(left); traverse(right) //前序</span></span><br><span class="line">      <span class="comment">//case Node(v, left, right) =&gt; traverse(left);traverse(right);println(v)  //后序</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">BFS</span></span>(t: (<span class="type">List</span>[<span class="type">Node</span>], <span class="type">List</span>[<span class="type">Int</span>])): (<span class="type">List</span>[<span class="type">Node</span>], <span class="type">List</span>[<span class="type">Int</span>]) = t <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> (<span class="type">Nil</span>, res) =&gt; (<span class="type">Nil</span>, res)</span><br><span class="line">    <span class="keyword">case</span> (lB, res) =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> tmp = lB.map &#123; <span class="keyword">case</span> <span class="type">Node</span>(v, <span class="literal">null</span>, <span class="literal">null</span>) =&gt; (<span class="type">Nil</span>, v)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Node</span>(v, left, <span class="literal">null</span>) =&gt; (<span class="type">List</span>(left.asInstanceOf[<span class="type">Node</span>]), v)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Node</span>(v, <span class="literal">null</span>, right) =&gt; (<span class="type">List</span>(right.asInstanceOf[<span class="type">Node</span>]), v)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Node</span>(v, left, right) =&gt; (<span class="type">List</span>(left.asInstanceOf[<span class="type">Node</span>], right.asInstanceOf[<span class="type">Node</span>]), v)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">BFS</span>((tmp.flatMap(_._1), res ++ tmp.map(_._2)))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">DFS</span></span>(t:(<span class="type">List</span>[<span class="type">Node</span>], <span class="type">List</span>[<span class="type">Int</span>])): (<span class="type">List</span>[<span class="type">Node</span>], <span class="type">List</span>[<span class="type">Int</span>]) =t <span class="keyword">match</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> (<span class="type">Nil</span>, res) =&gt; (<span class="type">Nil</span>, res)</span><br><span class="line">    <span class="keyword">case</span> (lB, res) =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> top = lB.head</span><br><span class="line">      <span class="keyword">val</span> left = <span class="keyword">if</span>(top.left == <span class="literal">null</span>) <span class="type">Nil</span> <span class="keyword">else</span> <span class="type">List</span>(top.left.asInstanceOf[<span class="type">Node</span>])</span><br><span class="line">      <span class="keyword">val</span> right = <span class="keyword">if</span>(top.right == <span class="literal">null</span>) <span class="type">Nil</span> <span class="keyword">else</span> <span class="type">List</span>(top.right.asInstanceOf[<span class="type">Node</span>])</span><br><span class="line">      <span class="type">DFS</span>(left ++ right ++ lB.tail, res ++ <span class="type">List</span>(top.value))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> t = <span class="type">Node</span>(<span class="number">1</span>, <span class="type">Node</span>(<span class="number">2</span>, <span class="type">Node</span>(<span class="number">4</span>), <span class="type">Node</span>(<span class="number">5</span>, <span class="type">Node</span>(<span class="number">7</span>), <span class="type">Node</span>(<span class="number">8</span>))), <span class="type">Node</span>(<span class="number">3</span>, <span class="literal">null</span>, <span class="type">Node</span>(<span class="number">6</span>)))</span><br><span class="line">    <span class="comment">//traverse(t)</span></span><br><span class="line">    <span class="keyword">val</span> res = <span class="type">DFS</span>((<span class="type">List</span>(t), <span class="type">List</span>.empty[<span class="type">Int</span>]))</span><br><span class="line">    println(res._2)  <span class="comment">// List(1, 2, 4, 5, 7, 8, 3, 6)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//val res = DFS((List(t), List.empty[Int]))</span></span><br><span class="line">    <span class="comment">//println(res._2) // List(1, 2, 4, 5, 7, 8, 3, 6)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统-基于FM模型的召回</title>
      <link href="/2021/07/08/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E4%BA%8EFM%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%AC%E5%9B%9E/"/>
      <url>/2021/07/08/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E4%BA%8EFM%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%AC%E5%9B%9E/</url>
      
        <content type="html"><![CDATA[<p>这篇文章我会介绍在推荐系统中如何基于FM模型来做召回。召回可以粗略地分为两大类，一种是统计类的，比如ItemCF, UserCF，都是基于对历史大数据的统计，找到相似矩阵，不涉及模型训练。另一种是模型类的，比如FM、YoutubeNet、DSSM之类的，有确定的模型以及损失函数。</p><span id="more"></span><h2 id="召回阶段">召回阶段</h2><p>一个最基本的推荐系统必定包含两个phase，召回和排序。很多文章都会提到一句: 召回阶段主要看样本，排序阶段主要靠特征。那这到底是什么意思呢？在推荐系统的召回训练中，负样本 不能仅仅是曝光未点击。排序是从已经圈定的偏好item中再次排序，而召回更多的是侧重一定要排除用户压根不感兴趣的。点击的item用作正样本，这一点毫无争议。那么负样本应该如何构建呢？</p><p>在2020年Facebook最新的论文<a href="https://arxiv.org/abs/2006.11632">《Embedding-based Retrieval in Facebook Search》</a>提到了不能只拿曝光未点击做负样本，负样本需要进行easy negative/hard negative分级。 hard negative就是说根据业务知识判断，来加入负样本。Airbnb在<a href="https://www.kdd.org/kdd2018/accepted-papers/view/real-time-personalization-using-embeddings-for-search-ranking-at-airbnb">《Real-time Personalization using Embeddings for Search Ranking at Airbnb》</a>一文中的做法，就是根据业务逻辑来选取hard negative</p><pre><code>- 增加与正样本同城的房间作为负样本，增强了正负样本在地域上的相似性，加大了模型的学习难度- 增加“被房主拒绝”作为负样本，增强了正负样本在“匹配用户兴趣爱好”上的相似性，加大了模型的学习难度</code></pre><p>而easy negative就是用一种随机采样的方式来模拟负样本的产生。那么我们能和排序阶段一样使用&lt;user, item, label&gt;这样的格式吗？一般的我们会在排序时使用pointwise形式的样本，在召回阶段我们应该更倾向使用pairwise形式的样本。 理由如下:</p><ol type="1"><li>负样本大多是随机生成(easy nagative)，不应该严格的说user偏好或者不偏好这种二元信息，而是一种相对偏好，比如user点击了a，而b是随机生成，我们会说user相比较b更偏好a</li><li>召回样本区别于排序中常见的&lt;user, item, label&gt;，而是三元组&lt;user, item+, item-&gt;，预测的目标是MatchScore(user, item+)要远高于MatchScore(user, item-)</li></ol><h2 id="fm模型">FM模型</h2><p>FM模型和一般的线性模型相比只是多考虑了特征交叉项， <span class="math display">\[\begin{equation}\hat{y}(x) = w_{0} + \sum_{i = 1}^n w_{i}x_{i} + \sum_{i = 1}^n\sum_{j = i+1}^nw_{i, j}x_{i}x_j\end{equation}\]</span></p><p>上述的交叉项满足不为0的条件非常少(需要<span class="math inline">\(x_i\)</span>,x_j$均不为0)，当样本训练不足时容易导致参数训练不充分，影响模型效果，所以交叉项参数的训练问题我们采用矩阵分解近似计算。</p><p><span class="math display">\[\begin{equation}\label{2}\begin{split}\hat{y}(x) &amp;= w_{0} + \sum_{i = 1}^n w_{i}x_{i} + \sum_{i = 1}^n\sum_{j = i+1}^n&lt;v_i, v_j&gt;x_{i}x_j \\&lt;v_i, v_j&gt; &amp;= \sum_{f=1}^{k}v_{j, f}v_{j,f} \\\end{split}\end{equation}\]</span></p><p>其中模型需要估计的参数是 <span class="math inline">\(w_0 \in \mathbb{R}, \mathbf{w} \in \mathbb{R}^n, \mathbf{V} \in \mathbb{R}^{n \times k}\)</span></p><p>如果直接计算公式<span class="math inline">\(\ref{2}\)</span>,其时间复杂度<span class="math inline">\(O(kn^2)\)</span>，通过公式变换可以减少到线性复杂度 <span class="math display">\[\begin{equation}\begin{split}&amp;\sum_{i=1}^{n}\sum_{j=i+1}^{n}&lt;v_j, v_j&gt;x_ix_j \\&amp;= \frac{1}{2}\sum_{i=1}^{n}\sum_{j=1}^{n}&lt;v_j, v_j&gt;x_ix_j - \frac{1}{2}\sum_{i=1}^n&lt;v_j,v_j&gt;x_ix_j \\&amp;= \frac{1}{2}( \sum_{i=1}^n\sum_{j=1}^n\sum_{f=1}^kv_{i, f}v_{j, f}x_ix_j - \sum_{i=1}^n\sum_{f=1}^kv_{i, f}v_{i,f}x_ix_i ) \\&amp;= \frac{1}{2}\sum_{f=1}^k( (\sum_{i=1}^nv_{i,f}x_i)(\sum_{j=1}^n)v_{j, f}x_j) - \sum_{i = 1}^{n}v_{i, f}^2x_i^2) \\&amp;= \frac{1}{2}\sum_{f=1}^k( (\sum_{i=1}^nv_{i,f}x_i)^2 - \sum_{i = 1}^n v_{i,f}^2x_i^2)\end{split}\end{equation}\]</span></p><p>怎么理解上述的公式呢? FM模型最终的模型结果不但有每个维度的权重还会有每个维度对应的一个向量。如下图所示(假设一共有n个维度, 隐藏维度是k)</p><p><span class="math display">\[\begin{equation}\begin{matrix}v_{0, 0} &amp; v_{0, 1} &amp; \cdots &amp; v_{0, k-1} \\v_{1, 0} &amp; v_{1, 1} &amp; \cdots &amp; v_{1, k-1} \\\vdots &amp; \vdots &amp; \ddots &amp;\vdots \\v_{n-1, 0} &amp; v_{n-1, 1} &amp; \cdots &amp; v_{n-1, k-1}\\\end{matrix}\end{equation}\]</span></p><h3 id="ffm模型">FFM模型</h3><p>FFM（Field-aware Factorization Machine）作为FM的升级版模型。通过引入field的概念，FFM把相同性质的特征归于同一个field。在FFM中，每一维特征<span class="math inline">\(X_{i}\)</span>， 针对其它特征的每一种field <span class="math inline">\(f_j\)</span>，都会学习一个隐向量 <span class="math inline">\(v_{i,f_j}\)</span>。因此，隐向量不仅与特征相关，也与field相关。</p><p><span class="math display">\[\begin{equation}\hat{y}(x) = w_{0} + \sum_{i = 1}^n w_{i}x_{i} + \sum_{i = 1}^n\sum_{j = i+1}^n&lt;v_{i, f_j}, v_{j,f_i}&gt;x_{i}x_j\end{equation}\]</span></p><p>举个例子</p><ol type="1"><li>现在有交叉项<span class="math inline">\(&lt;v_{i, f_j}, v_{j,f_i}&gt;x_{i}x_j\)</span></li><li><span class="math inline">\(f_j\)</span>是<span class="math inline">\(x_j\)</span>所属的field，<span class="math inline">\(f_i\)</span>是<span class="math inline">\(x_i\)</span>所属的field</li><li>某个具体的特征x一定只会所属一个field</li><li>2个特征维度组合时，就会拿“对方”的所属field</li><li>FFM 当然也会包含属于同一个field下的维度两两组合</li></ol><p>鉴于FFM的特性，我们没有办法对其进行线性计算优化，感兴趣的读者可以尝试使用<a href="https://www.csie.ntu.edu.tw/~cjlin/libffm/">libFFM</a>, 另外，FFM的求解参数一共有nfk个(假设有n个维度，f个field，k维隐藏向量), 不能像FM一样优化，求解速度较慢。</p><h3 id="样本选择">样本选择</h3><p>样本选择其实就一个注意点: 打压hot item。在之前的协同过滤中也提到打压方式，这里的打压思想也是一致的，我们要降低hot item被采样到的概率。</p><p><span class="math display">\[\begin{equation}\label{sampling}\begin{split}P_{pos}(w_i) &amp;= (\sqrt{\frac{z(w_i)}{\alpha}} + 1) \frac{\alpha}{z(w_i)} \\P_{neg}(w_i) &amp;= \frac{f(w_i)^{\beta}}{\sum_wf(w)^{\beta}}\end{split}\end{equation}\]</span></p><p>在上述<span class="math inline">\(\ref{sampling}\)</span>公式中，如果希望对hot item在采样时打压更加厉害，可以减小<span class="math inline">\(\alpha\)</span>和<span class="math inline">\(\beta\)</span>,<span class="math inline">\(\alpha\)</span>的范围一般是<span class="math inline">\(1e^{-3}\)</span>到<span class="math inline">\(1e^{-5}\)</span> , <span class="math inline">\(\beta\)</span>一般取0.75。这两个采样公式正是来自word2vec中所用的公式。</p><p>在具体工程实践时，可以借助框架(比如spark)实现的分层采样(stratified sampling): <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> df = sampleDF.stat.sampleBy(<span class="string">&quot;video_id&quot;</span>, fractions, <span class="number">1024</span>L)</span><br></pre></td></tr></table></figure></p><h3 id="fm模型的求解">FM模型的求解</h3><p>这边我会根据链式求导法则列出FM模型的求解过程，在实际应用中并不需要，目前的深度学习框架都提供了自动求导。</p><p>针对一个二分类问题，其损失函数如下图所示(假设用BGD, 一个Batch的size为N, 维度大小为n 隐藏维度大小是d)</p><p><span class="math display">\[\begin{equation}\label{FMderive}\begin{split}J &amp;= - \frac{1}{N} \sum_{i=0}^{N-1}y^{(i)}\ln{\hat{y}^{(i)}} + (1 - y^{(i)})\ln{(1 - \hat{y}^{(i)})} \\\hat{y}^{(i)} &amp;= \phi{(z^{(i)})} = \frac{1}{1 + e^{(-z^{(i)})}} \\z &amp;= \omega_0 + \sum\omega_ix_i + \sum_{i = 1}^n\sum_{j = i+1}^n&lt;v_{i, f_j}, v_{j,f_i}&gt;x_{i}x_j \\\end{split}\end{equation}\]</span></p><p>所以我们会得到求导公式 <span class="math display">\[\begin{equation}\label{derivation}\begin{split}\frac{\partial J}{\partial \phi{(z)}} \frac{\phi{(z)} }{z} &amp;= -\frac{1}{N}\sum_{i = 0}^{N-1} (y^{(i)} - \phi{(z^{i})}) \\&amp;= -\frac{1}{N}(\mathbf{Y} - \Phi{(\mathbf{Z})})^T \mathbf{I}\end{split}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\frac{\partial z}{\partial \theta} =  \begin{cases}1, &amp; \theta = \omega_0 \\x_i, &amp; \theta = \omega_i \\x_i\sum_{j = 1}^n v_{j, f}x_j - v_{i, f}x_i^2, &amp; \theta = v_{i, f} \\\end{cases}\end{equation}\]</span></p><h3 id="基于fm的召回模型">基于FM的召回模型</h3><p>前面讲述的内容只能算铺垫，最关键的损失函数(目标函数)还没有展示给大家，直接抛出公式</p><p><span class="math display">\[\begin{equation}\label{FM}\begin{split}J &amp;= -\frac{1}{N}\sum_iy^{(i)}ln\hat{y}^{(i)} + (1 - y^{(i)})ln(1-\hat{y}^{(i)}) \\\hat{y}^{(i)} &amp;= \phi(z^{(i)}) = \frac{1}{1 + e^{-z^{(i)}}} \\z^{(i)} &amp;= y_{fm}(x_{+}^{(i)}) - y_{fm}(x_{-}^{(i)}) \\y_{fm}(x) &amp;= w_0 + \sum_{i=1}^n w_ix_i + \sum_{i=1}^d\sum_{j=i+1}^d&lt;v_i, v_j&gt;x_ix_j \\\end{split}\end{equation}\]</span></p><p><span class="math inline">\(y^{(i)}\)</span>表示真实样本label，例如对于三元样本&lt;user, item+, item-&gt; 它的label应该是1，同时我们还是使用交叉熵做为损失函数，这边交叉熵的概率描述的是pair样本之间的优先级关系。</p><p>下面是核心代码片段展示 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">HIDDEN_NUM = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">inputsPos = tf.compat.v1.placeholder(tf.int32)</span><br><span class="line"></span><br><span class="line">inputsNeg = tf.compat.v1.placeholder(tf.int32)</span><br><span class="line"></span><br><span class="line">linearW = tf.Variable(tf.random_normal([FEATURE_NUM, <span class="number">1</span>], <span class="number">0.0</span>, <span class="number">1.0</span>))</span><br><span class="line"></span><br><span class="line">embedding = tf.Variable(tf.random_normal([FEATURE_NUM, HIDDEN_NUM], <span class="number">0.0</span>, <span class="number">1.0</span>))</span><br><span class="line"></span><br><span class="line">linear_op = tf.compat.v1.reduce_sum(tf.nn.embedding_lookup(linearW, inputsPos), axis=<span class="number">1</span>) \</span><br><span class="line">            - tf.compat.v1.reduce_sum(tf.nn.embedding_lookup(linearW, inputsNeg), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cross_op_a = tf.compat.v1.reduce_sum(</span><br><span class="line">    tf.square(tf.compat.v1.reduce_sum(tf.nn.embedding_lookup(embedding, inputsPos), axis=<span class="number">1</span>)), axis=<span class="number">1</span>)</span><br><span class="line">cross_op_b = tf.compat.v1.reduce_sum(</span><br><span class="line">    tf.compat.v1.reduce_sum(tf.square(tf.nn.embedding_lookup(embedding, inputsPos)), axis=<span class="number">1</span>), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cross_op_inner = (tf.square(tf.compat.v1.reduce_sum(tf.nn.embedding_lookup(embedding, inputsPos), axis=<span class="number">1</span>)) -</span><br><span class="line">                  tf.compat.v1.reduce_sum(tf.square(tf.nn.embedding_lookup(embedding, inputsPos)), axis=<span class="number">1</span>)) - \</span><br><span class="line">                 (tf.square(tf.compat.v1.reduce_sum(tf.nn.embedding_lookup(embedding, inputsNeg), axis=<span class="number">1</span>)) -</span><br><span class="line">                  tf.compat.v1.reduce_sum(tf.square(tf.nn.embedding_lookup(embedding, inputsNeg)), axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">cross_op = <span class="number">0.5</span> * tf.compat.v1.reduce_sum(cross_op_inner, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">z = tf.clip_by_value(linear_op + cross_op, -<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># 只有label = 1 所以只有一项</span></span><br><span class="line">cost_func = - tf.reduce_mean(tf.math.log(tf.nn.sigmoid(z)))</span><br></pre></td></tr></table></figure> 求解过程就交给tensorflow吧，在笔者的电脑配置(2018 Macbook)上，300W维度的以BSD方式进行的梯度训练。一共1.5W个batch 耗时30min。</p><h3 id="向量检索">向量检索</h3><p>生产环境中，我们都需要借助向量检索引擎来完成召回。假设我们已经完成了FM的训练，我们召回的目标就是<span class="math inline">\(\hat{y}_{fm}(x)\)</span>的TopN个。但是这个表达式应该怎么算呢?</p><pre class="mermaid">graph LR    d1["item 向量"] --> d2["v0|v1|v2|...|vf_1|1|1|"]    d3["user 向量"] --> d4["v0|v1|v2|...|vf_1|w_0|w_1|"]</pre><p>如上图所示，在使用向量检索引擎时需要把item侧的向量都放入引擎内(比如milvus), 同时要在低位补充1，另一方方面，user侧的向量累加后，还需要在低位补足对应的weight。 总之就是把FM的公式改写成向量内积的形式，这样就可以使用向量检索引擎了。</p><h2 id="小结">小结</h2><ol type="1"><li>在召回阶段，我们借助learning-to-rank的思想，计算item之间的偏序</li><li>借助FM模型，我们可以把所有的id类特征向量化，做成一个双塔模型</li><li>采样过程要注意对hot item的降采样</li><li>FM模型做为一个基础模型，还可以有很多变种，比如NFM模型，FFM模型</li></ol><p>参考:</p><ol type="1"><li><p><a href="https://zhuanlan.zhihu.com/p/50426292" class="uri">https://zhuanlan.zhihu.com/p/50426292</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/165064102" class="uri">https://zhuanlan.zhihu.com/p/165064102</a></p></li><li><p><a href="https://blog.csdn.net/qq_25628891/article/details/84033472" class="uri">https://blog.csdn.net/qq_25628891/article/details/84033472</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>akka学习笔记(一)</title>
      <link href="/2021/06/30/akka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
      <url>/2021/06/30/akka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>akka是什么? akka是一个基于actor并发模型的框架，该模型可以追溯到1973年发表的论文《A Universal Modular Actor Formalism for Artificial Intelligence 》， Actor就源于该模型。</p><p>actor通过消息传递的方式与外界通信。消息传递是异步的。每个actor都有一个邮箱，该邮箱接收并缓存其他actor发过来的消息，actor一次只能同步处理一个消息，处理消息过程中，除了可以接收消息，不能做任何其他操作。</p><span id="more"></span><p>Akka的哲学是基于End to End Argument这个事实的，即：在分布式环境中，reliable的通信需要在application层来确保，中间件层或者infrastructure只能提供效率上的帮助，而绝对无法保证reliability。</p><p>akka是一个基于actor模型的框架，提供了极致的异步并发处理性能，但是分布式条件下的可靠性需要使用者来保障</p><h2 id="akka模块">akka模块</h2><p>以下列出了akka核心模块，所有akka的核心功能模块均遵循开源软件协议(Open Source Software (OSS)), Lightbend同时也提供商业版本，提供基于akka的增强功能。</p><ul><li>akka library<ul><li>How to build and design high-performance, concurrent applications.</li><li>How to handle errors in a multi-threaded environment.</li><li>How to protect my project from the pitfalls of concurrency.</li></ul></li><li>remoting<ul><li>How to address actor systems living on remote hosts.</li><li>How to address individual actors on remote actor systems.</li><li>How to turn messages to bytes on the wire.</li><li>How to manage low-level, network connections (and reconnections) between hosts, detect crashed actor systems and hosts, all transparently.</li><li>How to multiplex communications from an unrelated set of actors on the same network connection, all transparently.</li></ul></li><li>Cluster<ul><li>How to maintain a set of actor systems (a cluster) that can communicate with each other and consider each other as part of the cluster.</li><li>How to introduce a new system safely to the set of already existing members.</li><li>How to reliably detect systems that are temporarily unreachable.</li><li>How to remove failed hosts/systems (or scale down the system) so that all remaining members agree on the remaining subset of the cluster.</li><li>How to distribute computations among the current set of members.</li><li>How to designate members of the cluster to a certain role, in other words, to provide certain services and not others.</li></ul></li><li>Cluster Sharding<ul><li>How to model and scale out a large set of stateful entities on a set of systems.</li><li>How to ensure that entities in the cluster are distributed properly so that load is properly balanced across the machines.</li><li>How to ensure migrating entities from a crashed system without losing the state.</li><li>How to ensure that an entity does not exist on multiple systems at the same time and hence keeps consistent.</li></ul></li><li>Cluster Singleton<ul><li>How to ensure that only one instance of a service is running in the whole cluster.</li><li>How to ensure that the service is up even if the system hosting it currently crashes or shuts down during the process of scaling down.</li><li>How to reach this instance from any member of the cluster assuming that it can migrate to other systems over time.</li></ul></li><li>Persistence<ul><li>How to restore the state of an entity/actor when system restarts or crashes.</li><li>How to implement a CQRS system.</li><li>How to ensure reliable delivery of messages in face of network errors and system crashes.</li><li>How to introspect domain events that have led an entity to its current state.</li><li>How to leverage Event Sourcing in your application to support long-running processes while the project continues to evolve.</li></ul></li><li>projections<ul><li>Constructing alternate or aggregate views over an event stream.</li><li>Propagating an event stream onto another downstream medium such as a Kafka topic.</li><li>A simple way of building read-side projections in the context of Event Sourcing and CQRS system</li></ul></li><li>Distributed Data<ul><li>How to accept writes even in the face of cluster partitions.</li><li>How to share data while at the same time ensuring low-latency local read and write access.</li></ul></li><li>Streams<ul><li>How to handle streams of events or large datasets with high performance, exploiting concurrency and keeping resource usage tight.</li><li>How to assemble reusable pieces of event/data processing into flexible pipelines.</li><li>How to connect asynchronous services in a flexible way to each other with high performance.</li><li>How to provide or consume Reactive Streams compliant interfaces to interface with a third party library.</li></ul></li><li>Alpakka <strong>Alpakka is a separate module from Akka</strong><ul><li>Connecting various infrastructure or persistence components to Stream based flows.</li><li>Connecting to legacy systems in a manner that adheres to a Reactive Streams API.</li></ul></li><li>HTTP <strong>Akka HTTP is a separate module from Akka.</strong><ul><li>How to expose services of a system or cluster to the external world via an HTTP API in a performant way.</li><li>How to stream large datasets in and out of a system using HTTP.</li><li>How to stream live events in and out of a system using HTTP.</li></ul></li><li>gRPC <strong>Akka gRPC is a separate module from Akka.</strong><ul><li>Exposing services with all the benefits of gRPC &amp; protobuf:</li><li>Schema-first contract</li><li>Schema evolution support</li><li>Efficient binary protocol</li><li>First-class streaming support</li><li>Wide interoperability</li><li>Use of HTTP/2 connection multiplexing</li></ul></li></ul><p>如果需要使用akka内部的module，需要添加如下依赖 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="type">AkkaVersion</span> = <span class="string">&quot;2.5.21&quot;</span></span><br><span class="line"></span><br><span class="line">libraryDependencies += <span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-actor-typed&quot;</span> % <span class="type">AkkaVersion</span></span><br><span class="line"></span><br><span class="line">libraryDependencies += <span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-remote&quot;</span> % <span class="type">AkkaVersion</span></span><br><span class="line"></span><br><span class="line">libraryDependencies += <span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-cluster-typed&quot;</span> % <span class="type">AkkaVersion</span></span><br><span class="line"></span><br><span class="line">libraryDependencies += <span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-cluster-sharding-typed&quot;</span> % <span class="type">AkkaVersion</span></span><br><span class="line"></span><br><span class="line">libraryDependencies += <span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-cluster-singleton&quot;</span> % <span class="type">AkkaVersion</span></span><br><span class="line"></span><br><span class="line">libraryDependencies += <span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-persistence-typed&quot;</span> % <span class="type">AkkaVersion</span></span><br><span class="line"></span><br><span class="line">libraryDependencies += <span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-projection-core&quot;</span> % <span class="type">AkkaVersion</span></span><br><span class="line"></span><br><span class="line">libraryDependencies += <span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-cluster-typed&quot;</span> % <span class="type">AkkaVersion</span></span><br><span class="line"></span><br><span class="line">libraryDependencies += <span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-stream-typed&quot;</span> % <span class="type">AkkaVersion</span></span><br></pre></td></tr></table></figure></p><h2 id="actor层次结构">actor层次结构</h2><p><img src="actor_top_tree.png" /></p><ul><li><strong>/</strong> 称作root guardian，是系统内所有actor的parent, 当一个系统被关闭时，它也是最后一个被停止的actor</li><li><strong>/system</strong> 称作system guardian. Akka 或者其它的内置libraries可能会在此创建actor在system的命名空间下</li><li><strong>/user</strong> 称作user guardian. 应用内创建的actor都会在它下面</li></ul><p>无论何时terminate actor, 它的子actor会首先递归停止. 停止一个子actor可以通过在其parent actor调用 <strong>context.stop(childRef)</strong>,</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StartStopActor1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Behavior</span>[<span class="type">String</span>] =</span><br><span class="line">    <span class="type">Behaviors</span>.setup(context =&gt; <span class="keyword">new</span> <span class="type">StartStopActor1</span>(context))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StartStopActor1</span>(<span class="params">context: <span class="type">ActorContext</span>[<span class="type">String</span>]</span>) <span class="keyword">extends</span> <span class="title">AbstractBehavior</span>[<span class="type">String</span>]</span>&#123;</span><br><span class="line">  println(<span class="string">&quot;first started&quot;</span>)</span><br><span class="line">  context.spawn(<span class="type">StartStopActor2</span>(), <span class="string">&quot;second&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onMessage</span></span>(msg: <span class="type">String</span>): <span class="type">Behavior</span>[<span class="type">String</span>] =</span><br><span class="line">    msg <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;stop&quot;</span> =&gt; <span class="type">Behaviors</span>.stopped</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onSignal</span></span>: <span class="type">PartialFunction</span>[<span class="type">Signal</span>, <span class="type">Behavior</span>[<span class="type">String</span>]] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">PostStop</span> =&gt;</span><br><span class="line">      println(<span class="string">&quot;first stopped&quot;</span>)</span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StartStopActor2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Behavior</span>[<span class="type">String</span>] =</span><br><span class="line">    <span class="type">Behaviors</span>.setup(<span class="keyword">new</span> <span class="type">StartStopActor2</span>(_))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StartStopActor2</span>(<span class="params">context: <span class="type">ActorContext</span>[<span class="type">String</span>]</span>) <span class="keyword">extends</span> <span class="title">AbstractBehavior</span>[<span class="type">String</span>] </span>&#123;</span><br><span class="line">  println(<span class="string">&quot;second started&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onMessage</span></span>(msg: <span class="type">String</span>): <span class="type">Behavior</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="comment">// no messages handled by this actor</span></span><br><span class="line">    <span class="type">Behaviors</span>.unhandled</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onSignal</span></span>: <span class="type">PartialFunction</span>[<span class="type">Signal</span>, <span class="type">Behavior</span>[<span class="type">String</span>]] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">PostStop</span> =&gt;</span><br><span class="line">      println(<span class="string">&quot;second stopped&quot;</span>)</span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Behavior</span>[<span class="type">String</span>] =</span><br><span class="line">    <span class="type">Behaviors</span>.setup(context =&gt; <span class="keyword">new</span> <span class="type">Main</span>(context))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span>(<span class="params">context: <span class="type">ActorContext</span>[<span class="type">String</span>]</span>) <span class="keyword">extends</span> <span class="title">AbstractBehavior</span>[<span class="type">String</span>](<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onMessage</span></span>(msg: <span class="type">String</span>): <span class="type">Behavior</span>[<span class="type">String</span>] =</span><br><span class="line">    msg <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;first&quot;</span> =&gt;</span><br><span class="line">        <span class="keyword">val</span> first = context.spawn(<span class="type">StartStopActor1</span>(), <span class="string">&quot;first&quot;</span>)</span><br><span class="line">        println(<span class="string">s&quot;fistActor: <span class="subst">$&#123;first&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="type">Thread</span>.sleep(<span class="number">4000</span>)</span><br><span class="line">        first ! <span class="string">&quot;stop&quot;</span></span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ActorHierarchyExperiments</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> testSystem = <span class="type">ActorSystem</span>(<span class="type">Main</span>(), <span class="string">&quot;testSystem&quot;</span>)</span><br><span class="line">  testSystem ! <span class="string">&quot;first&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first started</span><br><span class="line">second started</span><br><span class="line">second stopped</span><br><span class="line">first stopped</span><br></pre></td></tr></table></figure> 很显然，second 首先被terminated 然后才是actor1，以上代码就说明了actor的这个特性: 在parent actor停止之前，会递归地停止它的子actor。</p><h2 id="异常处理">异常处理</h2><p>和传统的防御性编程不同，Akka沿袭了Erlang的let it crash哲学，当actor内部发生异常时，并不试图捕捉异常并处理，而是重建一个新的actor, 使得整个系统在错误发生的时候可以自动恢复。</p><ul><li><p>监护策略 在Akka中，在子actor被创建后，父actor可以成为子actor的监护者，在子actor出错时负责处理， 有一对一和一对多两种策略：</p><ul><li>OneForOneStrategy 只诛首恶，余者不问。只有出错的actor会被处理。Akka默认采用这种机制。</li><li>OneForAllStrategy 城门失火，殃及池鱼。当出错时，不仅出错的actor,其兄弟actor也采用同样的策略一并处理。</li></ul></li><li><p>恢复策略 actor出错时具体采用何种策略呢？共有四种：</p><ul><li>Stop - 停止出错的actor,不再让它处理任何消息。</li><li>Restart - 这是默认策略，杀死旧的actor,重新创建一个新的actor。</li><li>Resume - 忽略本次错误，恢复actor对消息的处理。</li><li>Escalate - 交给父actor来决定处理策略。</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SupervisingActor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Behavior</span>[<span class="type">String</span>] =</span><br><span class="line">    <span class="type">Behaviors</span>.setup(context =&gt; <span class="keyword">new</span> <span class="type">SupervisingActor</span>(context))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SupervisingActor</span>(<span class="params">context: <span class="type">ActorContext</span>[<span class="type">String</span>]</span>) <span class="keyword">extends</span> <span class="title">AbstractBehavior</span>[<span class="type">String</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> child = context.spawn(</span><br><span class="line">    <span class="type">Behaviors</span>.supervise(<span class="type">SupervisedActor</span>()).onFailure(<span class="type">SupervisorStrategy</span>.restart),</span><br><span class="line">    name = <span class="string">&quot;supervised-actor&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onMessage</span></span>(msg: <span class="type">String</span>): <span class="type">Behavior</span>[<span class="type">String</span>] =</span><br><span class="line">    msg <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;failChild&quot;</span> =&gt;</span><br><span class="line">        child ! <span class="string">&quot;fail&quot;</span></span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SupervisedActor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Behavior</span>[<span class="type">String</span>] =</span><br><span class="line">    <span class="type">Behaviors</span>.setup(context =&gt; <span class="keyword">new</span> <span class="type">SupervisedActor</span>(context))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SupervisedActor</span>(<span class="params">context: <span class="type">ActorContext</span>[<span class="type">String</span>]</span>) <span class="keyword">extends</span> <span class="title">AbstractBehavior</span>[<span class="type">String</span>] </span>&#123;</span><br><span class="line">  println(<span class="string">&quot;supervised actor started&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onMessage</span></span>(msg: <span class="type">String</span>): <span class="type">Behavior</span>[<span class="type">String</span>] =</span><br><span class="line">    msg <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;fail&quot;</span> =&gt;</span><br><span class="line">        println(<span class="string">&quot;supervised actor fails now&quot;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">&quot;I failed!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onSignal</span></span>: <span class="type">PartialFunction</span>[<span class="type">Signal</span>, <span class="type">Behavior</span>[<span class="type">String</span>]] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">PreRestart</span> =&gt;</span><br><span class="line">      println(<span class="string">&quot;supervised actor will be restarted&quot;</span>)</span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">PostStop</span> =&gt;</span><br><span class="line">      println(<span class="string">&quot;supervised actor stopped&quot;</span>)</span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Behavior</span>[<span class="type">String</span>] =</span><br><span class="line">    <span class="type">Behaviors</span>.setup(context =&gt; <span class="keyword">new</span> <span class="type">Main</span>(context))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span>(<span class="params">context: <span class="type">ActorContext</span>[<span class="type">String</span>]</span>) <span class="keyword">extends</span> <span class="title">AbstractBehavior</span>[<span class="type">String</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onMessage</span></span>(msg: <span class="type">String</span>): <span class="type">Behavior</span>[<span class="type">String</span>] =</span><br><span class="line">    msg <span class="keyword">match</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;first&quot;</span> =&gt;</span><br><span class="line">        <span class="keyword">val</span> first = context.spawn(<span class="type">StartStopActor1</span>(), <span class="string">&quot;first&quot;</span>)</span><br><span class="line">        println(<span class="string">s&quot;fistActor: <span class="subst">$&#123;first&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="type">Thread</span>.sleep(<span class="number">4000</span>)</span><br><span class="line">        first ! <span class="string">&quot;stop&quot;</span></span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;failure&quot;</span>=&gt;</span><br><span class="line">        <span class="keyword">val</span> supervisingActor = context.spawn(<span class="type">SupervisingActor</span>(), <span class="string">&quot;supervising-actor&quot;</span>)</span><br><span class="line">        supervisingActor ! <span class="string">&quot;failChild&quot;</span></span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ActorHierarchyExperiments</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> testSystem = <span class="type">ActorSystem</span>(<span class="type">Main</span>(), <span class="string">&quot;testSystem&quot;</span>)</span><br><span class="line">  testSystem ! <span class="string">&quot;failure&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会看到以下输出: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">supervised actor started</span><br><span class="line">supervised actor fails now</span><br><span class="line">supervised actor will be restarted</span><br><span class="line">supervised actor started</span><br><span class="line">[ERROR] [06/30/2021 12:01:41.800] [testSystem-akka.actor.default-dispatcher-3] [akka://testSystem/user/supervising-actor/supervised-actor] Supervisor RestartSupervisor saw failure: I failed!</span><br><span class="line">java.lang.Exception: I failed!</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>在发生failure之后，被监控的actor停止然后立刻restarted(这就是为什么会打印出supervised actor will be restarted 但是没有supervised actor stopped)</p><h2 id="一个iot例子">一个IoT例子</h2><p><img src="device_manager_tree.png" /></p><p>官方文档提供了一个IoT例子，在这个IoT系统中分别有三个角色DevcieActor, DeviceGroup, DeviceManager以及一哥查询功能queryActor</p><p>DeviceActor这个角色有两个任务，记录温度，读取温度。</p><p>DevcieGroup 需要保存记录在Group下的device信息(使用一个内部Map对象实现)，主要任务有两个，当创建一个新的deviceActor时监控它，当收到actordevice stop消息需要从Map中移除。这个功能我们用以下代码实现 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">context.watchWith(deviceActor, <span class="type">DeviceTerminated</span>(deviceActor, groupId, deviceId))</span><br><span class="line"><span class="comment">//Registers this actor as a Monitor for the provided ActorRef. This actor will receive the specified message when watched actor is terminated.</span></span><br></pre></td></tr></table></figure> 上述代码的含义是，当deviceActor is terminated, 当前actor会收到消息DeviceTerminated(deviceActor, groupId, deviceId)</p><p>DeviceManager和DeviceGroup任务类似，同样要按需注册groupActor以及当groupActor停止时移除</p><p>在一个非query场景下，我们考虑的状态信息时很少的，官网中是这样说的:</p><ul><li>Device actors return a reading, which requires no state change</li><li>Record a temperature, which updates a single field</li><li>Device Group actors maintain group membership by adding or removing entries from a map</li></ul><p>然而，假设我们需要查询一个group下的所有temperature，可能会发生这些意外</p><ul><li>A device actor might stop and not be able to respond back with a temperature reading.</li><li>A new device actor might start up and not be included in the query because we weren’t aware of it.</li><li>some actors might take a long time to answer</li></ul><p>这些情形确实客观存在，最重要的是<strong>行为状态</strong>确定化，官网给出的solution如下</p><ol type="1"><li>When a query arrives, the group actor takes a snapshot of the existing device actors and will only ask those actors for the temperature.</li><li>Actors that start up after the query arrives are ignored.</li><li>If an actor in the snapshot stops during the query without answering, we will report the fact that it stopped to the sender of the query message.</li><li>All actors in the snapshot have either responded or have confirmed being stopped.</li><li>We reach a pre-defined deadline.</li></ol><p>综合以上场景，我们将定义4种devcie状态来应对query</p><ul><li>It has a temperature available: Temperature.</li><li>It has responded, but has no temperature available yet: TemperatureNotAvailable.</li><li>It has stopped before answering: DeviceNotAvailable.</li><li>It did not respond before the deadline: DeviceTimedOut.</li></ul><p>这个query任务也会单独作为一类actor存在，它需要获得以下信息:</p><ol type="1"><li>The snapshot and IDs of active device actors to query.</li><li>The ID of the request that started the query (so that we can include it in the reply).</li><li>The reference of the actor who sent the query. We will send the reply to this actor directly.</li><li>A deadline that indicates how long the query should wait for replies. Making this a parameter will simplify testing.</li></ol><p>具体实现时，通过一个set记录正在排队等待temperature的deviceActor, 一个map用来记录查询到的temperature</p><p>完整的代码 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.typed.<span class="type">ActorRef</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.typed.<span class="type">Behavior</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.typed.<span class="type">PostStop</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.typed.<span class="type">Signal</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.typed.scaladsl.&#123;<span class="type">AbstractBehavior</span>, <span class="type">ActorContext</span>, <span class="type">Behaviors</span>, <span class="type">TimerScheduler</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.concurrent.duration.&#123;<span class="type">DurationInt</span>, <span class="type">FiniteDuration</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(groupId: <span class="type">String</span>, deviceId: <span class="type">String</span>): <span class="type">Behavior</span>[<span class="type">Command</span>] =</span><br><span class="line">    <span class="type">Behaviors</span>.setup(context =&gt; <span class="keyword">new</span> <span class="type">Device</span>(context, groupId, deviceId))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Command</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//typical Request-Response pattern</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadTemperature</span>(<span class="params">requestId: <span class="type">Long</span>, replyTo: <span class="type">ActorRef</span>[<span class="type">RespondTemperature</span>]</span>) <span class="keyword">extends</span> <span class="title">Command</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">RespondTemperature</span>(<span class="params">requestId: <span class="type">Long</span>, deviceId: <span class="type">String</span>, value: <span class="type">Option</span>[<span class="type">Double</span>]</span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordTemperature</span>(<span class="params">requestId: <span class="type">Long</span>, value: <span class="type">Double</span>, replyTo: <span class="type">ActorRef</span>[<span class="type">TemperatureRecorded</span>]</span>)</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="type">Command</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">TemperatureRecorded</span>(<span class="params">requestId: <span class="type">Long</span></span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Passivate</span> <span class="keyword">extends</span> <span class="title">Command</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span>(<span class="params">context: <span class="type">ActorContext</span>[<span class="type">Device</span>.<span class="type">Command</span>], groupId: <span class="type">String</span>, deviceId: <span class="type">String</span></span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">AbstractBehavior</span>[<span class="type">Device</span>.<span class="type">Command</span>] &#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">Device</span>._</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> lastTemperatureReading: <span class="type">Option</span>[<span class="type">Double</span>] = <span class="type">None</span></span><br><span class="line"></span><br><span class="line">  context.log.info(<span class="string">s&quot;Device actor <span class="subst">$&#123;groupId&#125;</span>-<span class="subst">$&#123;deviceId&#125;</span> started&quot;</span> )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onMessage</span></span>(msg: <span class="type">Command</span>): <span class="type">Behavior</span>[<span class="type">Command</span>] = &#123;</span><br><span class="line">    msg <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">RecordTemperature</span>(id, value, replyTo) =&gt;</span><br><span class="line">        context.log.info(<span class="string">s&quot;Recorded temperature reading <span class="subst">$&#123;value&#125;</span> with <span class="subst">$&#123;id&#125;</span>&quot;</span>)</span><br><span class="line">        lastTemperatureReading = <span class="type">Some</span>(value)</span><br><span class="line">        replyTo ! <span class="type">TemperatureRecorded</span>(id)</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">ReadTemperature</span>(id, replyTo) =&gt;</span><br><span class="line">        replyTo ! <span class="type">RespondTemperature</span>(id, deviceId, lastTemperatureReading)</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">Passivate</span> =&gt;</span><br><span class="line">        <span class="type">Behaviors</span>.stopped</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onSignal</span></span>: <span class="type">PartialFunction</span>[<span class="type">Signal</span>, <span class="type">Behavior</span>[<span class="type">Command</span>]] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">PostStop</span> =&gt;</span><br><span class="line">      context.log.info(<span class="string">s&quot;Device actor <span class="subst">$&#123;groupId&#125;</span>-<span class="subst">$&#123;deviceId&#125;</span> stopped&quot;</span>)</span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// device group</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DeviceGroup</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(groupId: <span class="type">String</span>): <span class="type">Behavior</span>[<span class="type">Command</span>] =</span><br><span class="line">    <span class="type">Behaviors</span>.setup(context =&gt; <span class="keyword">new</span> <span class="type">DeviceGroup</span>(context, groupId))</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Command</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceTerminated</span>(<span class="params">device: <span class="type">ActorRef</span>[<span class="type">Device</span>.<span class="type">Command</span>], groupId: <span class="type">String</span>, deviceId: <span class="type">String</span></span>)</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="type">Command</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeviceGroup</span>(<span class="params">context: <span class="type">ActorContext</span>[<span class="type">DeviceGroup</span>.<span class="type">Command</span>], groupId: <span class="type">String</span></span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">AbstractBehavior</span>[<span class="type">DeviceGroup</span>.<span class="type">Command</span>] &#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">DeviceGroup</span>._</span><br><span class="line">  <span class="keyword">import</span> <span class="type">DeviceManager</span>.&#123; <span class="type">DeviceRegistered</span>, <span class="type">ReplyDeviceList</span>, <span class="type">RequestDeviceList</span>, <span class="type">RequestTrackDevice</span>, <span class="type">RequestAllTemperatures</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> deviceIdToActor = <span class="type">Map</span>.empty[<span class="type">String</span>, <span class="type">ActorRef</span>[<span class="type">Device</span>.<span class="type">Command</span>]]</span><br><span class="line"></span><br><span class="line">  context.log.info(<span class="string">s&quot;DeviceGroup <span class="subst">$&#123;groupId&#125;</span> started&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onMessage</span></span>(msg: <span class="type">Command</span>): <span class="type">Behavior</span>[<span class="type">Command</span>] =</span><br><span class="line">    msg <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> trackMsg @ <span class="type">RequestTrackDevice</span>(`groupId`, deviceId, replyTo) =&gt;</span><br><span class="line">        deviceIdToActor.get(deviceId) <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Some</span>(deviceActor) =&gt;</span><br><span class="line">            replyTo ! <span class="type">DeviceRegistered</span>(deviceActor)</span><br><span class="line">          <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">            context.log.info(<span class="string">s&quot;Creating device actor for <span class="subst">$&#123;trackMsg.deviceId&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> deviceActor = context.spawn(<span class="type">Device</span>(groupId, deviceId), <span class="string">s&quot;device-<span class="subst">$deviceId</span>&quot;</span>)</span><br><span class="line">            context.watchWith(deviceActor, <span class="type">DeviceTerminated</span>(deviceActor, groupId, deviceId))</span><br><span class="line">            deviceIdToActor += deviceId -&gt; deviceActor</span><br><span class="line">            replyTo ! <span class="type">DeviceRegistered</span>(deviceActor)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">RequestTrackDevice</span>(gId, _, _) =&gt;</span><br><span class="line">        context.log.warning(<span class="string">s&quot;Ignoring TrackDevice request for <span class="subst">$&#123;gId&#125;</span>. This actor is responsible for <span class="subst">$&#123;groupId&#125;</span>.&quot;</span>)</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">RequestDeviceList</span>(requestId, gId, replyTo) =&gt;</span><br><span class="line">        <span class="keyword">if</span> (gId == groupId) &#123;</span><br><span class="line">          replyTo ! <span class="type">ReplyDeviceList</span>(requestId, deviceIdToActor.keySet)</span><br><span class="line">          <span class="keyword">this</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          <span class="type">Behaviors</span>.unhandled</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">DeviceTerminated</span>(_, _, deviceId) =&gt;</span><br><span class="line">        context.log.info(<span class="string">s&quot;Device actor for <span class="subst">$&#123;deviceId&#125;</span> has been terminated&quot;</span>)</span><br><span class="line">        deviceIdToActor -= deviceId</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">RequestAllTemperatures</span>(requestId, gId, replyTo) =&gt;</span><br><span class="line">        <span class="keyword">if</span> (gId == groupId) &#123;</span><br><span class="line">          context.spawnAnonymous(</span><br><span class="line">            <span class="type">DeviceGroupQuery</span>(deviceIdToActor, requestId = requestId, requester = replyTo, <span class="number">3.</span>seconds))</span><br><span class="line">          <span class="keyword">this</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          <span class="type">Behaviors</span>.unhandled</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onSignal</span></span>: <span class="type">PartialFunction</span>[<span class="type">Signal</span>, <span class="type">Behavior</span>[<span class="type">Command</span>]] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">PostStop</span> =&gt;</span><br><span class="line">      context.log.info(<span class="string">s&quot;DeviceGroup <span class="subst">$&#123;groupId&#125;</span> stopped&quot;</span>)</span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---- device group</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// device manager</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DeviceManager</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Behavior</span>[<span class="type">Command</span>] =</span><br><span class="line">    <span class="type">Behaviors</span>.setup(context =&gt; <span class="keyword">new</span> <span class="type">DeviceManager</span>(context))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Command</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestTrackDevice</span>(<span class="params">groupId: <span class="type">String</span>, deviceId: <span class="type">String</span>, replyTo: <span class="type">ActorRef</span>[<span class="type">DeviceRegistered</span>]</span>)</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="type">DeviceManager</span>.<span class="type">Command</span></span><br><span class="line">      <span class="keyword">with</span> <span class="type">DeviceGroup</span>.<span class="type">Command</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceRegistered</span>(<span class="params">device: <span class="type">ActorRef</span>[<span class="type">Device</span>.<span class="type">Command</span>]</span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDeviceList</span>(<span class="params">requestId: <span class="type">Long</span>, groupId: <span class="type">String</span>, replyTo: <span class="type">ActorRef</span>[<span class="type">ReplyDeviceList</span>]</span>)</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="type">DeviceManager</span>.<span class="type">Command</span></span><br><span class="line">      <span class="keyword">with</span> <span class="type">DeviceGroup</span>.<span class="type">Command</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplyDeviceList</span>(<span class="params">requestId: <span class="type">Long</span>, ids: <span class="type">Set</span>[<span class="type">String</span>]</span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceGroupTerminated</span>(<span class="params">groupId: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">DeviceManager</span>.<span class="title">Command</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestAllTemperatures</span>(<span class="params">requestId: <span class="type">Long</span>, groupId: <span class="type">String</span>, replyTo: <span class="type">ActorRef</span>[<span class="type">RespondAllTemperatures</span>]</span>)</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="type">DeviceGroupQuery</span>.<span class="type">Command</span></span><br><span class="line">      <span class="keyword">with</span> <span class="type">DeviceGroup</span>.<span class="type">Command</span></span><br><span class="line">      <span class="keyword">with</span> <span class="type">DeviceManager</span>.<span class="type">Command</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">RespondAllTemperatures</span>(<span class="params">requestId: <span class="type">Long</span>, temperatures: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">TemperatureReading</span>]</span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">TemperatureReading</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Temperature</span>(<span class="params">value: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">TemperatureReading</span></span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">TemperatureNotAvailable</span> <span class="keyword">extends</span> <span class="title">TemperatureReading</span></span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">DeviceNotAvailable</span> <span class="keyword">extends</span> <span class="title">TemperatureReading</span></span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">DeviceTimedOut</span> <span class="keyword">extends</span> <span class="title">TemperatureReading</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeviceManager</span>(<span class="params">context: <span class="type">ActorContext</span>[<span class="type">DeviceManager</span>.<span class="type">Command</span>]</span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">AbstractBehavior</span>[<span class="type">DeviceManager</span>.<span class="type">Command</span>] &#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">DeviceManager</span>._</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> groupIdToActor = <span class="type">Map</span>.empty[<span class="type">String</span>, <span class="type">ActorRef</span>[<span class="type">DeviceGroup</span>.<span class="type">Command</span>]]</span><br><span class="line"></span><br><span class="line">  context.log.info(<span class="string">&quot;DeviceManager started&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onMessage</span></span>(msg: <span class="type">Command</span>): <span class="type">Behavior</span>[<span class="type">Command</span>] =</span><br><span class="line">    msg <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> trackMsg @ <span class="type">RequestTrackDevice</span>(groupId, _, replyTo) =&gt;</span><br><span class="line">        groupIdToActor.get(groupId) <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Some</span>(ref) =&gt;</span><br><span class="line">            ref ! trackMsg</span><br><span class="line">          <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">            context.log.info(<span class="string">s&quot;Creating device group actor for <span class="subst">$&#123;groupId&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> groupActor = context.spawn(<span class="type">DeviceGroup</span>(groupId), <span class="string">&quot;group-&quot;</span> + groupId)</span><br><span class="line">            context.watchWith(groupActor, <span class="type">DeviceGroupTerminated</span>(groupId))</span><br><span class="line">            groupActor ! trackMsg</span><br><span class="line">            groupIdToActor += groupId -&gt; groupActor</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> req @ <span class="type">RequestDeviceList</span>(requestId, groupId, replyTo) =&gt;</span><br><span class="line">        groupIdToActor.get(groupId) <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Some</span>(ref) =&gt;</span><br><span class="line">            ref ! req</span><br><span class="line">          <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">            replyTo ! <span class="type">ReplyDeviceList</span>(requestId, <span class="type">Set</span>.empty)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">DeviceGroupTerminated</span>(groupId) =&gt;</span><br><span class="line">        context.log.info(<span class="string">s&quot;Device group actor for <span class="subst">$&#123;groupId&#125;</span> has been terminated&quot;</span>)</span><br><span class="line">        groupIdToActor -= groupId</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onSignal</span></span>: <span class="type">PartialFunction</span>[<span class="type">Signal</span>, <span class="type">Behavior</span>[<span class="type">Command</span>]] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">PostStop</span> =&gt;</span><br><span class="line">      context.log.info(<span class="string">&quot;DeviceManager stopped&quot;</span>)</span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --device manager</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// groupdevciequery</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DeviceGroupQuery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(</span><br><span class="line">             deviceIdToActor: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">ActorRef</span>[<span class="type">Device</span>.<span class="type">Command</span>]],</span><br><span class="line">             requestId: <span class="type">Long</span>,</span><br><span class="line">             requester: <span class="type">ActorRef</span>[<span class="type">DeviceManager</span>.<span class="type">RespondAllTemperatures</span>],</span><br><span class="line">             timeout: <span class="type">FiniteDuration</span>): <span class="type">Behavior</span>[<span class="type">Command</span>] = &#123;</span><br><span class="line">    <span class="type">Behaviors</span>.setup &#123; context =&gt;</span><br><span class="line">      <span class="type">Behaviors</span>.withTimers &#123; timers =&gt;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">DeviceGroupQuery</span>(deviceIdToActor, requestId, requester, timeout, context, timers)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Command</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">CollectionTimeout</span> <span class="keyword">extends</span> <span class="title">Command</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">WrappedRespondTemperature</span>(<span class="params">response: <span class="type">Device</span>.<span class="type">RespondTemperature</span></span>) <span class="keyword">extends</span> <span class="title">Command</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceTerminated</span>(<span class="params">deviceId: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Command</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeviceGroupQuery</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">                        deviceIdToActor: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">ActorRef</span>[<span class="type">Device</span>.<span class="type">Command</span>]],</span></span></span><br><span class="line"><span class="params"><span class="class">                        requestId: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                        requester: <span class="type">ActorRef</span>[<span class="type">DeviceManager</span>.<span class="type">RespondAllTemperatures</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">                        timeout: <span class="type">FiniteDuration</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                        context: <span class="type">ActorContext</span>[<span class="type">DeviceGroupQuery</span>.<span class="type">Command</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">                        timers: <span class="type">TimerScheduler</span>[<span class="type">DeviceGroupQuery</span>.<span class="type">Command</span>]</span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">AbstractBehavior</span>[<span class="type">DeviceGroupQuery</span>.<span class="type">Command</span>] &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> <span class="type">DeviceGroupQuery</span>._</span><br><span class="line">  <span class="keyword">import</span> <span class="type">DeviceManager</span>.<span class="type">DeviceNotAvailable</span></span><br><span class="line">  <span class="keyword">import</span> <span class="type">DeviceManager</span>.<span class="type">DeviceTimedOut</span></span><br><span class="line">  <span class="keyword">import</span> <span class="type">DeviceManager</span>.<span class="type">RespondAllTemperatures</span></span><br><span class="line">  <span class="keyword">import</span> <span class="type">DeviceManager</span>.<span class="type">Temperature</span></span><br><span class="line">  <span class="keyword">import</span> <span class="type">DeviceManager</span>.<span class="type">TemperatureNotAvailable</span></span><br><span class="line">  <span class="keyword">import</span> <span class="type">DeviceManager</span>.<span class="type">TemperatureReading</span></span><br><span class="line"></span><br><span class="line">  timers.startSingleTimer(<span class="type">CollectionTimeout</span>, <span class="type">CollectionTimeout</span>, timeout)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> respondTemperatureAdapter = context.messageAdapter(<span class="type">WrappedRespondTemperature</span>.apply)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> repliesSoFar = <span class="type">Map</span>.empty[<span class="type">String</span>, <span class="type">TemperatureReading</span>]</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> stillWaiting = deviceIdToActor.keySet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  deviceIdToActor.foreach &#123;</span><br><span class="line">    <span class="keyword">case</span> (deviceId, device) =&gt;</span><br><span class="line">      context.watchWith(device, <span class="type">DeviceTerminated</span>(deviceId))</span><br><span class="line">      device ! <span class="type">Device</span>.<span class="type">ReadTemperature</span>(<span class="number">0</span>, respondTemperatureAdapter)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onMessage</span></span>(msg: <span class="type">Command</span>): <span class="type">Behavior</span>[<span class="type">Command</span>] =</span><br><span class="line">    msg <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">WrappedRespondTemperature</span>(response) =&gt; onRespondTemperature(response)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">DeviceTerminated</span>(deviceId)          =&gt; onDeviceTerminated(deviceId)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">CollectionTimeout</span>                   =&gt; onCollectionTimout()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">onRespondTemperature</span></span>(response: <span class="type">Device</span>.<span class="type">RespondTemperature</span>): <span class="type">Behavior</span>[<span class="type">Command</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> reading = response.value <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(value) =&gt; <span class="type">Temperature</span>(value)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span>        =&gt; <span class="type">TemperatureNotAvailable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deviceId = response.deviceId</span><br><span class="line">    repliesSoFar += (deviceId -&gt; reading)</span><br><span class="line">    stillWaiting -= deviceId</span><br><span class="line"></span><br><span class="line">    respondWhenAllCollected()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">onDeviceTerminated</span></span>(deviceId: <span class="type">String</span>): <span class="type">Behavior</span>[<span class="type">Command</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (stillWaiting(deviceId)) &#123;</span><br><span class="line">      repliesSoFar += (deviceId -&gt; <span class="type">DeviceNotAvailable</span>)</span><br><span class="line">      stillWaiting -= deviceId</span><br><span class="line">    &#125;</span><br><span class="line">    respondWhenAllCollected()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">onCollectionTimout</span></span>(): <span class="type">Behavior</span>[<span class="type">Command</span>] = &#123;</span><br><span class="line">    repliesSoFar ++= stillWaiting.map(deviceId =&gt; deviceId -&gt; <span class="type">DeviceTimedOut</span>)</span><br><span class="line">    stillWaiting = <span class="type">Set</span>.empty</span><br><span class="line">    respondWhenAllCollected()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">respondWhenAllCollected</span></span>(): <span class="type">Behavior</span>[<span class="type">Command</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (stillWaiting.isEmpty) &#123;</span><br><span class="line">      requester ! <span class="type">RespondAllTemperatures</span>(requestId, repliesSoFar)</span><br><span class="line">      <span class="type">Behaviors</span>.stopped</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --groupdevicequery</span></span><br></pre></td></tr></table></figure></p><p>测试代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.testkit.typed.scaladsl.<span class="type">ScalaTestWithActorTestKit</span></span><br><span class="line"><span class="keyword">import</span> org.scalatest._</span><br><span class="line"><span class="keyword">import</span> scala.concurrent.duration.<span class="type">DurationInt</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeviceSpec</span> <span class="keyword">extends</span> <span class="title">ScalaTestWithActorTestKit</span> <span class="keyword">with</span> <span class="title">FlatSpecLike</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> <span class="type">Device</span>._</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;Device actor&quot;</span> should <span class="string">&quot;reply with empty reading if no temperature is known&quot;</span> in &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> recordProbe = createTestProbe[<span class="type">TemperatureRecorded</span>]()</span><br><span class="line">    <span class="keyword">val</span> readProbe = createTestProbe[<span class="type">RespondTemperature</span>]()</span><br><span class="line">    <span class="keyword">val</span> deviceActor = spawn(<span class="type">Device</span>(<span class="string">&quot;group&quot;</span>, <span class="string">&quot;device&quot;</span>))</span><br><span class="line"></span><br><span class="line">    deviceActor ! <span class="type">Device</span>.<span class="type">RecordTemperature</span>(requestId = <span class="number">1</span>, <span class="number">24.0</span>, recordProbe.ref)</span><br><span class="line">    recordProbe.expectMessage(<span class="type">Device</span>.<span class="type">TemperatureRecorded</span>(requestId = <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    deviceActor ! <span class="type">Device</span>.<span class="type">ReadTemperature</span>(requestId = <span class="number">2</span>, readProbe.ref)</span><br><span class="line">    <span class="keyword">val</span> response1 = readProbe.receiveMessage()</span><br><span class="line">    response1.requestId should ===(<span class="number">2</span>)</span><br><span class="line">    response1.value should ===(<span class="type">Some</span>(<span class="number">24.0</span>))</span><br><span class="line"></span><br><span class="line">    deviceActor ! <span class="type">Device</span>.<span class="type">RecordTemperature</span>(requestId = <span class="number">3</span>, <span class="number">55.0</span>, recordProbe.ref)</span><br><span class="line">    recordProbe.expectMessage(<span class="type">Device</span>.<span class="type">TemperatureRecorded</span>(requestId = <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    deviceActor ! <span class="type">Device</span>.<span class="type">ReadTemperature</span>(requestId = <span class="number">4</span>, readProbe.ref)</span><br><span class="line">    <span class="keyword">val</span> response2 = readProbe.receiveMessage()</span><br><span class="line">    response2.requestId should ===(<span class="number">4</span>)</span><br><span class="line">    response2.value should ===(<span class="type">Some</span>(<span class="number">55.0</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroupSpec</span> <span class="keyword">extends</span> <span class="title">ScalaTestWithActorTestKit</span> <span class="keyword">with</span> <span class="title">FlatSpecLike</span></span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">Device</span>._</span><br><span class="line">  <span class="keyword">import</span> <span class="type">DeviceGroup</span>._</span><br><span class="line">  <span class="keyword">import</span> <span class="type">DeviceManager</span>._</span><br><span class="line">  <span class="keyword">import</span> <span class="type">DeviceGroupQuery</span>._</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;group actor&quot;</span> should <span class="string">&quot;be able to register a device actor&quot;</span> in &#123;</span><br><span class="line">    <span class="keyword">val</span> probe = createTestProbe[<span class="type">DeviceRegistered</span>]()</span><br><span class="line">    <span class="keyword">val</span> groupActor = spawn(<span class="type">DeviceGroup</span>(<span class="string">&quot;group&quot;</span>))</span><br><span class="line"></span><br><span class="line">    groupActor ! <span class="type">RequestTrackDevice</span>(<span class="string">&quot;group&quot;</span>, <span class="string">&quot;device1&quot;</span>, probe.ref)</span><br><span class="line">    <span class="keyword">val</span> registered1 = probe.receiveMessage()</span><br><span class="line">    <span class="keyword">val</span> deviceActor1 = registered1.device</span><br><span class="line"></span><br><span class="line">    <span class="comment">// another deviceId</span></span><br><span class="line">    groupActor ! <span class="type">RequestTrackDevice</span>(<span class="string">&quot;group&quot;</span>, <span class="string">&quot;device2&quot;</span>, probe.ref)</span><br><span class="line">    <span class="keyword">val</span> registered2 = probe.receiveMessage()</span><br><span class="line">    <span class="keyword">val</span> deviceActor2 = registered2.device</span><br><span class="line">    deviceActor1 should !==(deviceActor2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the device actors are working</span></span><br><span class="line">    <span class="keyword">val</span> recordProbe = createTestProbe[<span class="type">TemperatureRecorded</span>]()</span><br><span class="line">    deviceActor1 ! <span class="type">RecordTemperature</span>(requestId = <span class="number">0</span>, <span class="number">1.0</span>, recordProbe.ref)</span><br><span class="line">    recordProbe.expectMessage(<span class="type">TemperatureRecorded</span>(requestId = <span class="number">0</span>))</span><br><span class="line">    deviceActor2 ! <span class="type">Device</span>.<span class="type">RecordTemperature</span>(requestId = <span class="number">1</span>, <span class="number">2.0</span>, recordProbe.ref)</span><br><span class="line">    recordProbe.expectMessage(<span class="type">Device</span>.<span class="type">TemperatureRecorded</span>(requestId = <span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;group actor&quot;</span> should <span class="string">&quot;ignore requests for wrong groupId&quot;</span> in &#123;</span><br><span class="line">    <span class="keyword">val</span> probe = createTestProbe[<span class="type">DeviceRegistered</span>]()</span><br><span class="line">    <span class="keyword">val</span> groupActor = spawn(<span class="type">DeviceGroup</span>(<span class="string">&quot;group&quot;</span>))</span><br><span class="line"></span><br><span class="line">    groupActor ! <span class="type">RequestTrackDevice</span>(<span class="string">&quot;wrongGroup&quot;</span>, <span class="string">&quot;device1&quot;</span>, probe.ref)</span><br><span class="line">    probe.expectNoMessage(<span class="number">500.</span>milliseconds)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;group actor&quot;</span> should <span class="string">&quot;return same actor for same deviceId&quot;</span> in &#123;</span><br><span class="line">    <span class="keyword">val</span> probe = createTestProbe[<span class="type">DeviceRegistered</span>]()</span><br><span class="line">    <span class="keyword">val</span> groupActor = spawn(<span class="type">DeviceGroup</span>(<span class="string">&quot;group&quot;</span>))</span><br><span class="line"></span><br><span class="line">    groupActor ! <span class="type">RequestTrackDevice</span>(<span class="string">&quot;group&quot;</span>, <span class="string">&quot;device1&quot;</span>, probe.ref)</span><br><span class="line">    <span class="keyword">val</span> registered1 = probe.receiveMessage()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// registering same again should be idempotent</span></span><br><span class="line">    groupActor ! <span class="type">RequestTrackDevice</span>(<span class="string">&quot;group&quot;</span>, <span class="string">&quot;device1&quot;</span>, probe.ref)</span><br><span class="line">    <span class="keyword">val</span> registered2 = probe.receiveMessage()</span><br><span class="line"></span><br><span class="line">    registered1.device should ===(registered2.device)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;group actor&quot;</span> should <span class="string">&quot;be able to list active devices&quot;</span> in &#123;</span><br><span class="line">    <span class="keyword">val</span> registeredProbe = createTestProbe[<span class="type">DeviceRegistered</span>]()</span><br><span class="line">    <span class="keyword">val</span> groupActor = spawn(<span class="type">DeviceGroup</span>(<span class="string">&quot;group&quot;</span>))</span><br><span class="line"></span><br><span class="line">    groupActor ! <span class="type">RequestTrackDevice</span>(<span class="string">&quot;group&quot;</span>, <span class="string">&quot;device1&quot;</span>, registeredProbe.ref)</span><br><span class="line">    registeredProbe.receiveMessage()</span><br><span class="line"></span><br><span class="line">    groupActor ! <span class="type">RequestTrackDevice</span>(<span class="string">&quot;group&quot;</span>, <span class="string">&quot;device2&quot;</span>, registeredProbe.ref)</span><br><span class="line">    registeredProbe.receiveMessage()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deviceListProbe = createTestProbe[<span class="type">ReplyDeviceList</span>]()</span><br><span class="line">    groupActor ! <span class="type">RequestDeviceList</span>(requestId = <span class="number">0</span>, groupId = <span class="string">&quot;group&quot;</span>, deviceListProbe.ref)</span><br><span class="line">    deviceListProbe.expectMessage(<span class="type">ReplyDeviceList</span>(requestId = <span class="number">0</span>, <span class="type">Set</span>(<span class="string">&quot;device1&quot;</span>, <span class="string">&quot;device2&quot;</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;group actor&quot;</span> should <span class="string">&quot;be able to list active devices after one shuts down&quot;</span> in &#123;</span><br><span class="line">    <span class="keyword">val</span> registeredProbe = createTestProbe[<span class="type">DeviceRegistered</span>]()</span><br><span class="line">    <span class="keyword">val</span> groupActor = spawn(<span class="type">DeviceGroup</span>(<span class="string">&quot;group&quot;</span>))</span><br><span class="line"></span><br><span class="line">    groupActor ! <span class="type">RequestTrackDevice</span>(<span class="string">&quot;group&quot;</span>, <span class="string">&quot;device1&quot;</span>, registeredProbe.ref)</span><br><span class="line">    <span class="keyword">val</span> registered1 = registeredProbe.receiveMessage()</span><br><span class="line">    <span class="keyword">val</span> toShutDown = registered1.device</span><br><span class="line"></span><br><span class="line">    groupActor ! <span class="type">RequestTrackDevice</span>(<span class="string">&quot;group&quot;</span>, <span class="string">&quot;device2&quot;</span>, registeredProbe.ref)</span><br><span class="line">    registeredProbe.receiveMessage()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deviceListProbe = createTestProbe[<span class="type">ReplyDeviceList</span>]()</span><br><span class="line">    groupActor ! <span class="type">RequestDeviceList</span>(requestId = <span class="number">0</span>, groupId = <span class="string">&quot;group&quot;</span>, deviceListProbe.ref)</span><br><span class="line">    deviceListProbe.expectMessage(<span class="type">ReplyDeviceList</span>(requestId = <span class="number">0</span>, <span class="type">Set</span>(<span class="string">&quot;device1&quot;</span>, <span class="string">&quot;device2&quot;</span>)))</span><br><span class="line"></span><br><span class="line">    toShutDown ! <span class="type">Passivate</span></span><br><span class="line">    registeredProbe.expectTerminated(toShutDown, registeredProbe.remainingOrDefault)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// using awaitAssert to retry because it might take longer for the groupActor</span></span><br><span class="line">    <span class="comment">// to see the Terminated, that order is undefined</span></span><br><span class="line">    registeredProbe.awaitAssert &#123;</span><br><span class="line">      groupActor ! <span class="type">RequestDeviceList</span>(requestId = <span class="number">1</span>, groupId = <span class="string">&quot;group&quot;</span>, deviceListProbe.ref)</span><br><span class="line">      deviceListProbe.expectMessage(<span class="type">ReplyDeviceList</span>(requestId = <span class="number">1</span>, <span class="type">Set</span>(<span class="string">&quot;device2&quot;</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;group query&quot;</span> should <span class="string">&quot;return temperature value for working devices&quot;</span> in &#123;</span><br><span class="line">    <span class="keyword">val</span> requester = createTestProbe[<span class="type">RespondAllTemperatures</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> device1 = createTestProbe[<span class="type">Device</span>.<span class="type">Command</span>]()</span><br><span class="line">    <span class="keyword">val</span> device2 = createTestProbe[<span class="type">Device</span>.<span class="type">Command</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deviceIdToActor = <span class="type">Map</span>(<span class="string">&quot;device1&quot;</span> -&gt; device1.ref, <span class="string">&quot;device2&quot;</span> -&gt; device2.ref)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> queryActor =</span><br><span class="line">      spawn(<span class="type">DeviceGroupQuery</span>(deviceIdToActor, requestId = <span class="number">1</span>, requester = requester.ref, timeout = <span class="number">3.</span>seconds))</span><br><span class="line"></span><br><span class="line">    device1.expectMessageType[<span class="type">Device</span>.<span class="type">ReadTemperature</span>]</span><br><span class="line">    device2.expectMessageType[<span class="type">Device</span>.<span class="type">ReadTemperature</span>]</span><br><span class="line"></span><br><span class="line">    queryActor ! <span class="type">WrappedRespondTemperature</span>(<span class="type">Device</span>.<span class="type">RespondTemperature</span>(requestId = <span class="number">0</span>, <span class="string">&quot;device1&quot;</span>, <span class="type">Some</span>(<span class="number">1.0</span>)))</span><br><span class="line">    queryActor ! <span class="type">WrappedRespondTemperature</span>(<span class="type">Device</span>.<span class="type">RespondTemperature</span>(requestId = <span class="number">0</span>, <span class="string">&quot;device2&quot;</span>, <span class="type">Some</span>(<span class="number">2.0</span>)))</span><br><span class="line"></span><br><span class="line">    requester.expectMessage(</span><br><span class="line">      <span class="type">RespondAllTemperatures</span>(</span><br><span class="line">        requestId = <span class="number">1</span>,</span><br><span class="line">        temperatures = <span class="type">Map</span>(<span class="string">&quot;device1&quot;</span> -&gt; <span class="type">Temperature</span>(<span class="number">1.0</span>), <span class="string">&quot;device2&quot;</span> -&gt; <span class="type">Temperature</span>(<span class="number">2.0</span>))))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;group query&quot;</span> should <span class="string">&quot;return TemperatureNotAvailable for devices with no readings&quot;</span> in &#123;</span><br><span class="line">    <span class="keyword">val</span> requester = createTestProbe[<span class="type">RespondAllTemperatures</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> device1 = createTestProbe[<span class="type">Device</span>.<span class="type">Command</span>]()</span><br><span class="line">    <span class="keyword">val</span> device2 = createTestProbe[<span class="type">Device</span>.<span class="type">Command</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deviceIdToActor = <span class="type">Map</span>(<span class="string">&quot;device1&quot;</span> -&gt; device1.ref, <span class="string">&quot;device2&quot;</span> -&gt; device2.ref)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> queryActor =</span><br><span class="line">      spawn(<span class="type">DeviceGroupQuery</span>(deviceIdToActor, requestId = <span class="number">1</span>, requester = requester.ref, timeout = <span class="number">3.</span>seconds))</span><br><span class="line"></span><br><span class="line">    device1.expectMessageType[<span class="type">Device</span>.<span class="type">ReadTemperature</span>]</span><br><span class="line">    device2.expectMessageType[<span class="type">Device</span>.<span class="type">ReadTemperature</span>]</span><br><span class="line"></span><br><span class="line">    queryActor ! <span class="type">WrappedRespondTemperature</span>(<span class="type">Device</span>.<span class="type">RespondTemperature</span>(requestId = <span class="number">0</span>, <span class="string">&quot;device1&quot;</span>, <span class="type">None</span>))</span><br><span class="line">    queryActor ! <span class="type">WrappedRespondTemperature</span>(<span class="type">Device</span>.<span class="type">RespondTemperature</span>(requestId = <span class="number">0</span>, <span class="string">&quot;device2&quot;</span>, <span class="type">Some</span>(<span class="number">2.0</span>)))</span><br><span class="line"></span><br><span class="line">    requester.expectMessage(</span><br><span class="line">      <span class="type">RespondAllTemperatures</span>(</span><br><span class="line">        requestId = <span class="number">1</span>,</span><br><span class="line">        temperatures = <span class="type">Map</span>(<span class="string">&quot;device1&quot;</span> -&gt; <span class="type">TemperatureNotAvailable</span>, <span class="string">&quot;device2&quot;</span> -&gt; <span class="type">Temperature</span>(<span class="number">2.0</span>))))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;group query&quot;</span> should <span class="string">&quot;return DeviceNotAvailable if device stops before answering&quot;</span> in &#123;</span><br><span class="line">    <span class="keyword">val</span> requester = createTestProbe[<span class="type">RespondAllTemperatures</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> device1 = createTestProbe[<span class="type">Device</span>.<span class="type">Command</span>]()</span><br><span class="line">    <span class="keyword">val</span> device2 = createTestProbe[<span class="type">Device</span>.<span class="type">Command</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deviceIdToActor = <span class="type">Map</span>(<span class="string">&quot;device1&quot;</span> -&gt; device1.ref, <span class="string">&quot;device2&quot;</span> -&gt; device2.ref)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> queryActor =</span><br><span class="line">      spawn(<span class="type">DeviceGroupQuery</span>(deviceIdToActor, requestId = <span class="number">1</span>, requester = requester.ref, timeout = <span class="number">3.</span>seconds))</span><br><span class="line"></span><br><span class="line">    device1.expectMessageType[<span class="type">Device</span>.<span class="type">ReadTemperature</span>]</span><br><span class="line">    device2.expectMessageType[<span class="type">Device</span>.<span class="type">ReadTemperature</span>]</span><br><span class="line"></span><br><span class="line">    queryActor ! <span class="type">WrappedRespondTemperature</span>(<span class="type">Device</span>.<span class="type">RespondTemperature</span>(requestId = <span class="number">0</span>, <span class="string">&quot;device1&quot;</span>, <span class="type">Some</span>(<span class="number">2.0</span>)))</span><br><span class="line"></span><br><span class="line">    device2.stop()</span><br><span class="line"></span><br><span class="line">    requester.expectMessage(</span><br><span class="line">      <span class="type">RespondAllTemperatures</span>(</span><br><span class="line">        requestId = <span class="number">1</span>,</span><br><span class="line">        temperatures = <span class="type">Map</span>(<span class="string">&quot;device1&quot;</span> -&gt; <span class="type">Temperature</span>(<span class="number">2.0</span>), <span class="string">&quot;device2&quot;</span> -&gt; <span class="type">DeviceNotAvailable</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;group query&quot;</span> should <span class="string">&quot;return temperature reading even if device stops after answering&quot;</span> in &#123;</span><br><span class="line">    <span class="keyword">val</span> requester = createTestProbe[<span class="type">RespondAllTemperatures</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> device1 = createTestProbe[<span class="type">Device</span>.<span class="type">Command</span>]()</span><br><span class="line">    <span class="keyword">val</span> device2 = createTestProbe[<span class="type">Device</span>.<span class="type">Command</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deviceIdToActor = <span class="type">Map</span>(<span class="string">&quot;device1&quot;</span> -&gt; device1.ref, <span class="string">&quot;device2&quot;</span> -&gt; device2.ref)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> queryActor =</span><br><span class="line">      spawn(<span class="type">DeviceGroupQuery</span>(deviceIdToActor, requestId = <span class="number">1</span>, requester = requester.ref, timeout = <span class="number">3.</span>seconds))</span><br><span class="line"></span><br><span class="line">    device1.expectMessageType[<span class="type">Device</span>.<span class="type">ReadTemperature</span>]</span><br><span class="line">    device2.expectMessageType[<span class="type">Device</span>.<span class="type">ReadTemperature</span>]</span><br><span class="line"></span><br><span class="line">    queryActor ! <span class="type">WrappedRespondTemperature</span>(<span class="type">Device</span>.<span class="type">RespondTemperature</span>(requestId = <span class="number">0</span>, <span class="string">&quot;device1&quot;</span>, <span class="type">Some</span>(<span class="number">1.0</span>)))</span><br><span class="line">    queryActor ! <span class="type">WrappedRespondTemperature</span>(<span class="type">Device</span>.<span class="type">RespondTemperature</span>(requestId = <span class="number">0</span>, <span class="string">&quot;device2&quot;</span>, <span class="type">Some</span>(<span class="number">2.0</span>)))</span><br><span class="line"></span><br><span class="line">    device2.stop()</span><br><span class="line"></span><br><span class="line">    requester.expectMessage(</span><br><span class="line">      <span class="type">RespondAllTemperatures</span>(</span><br><span class="line">        requestId = <span class="number">1</span>,</span><br><span class="line">        temperatures = <span class="type">Map</span>(<span class="string">&quot;device1&quot;</span> -&gt; <span class="type">Temperature</span>(<span class="number">1.0</span>), <span class="string">&quot;device2&quot;</span> -&gt; <span class="type">Temperature</span>(<span class="number">2.0</span>))))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;group query&quot;</span> should <span class="string">&quot;return DeviceTimedOut if device does not answer in time&quot;</span> in &#123;</span><br><span class="line">    <span class="keyword">val</span> requester = createTestProbe[<span class="type">RespondAllTemperatures</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> device1 = createTestProbe[<span class="type">Device</span>.<span class="type">Command</span>]()</span><br><span class="line">    <span class="keyword">val</span> device2 = createTestProbe[<span class="type">Device</span>.<span class="type">Command</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deviceIdToActor = <span class="type">Map</span>(<span class="string">&quot;device1&quot;</span> -&gt; device1.ref, <span class="string">&quot;device2&quot;</span> -&gt; device2.ref)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> queryActor =</span><br><span class="line">      spawn(<span class="type">DeviceGroupQuery</span>(deviceIdToActor, requestId = <span class="number">1</span>, requester = requester.ref, timeout = <span class="number">200.</span>millis))</span><br><span class="line"></span><br><span class="line">    device1.expectMessageType[<span class="type">Device</span>.<span class="type">ReadTemperature</span>]</span><br><span class="line">    device2.expectMessageType[<span class="type">Device</span>.<span class="type">ReadTemperature</span>]</span><br><span class="line"></span><br><span class="line">    queryActor ! <span class="type">WrappedRespondTemperature</span>(<span class="type">Device</span>.<span class="type">RespondTemperature</span>(requestId = <span class="number">0</span>, <span class="string">&quot;device1&quot;</span>, <span class="type">Some</span>(<span class="number">1.0</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no reply from device2</span></span><br><span class="line"></span><br><span class="line">    requester.expectMessage(</span><br><span class="line">      <span class="type">RespondAllTemperatures</span>(</span><br><span class="line">        requestId = <span class="number">1</span>,</span><br><span class="line">        temperatures = <span class="type">Map</span>(<span class="string">&quot;device1&quot;</span> -&gt; <span class="type">Temperature</span>(<span class="number">1.0</span>), <span class="string">&quot;device2&quot;</span> -&gt; <span class="type">DeviceTimedOut</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;group query&quot;</span> should <span class="string">&quot;be able to collect temperatures from all active devices&quot;</span> in &#123;</span><br><span class="line">    <span class="keyword">val</span> registeredProbe = createTestProbe[<span class="type">DeviceRegistered</span>]()</span><br><span class="line">    <span class="keyword">val</span> groupActor = spawn(<span class="type">DeviceGroup</span>(<span class="string">&quot;group&quot;</span>))</span><br><span class="line"></span><br><span class="line">    groupActor ! <span class="type">RequestTrackDevice</span>(<span class="string">&quot;group&quot;</span>, <span class="string">&quot;device1&quot;</span>, registeredProbe.ref)</span><br><span class="line">    <span class="keyword">val</span> deviceActor1 = registeredProbe.receiveMessage().device</span><br><span class="line"></span><br><span class="line">    groupActor ! <span class="type">RequestTrackDevice</span>(<span class="string">&quot;group&quot;</span>, <span class="string">&quot;device2&quot;</span>, registeredProbe.ref)</span><br><span class="line">    <span class="keyword">val</span> deviceActor2 = registeredProbe.receiveMessage().device</span><br><span class="line"></span><br><span class="line">    groupActor ! <span class="type">RequestTrackDevice</span>(<span class="string">&quot;group&quot;</span>, <span class="string">&quot;device3&quot;</span>, registeredProbe.ref)</span><br><span class="line">    registeredProbe.receiveMessage()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the device actors are working</span></span><br><span class="line">    <span class="keyword">val</span> recordProbe = createTestProbe[<span class="type">TemperatureRecorded</span>]()</span><br><span class="line">    deviceActor1 ! <span class="type">RecordTemperature</span>(requestId = <span class="number">0</span>, <span class="number">1.0</span>, recordProbe.ref)</span><br><span class="line">    recordProbe.expectMessage(<span class="type">TemperatureRecorded</span>(requestId = <span class="number">0</span>))</span><br><span class="line">    deviceActor2 ! <span class="type">RecordTemperature</span>(requestId = <span class="number">1</span>, <span class="number">2.0</span>, recordProbe.ref)</span><br><span class="line">    recordProbe.expectMessage(<span class="type">TemperatureRecorded</span>(requestId = <span class="number">1</span>))</span><br><span class="line">    <span class="comment">// No temperature for device3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> allTempProbe = createTestProbe[<span class="type">RespondAllTemperatures</span>]()</span><br><span class="line">    groupActor ! <span class="type">RequestAllTemperatures</span>(requestId = <span class="number">0</span>, groupId = <span class="string">&quot;group&quot;</span>, allTempProbe.ref)</span><br><span class="line">    allTempProbe.expectMessage(</span><br><span class="line">      <span class="type">RespondAllTemperatures</span>(</span><br><span class="line">        requestId = <span class="number">0</span>,</span><br><span class="line">        temperatures =</span><br><span class="line">          <span class="type">Map</span>(<span class="string">&quot;device1&quot;</span> -&gt; <span class="type">Temperature</span>(<span class="number">1.0</span>), <span class="string">&quot;device2&quot;</span> -&gt; <span class="type">Temperature</span>(<span class="number">2.0</span>), <span class="string">&quot;device3&quot;</span> -&gt; <span class="type">TemperatureNotAvailable</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结">小结</h2><ol type="1"><li>官方给的例子使用了很多reactive design patterms，一个典型的pattern是<strong>request-response pattern</strong> 比如下面这段代码</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDeviceList</span>(<span class="params">requestId: <span class="type">Long</span>, groupId: <span class="type">String</span>, replyTo: <span class="type">ActorRef</span>[<span class="type">ReplyDeviceList</span>]</span>)</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="type">DeviceManager</span>.<span class="type">Command</span></span><br><span class="line">      <span class="keyword">with</span> <span class="type">DeviceGroup</span>.<span class="type">Command</span></span><br><span class="line"></span><br><span class="line">...........</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="type">RequestDeviceList</span>(requestId, gId, replyTo) =&gt;</span><br><span class="line">        <span class="keyword">if</span> (gId == groupId) &#123;</span><br><span class="line">          replyTo ! <span class="type">ReplyDeviceList</span>(requestId, deviceIdToActor.keySet)</span><br><span class="line">          <span class="keyword">this</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          <span class="type">Behaviors</span>.unhandled</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>又比如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestAllTemperatures</span>(<span class="params">requestId: <span class="type">Long</span>, groupId: <span class="type">String</span>, replyTo: <span class="type">ActorRef</span>[<span class="type">RespondAllTemperatures</span>]</span>)</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="type">DeviceGroupQuery</span>.<span class="type">Command</span></span><br><span class="line">      <span class="keyword">with</span> <span class="type">DeviceGroup</span>.<span class="type">Command</span></span><br><span class="line">      <span class="keyword">with</span> <span class="type">DeviceManager</span>.<span class="type">Command</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">RequestAllTemperatures</span>(requestId, gId, replyTo) =&gt;</span><br><span class="line">        <span class="keyword">if</span> (gId == groupId) &#123;</span><br><span class="line">          context.spawnAnonymous(</span><br><span class="line">            <span class="type">DeviceGroupQuery</span>(deviceIdToActor, requestId = requestId, requester = replyTo, <span class="number">3.</span>seconds))</span><br><span class="line">          <span class="keyword">this</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          <span class="type">Behaviors</span>.unhandled</span><br></pre></td></tr></table></figure><p>总结为这样的形式 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">&lt;request&gt;</span> (<span class="params">...., replyTo:&lt;respond&gt;</span>)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><ol start="2" type="1"><li><p>并发编程模型除了actor模型，还有future promise，这也是Scala提供的并发框架</p></li><li><p>模式匹配使用频率非常多，需要牢固掌握</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从多臂赌博机谈起</title>
      <link href="/2021/06/21/%E4%BB%8E%E5%A4%9A%E8%87%82%E8%B5%8C%E5%8D%9A%E6%9C%BA%E8%B0%88%E8%B5%B7/"/>
      <url>/2021/06/21/%E4%BB%8E%E5%A4%9A%E8%87%82%E8%B5%8C%E5%8D%9A%E6%9C%BA%E8%B0%88%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[<p>一个赌徒，要去摇老虎机，走进赌场一看，一排老虎机，外表一模一样，但是每个老虎机吐钱的概率可不一样，他不知道每个老虎机吐钱的概率分布是什么，那么每次该选择哪个老虎机可以做到最大化收益呢？这就是多臂赌博机问题 <strong>(Multi-armed bandit problem, K- or N-armed bandit problem, MAB</strong></p><span id="more"></span><h2 id="解决mab问题常用算法">解决MAB问题常用算法</h2><ol type="1"><li>朴素选择算法(Naive selection algorithm):其思想是对于每个arm都进行k次实验，选择出平均收益最高的arm。在之后的所有arm选择中都选择这个最好的。</li><li>Epsilon-Greedy算法(<span class="math inline">\(\epsilon\)</span>-greedy algorithm): 每一轮在选择arm的时候按概率p选择Explore（探索），按概率1-p选择Exploit（历史经验）。对于Explore，随机的从所有arm中选择一个；对于Exploit，从所有arm中选择平均收益最大的那个。</li><li>Softmax算法: 改进版Epsilon-Greedy算法，同样是先选择是Explore（探索）还是Exploit（原有）。对于Exploit阶段，与Epsilon-Greedy算法一致。对于Explore，并不是随机选择arm，而是使用Softmax函数计算每一个arm被选中的概率, <span class="math inline">\(p(u_{i}) = \frac{e^{u_{i}}}{\sum_{j=0}^{k} e^{u_{j}}}\)</span>, <span class="math inline">\(u_i\)</span>表示第i个arm的平均收益，k是arm总数</li><li>UCB(Upper Confidence Bound)算法：通过实验观察，统计得到的arm平均收益，根据中心极限定理，实验的次数越多，统计概率越接近真实概率。换句话说当实验次数足够多时，平均收益就代表了真实收益。UCB算法使用每一个arm的统计平均收益来代替真实收益。根据arm的收益置信区间的上界，进行排序，选择置信区间上界最大的arm。随着尝试的次数越来越多，置信区间会不断缩窄，上界会逐渐逼近真实值。这个算法的好处是，将统计值的不确定因素，考虑进了算法决策中，并且不需要设定参数。</li></ol><ul><li>如果arm置信区间很宽（被选次数很少，还不确定），那么它会倾向于被多次选择，这个是算法冒风险的部分</li><li>如果arm置信区间很窄（被选次数很多，比较好确定其好坏了），那么均值大的倾向于被多次选择，这个是算法保守稳妥的部分。</li><li>UCB是一种乐观的算法，选择置信区间上界排序。如果是悲观保守的做法，是选择置信区间下界(LCB)排序。</li></ul><p><span class="math display">\[\begin{equation}\label{eq:ucb1}\begin{split}\mathop{\arg\max}_{i \in k} \ \ \hat{u}_i + \sqrt{\frac{2\ln(t)}{n_i}}\\\end{split}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\label{eq:ucb2}\begin{split}\mathop{\arg\max}_{i \in k} \ \ \hat{u}_i + \sqrt{\frac{(1+ \alpha)\ln(t/\tau(n_i))}{2\tau(n_i)}}\\\tau(n) = (1 + \alpha)^n \end{split}\end{equation}\]</span> 在公式<span class="math inline">\(\ref{eq:ucb1}\)</span>中，<span class="math inline">\(\hat{u}_i\)</span> 表示第i个arm的平均收益，<span class="math inline">\(t\)</span>是一共尝试arm的次数, <span class="math inline">\(n_i\)</span>是第i个arm尝试的次数。在公式<span class="math inline">\(\ref{eq:ucb2}\)</span>中，<span class="math inline">\(\tau{n_i}\)</span>引入<span class="math inline">\(\alpha\)</span>, 做为超参数控制探索部分的影响。</p><ol start="5" type="1"><li>Thompson sampling：该算法跟UCB类似，Thompson sampling算法根据arm的真实收益的概率分布来确定所选arm。假设每个臂是否产生收益，其背后有一个概率分布，产生收益的概率为p。不断地试验，去估计出一个置信度较高的概率p的概率分布就能近似解决这个问题了。 假设概率p的概率分布符合beta(wins, lose)分布，它有两个参数: wins, lose。每个臂都维护一个beta分布的参数。每次试验后，选中一个臂，摇一下，有收益则该臂的wins增加1，否则该臂的lose增加1。每次选择臂的方式是：用每个臂现有的beta分布产生一个随机数b，选择所有臂产生的随机数中最大的那个臂去摇。</li></ol><p>如下图所示，不同<span class="math inline">\(\epsilon\)</span>的收益 <img src="epsilon.png" /></p><p>以上介绍了5 种针对MAB问题的算法，下面针对这5种算法的优缺点做一个总结分析</p><table><colgroup><col style="width: 46%" /><col style="width: 26%" /><col style="width: 26%" /></colgroup><thead><tr class="header"><th>5种算法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td>朴素选择法</td><td>-</td><td>要求实验次数多，实际场景浪费流量</td></tr><tr class="even"><td>Epsilon-Greedy算法</td><td></td><td>只关心payoff 没有考虑每个arm的实验次数</td></tr><tr class="odd"><td>Softmax算法</td><td>-</td><td>-</td></tr><tr class="even"><td>UCB(Upper Confidence Bound)算法</td><td>关注payoff以及实验次数</td><td></td></tr><tr class="odd"><td>Thompson sampling</td><td>UCB算法部分使用概率分布（仅置信区间上界）来量化不确定性。而Thompson sampling基于贝叶斯思想，全部用概率分布来表达不确定性</td><td></td></tr></tbody></table><h2 id="linucb算法">LinUCB算法</h2><p>linUCB算法是在UCB的基础上考虑了更多的上下文信息，具体论文可以<a href="https://towardsdatascience.com/recommender-systems-using-linucb-a-contextual-multi-armed-bandit-approach-35a6f0eb6c4">参考</a>. LinUCB算法做了一个假设：一个Item被选择后推送给一个User，其回报和相关context成线性关系。于是预测过程就变成：用User和Item的特征预估回报及其置信区间，选择置信区间上界最大的Item推荐，然后依据实际回报来更新线性关系的参数。</p><p>首先，我们构建一个线性模型用来描述每个arm的回报<span class="math inline">\(P_a=\mathbf{\theta D_a}\)</span>, <span class="math inline">\(D_a\)</span>表示针对某个具体的arm的样本，<span class="math inline">\(b_a\)</span>表示对应的payoff，根据我之前文章的总结，一个线性模型可以套用公式 :=  - ( ( - )^T + )$，并且我们选择arm的依据应该是其期望回馈最大。这个期望的分布满足： <span class="math display">\[\begin{equation}\label{eq:payoffpdf}\begin{split}\mu &amp;= \mathbf{X}_{t, a}^T \hat{\mathbf{\theta}}_a \\\sigma &amp;= \sqrt{\mathbf{x}_{t, a}^T \mathbf{A}_a^{-1}\mathbf{x}_{t, a}}\end{split}\end{equation}\]</span></p><p>所以我们的目标公式如下 <span class="math display">\[\begin{equation}\label{eq:linucb}\begin{split}\mathbf{E}(r_{t, a}|\mathbf{x}_{t, a}) &amp;= \mathbf{X}_{t, a}^T \hat{\mathbf{\theta}_a} \\a_t &amp;\overset{def}{=} \mathop{\arg\max}_{a \in A_a} \ \ \mathbf{X}_{t, a}^T \hat{\mathbf{\theta}}_a + \alpha\sqrt{\mathbf{x}_{t, a}^T \mathbf{A}_a^{-1}\mathbf{x}_{t, a}} \\\mathbf{A}_a &amp; = \mathbf{D}_a \mathbf{D}_a^T + \mathbf{I}_d \end{split}\end{equation}\]</span></p><p>其中 <span class="math inline">\(\alpha\)</span>越大，CI(confidence interval)越宽</p><h2 id="线性模型扩展为双线性模型">线性模型扩展为双线性模型</h2><p>如果我们把<span class="math inline">\(\mathbf{X\theta}\)</span> 写成这样的形式 <span class="math inline">\(a^T\mathbf{\omega}b\)</span>, 那么我们就得到一个双线性模型, 双线性模型和线性模型的联系区别可以从下面的公式看出 <span class="math display">\[\begin{equation}\begin{split}&amp; \begin{pmatrix}a_0 &amp; a_1 &amp; a_2 &amp;\end{pmatrix} \begin{pmatrix} w_0 &amp; w_1 \\ w_2 &amp; w_3 \\ w_4 &amp; w_5 \end{pmatrix} \begin{pmatrix} b_0 \\ b_1 \end{pmatrix} \\&amp; \begin{pmatrix} a_0w_0+a_1w_2 + a_2w_4, a_0w_1+a_1w_3+a_2w_5 \end{pmatrix} \begin{pmatrix} b_0 \\ b_1 \end{pmatrix} \\&amp; \begin{pmatrix} a_0b_0w_0 + a_1b_0w_2 + a_2b_0w_4 + a_0b_1w_1 + a_1b_1w_3 + a_2b_1w_5 \end{pmatrix}\end{split}\end{equation}\]</span></p><p>向量<span class="math inline">\(a\)</span>,<span class="math inline">\(b\)</span>与<span class="math inline">\(w\)</span>的对应关系如下 <span class="math display">\[\begin{matrix}\begin{array}{c|c}a_0b_0 &amp; w_0 \\a_0b_1 &amp; w_1 \\a_1b_0 &amp; w_2 \\a_1b_1 &amp; w_3 \\a_2b_0 &amp; w_4 \\a_2b_1 &amp; w_5 \\\end{array}\end{matrix}\]</span></p><p>我们将<span class="math inline">\(ab\)</span>进行整理 <span class="math display">\[\begin{matrix}a_0\begin{pmatrix} b_0 \\ b_1 \end{pmatrix} \\a_1\begin{pmatrix} b_0 \\ b_1 \end{pmatrix} \\a_2\begin{pmatrix} b_0 \\ b_1 \end{pmatrix} \\\end{matrix}\]</span></p><p>实际等价为<span class="math inline">\(a\)</span><span class="math inline">\(b^t\)</span>向量外积 <span class="math display">\[\begin{equation}\begin{pmatrix}a_0 \\ a_1 \\ a_2\end{pmatrix} \otimes \begin{pmatrix} b_0 &amp; b_1 \end{pmatrix} = \begin{pmatrix}a_0b_0 &amp; a_0b_1 \\a_1b_0 &amp; a_1b_1 \\a_2b_0&amp; a_2b_1 \\\end{pmatrix}\end{equation}\]</span></p><h2 id="基于linucb在推荐系统冷启动的工程实践">基于linUCB在推荐系统冷启动的工程实践</h2><p>LinUCB算法有一个很重要的步骤，就是给User和Item构建特征，也就是刻画context。在原始论文里，Item是文章，其中专门介绍了它们怎么构建特征的。</p><p>原始用户特征：</p><ul><li>人口统计学：性别特征（2 类），年龄特征（离散成 10 个区间）</li><li>地域信息：遍布全球的大都市，美国各个州</li><li>行为类别：代表用户历史行为的 1000 个类别取值</li></ul><p>原始文章特征</p><ul><li>URL 类别：根据文章来源分成了几十个类别</li><li>编辑打标签：编辑人工给内容从几十个话题标签中挑选出来的</li><li>原始特征向量都要归一化成单位向量。 还要对原始特征降维，以及模型要能刻画一些非线性的关系。 用 Logistic Regression 去拟合用户对文章的点击历史，其中的线性回归部分为:</li></ul><p><span class="math display">\[\phi_u^TW\phi_a\]</span> (眼熟吧 就是一个Bilinear-Model 套上LR训练得到W)</p><p>然后基于W将<span class="math inline">\(\phi_u\)</span>进行投影： <span class="math display">\[\psi_u\stackrel{def}{=}\phi_u^\mathrm{T}W\]</span></p><p>然后，用投射后的多维特征对用户聚类，得到 5 个类簇，文章页同样聚类成5 个簇，再加上常数 1，用户和文章各自被表示成 6 维向量(这里应该是到簇中心的概率值)，那么这个6维向量也就是 arm的向量。</p><p>看完上述的推导过程，在工程实践中需要仔细考虑如下问题</p><ol type="1"><li><p>payoff如何结合业务场景进行定义?</p></li><li><p>如何构建特征？</p></li><li><p>如何针对每个arm进行训练？</p></li><li><p>如何线上inference?</p></li></ol><p>我们一个个来&gt;_&lt;</p><ol type="1"><li>payoff的定义可以简化成: 曝光未点击0分，曝光点击1分(当然可以制定更加复杂的业务打分规则)</li><li><span class="math inline">\(a\)</span>向量是user侧向量，可以结合实际业务要求选择维度，<span class="math inline">\(b\)</span>向量是item侧向量，基于LR-Bilinear 模型，将user侧进行映射，聚类后得到最终降维向量(即是论文中的<span class="math inline">\(x_{t, a}\)</span>)</li><li>通过离线方式训练，每个arm包含 <span class="math inline">\(D_a\)</span>, <span class="math inline">\(A_a\)</span>, <span class="math inline">\(b_a\)</span>, 并保存最终的训练结果<span class="math inline">\(\theta\)</span></li><li>为了在inference时加快，需要针对每个arm缓存一些相关数据 <span class="math inline">\(A_a\)</span>, <span class="math inline">\(A_a^{-1}\)</span></li><li>online 更新, 假设某个arm有了新样本<span class="math inline">\(\mathbf{x} = a^TW\)</span> 和新的payoff <span class="math inline">\(b\)</span></li></ol><p><span class="math display">\[\begin{equation}\label{eq:online}\begin{split}\mathbf{A}_a &amp; = \mathbf{A}^{\prime}_a + \mathbf{X}\mathbf{X}^T \\\mathbf{D}_a &amp; = \mathbf{D}^{\prime}_a :+ \mathbf{X} \\\mathbf{b}_a &amp; = \mathbf{b}_a^{\prime} :+ b \\\end{split}\end{equation}\]</span></p><h2 id="小结">小结</h2><ol type="1"><li>列举了MAB问题的5种解法</li><li>linUCB原理以及工程实现上需要注意的问题</li></ol><p>参考:</p><ol type="1"><li><p><a href="http://www.199it.com/archives/746422.html" class="uri">http://www.199it.com/archives/746422.html</a></p></li><li><p><a href="https://cosx.org/2017/05/bandit-and-recommender-systems/" class="uri">https://cosx.org/2017/05/bandit-and-recommender-systems/</a></p></li><li><p><a href="https://arxiv.org/pdf/1003.0146.pdf" class="uri">https://arxiv.org/pdf/1003.0146.pdf</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-IO密集任务/计算密集任务/多线程/多进程</title>
      <link href="/2021/05/21/python-IO%E5%AF%86%E9%9B%86%E4%BB%BB%E5%8A%A1-%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E4%BB%BB%E5%8A%A1-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
      <url>/2021/05/21/python-IO%E5%AF%86%E9%9B%86%E4%BB%BB%E5%8A%A1-%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E4%BB%BB%E5%8A%A1-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Python 作为编程语言存在多个具体实现，包括最常用的 CPython、超集 Cython、.NET 平台的 IronPython、JVM 上的 Jython，R 语言实现的 RPython、JIT 版本的 PyPy 等等。这里我们只讨论最常用的、官方的 CPython 实现。</p><span id="more"></span><p>GIL是CPython解释器引入的锁，GIL在解释器层面阻止了真正的并行运行。解释器在执行任何线程之前，必须等待当前正在运行的线程释放GIL。事实上，解释器会强迫想要运行的线程必须拿到GIL才能访问解释器的任何资源，例如栈或Python对象等。这也正是GIL的目的——阻止不同的线程并发访问Python对象。这样GIL可以保护解释器的内存，让垃圾回收工作正常。但事实上，这却造成了程序员无法通过并行执行多线程来提高程序的性能。如果我们去掉CPython的GIL，就可以让多线程真正并行执行。GIL并没有影响多处理器并行的线程，只是限制了一个解释器只能有一个线程在运行</p><ul><li><p>引入GLC的好处:</p><blockquote><ul><li>单线程情况下更快。</li><li>瓶颈在于 I/O 的多线程环境下更快。</li><li>CPU 耗时操作发生在 C 库调用上时更快。</li><li>编写 C 扩展会更容易：除法你手动指定，否则不会发生 Python 线程切换的问题。</li><li>封装 C 库变得更容易，因为不需要考虑线程安全问题。如果该库不是线程安全的，你只需要保证调用时 GIL 是锁定的。</li></ul></blockquote></li></ul><h2 id="线程-vs-进程">线程 VS 进程:</h2><blockquote><ul><li>进程是应用程序的一个执行实例，比如，在桌面上双击浏览器图标将会运行一个浏览器。</li><li>线程是一个控制流程，可以在进程内与其他活跃的线程同时执行。“控制流程”指的是顺序执行一些机器指令。</li><li>进程可以包含多个线程，所以开启一个浏览器，操作系统将创建一个进程，并开始执行这个进程的主线程。每一个线程将独立执行一系列的指令（通常就是一个函数），并且和其他线程并行执行。</li><li>同一个进程内的线程可以共享一些地址空间和数据结构，所以线程也被称作“轻量进程”</li></ul></blockquote><ul><li><strong>IO密集型任务 VS 计算密集型任务</strong> &gt; - 所谓IO密集型任务，是指磁盘IO、网络IO占主要的任务，计算量很小。典型的如请求网页、读写文件 &gt; - 所谓计算密集型任务，是指CPU计算占主要的任务，CPU一直处于满负荷状态。比如在一个很大的列表中查找元素</li></ul><p>对于IO密集型任务我们采用多线程，对于计算密集型任务，我们多采用多进程进行并行计算加速</p><h2 id="函数调用">函数调用</h2><h3 id="什么是栈帧stack-frame"><strong>什么是栈帧(stack frame)</strong></h3><p>栈帧是存储函数调用活动的实体，每一次函数的调用,都会在调用栈(call stack)上维护一个独立的栈帧(stack frame).每个独立的栈帧一般包括：</p><ol type="1"><li>函数的返回地址和参数</li><li>临时变量: 包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li><li>函数调用的上下文栈是从高地址向低地址延伸,一个函数的栈帧用ebp 和 esp 这两个寄存器来划定范围.ebp 指向当前栈帧的底部,esp 始终指向栈帧的顶部;ebp 寄存器又被称为帧指针(Frame Pointer);esp 寄存器又被称为栈指针(Stack Pointer)</li></ol><h3 id="函数调用过程"><strong>函数调用过程</strong></h3><p>在函数调用的过程中,有函数的调用者(caller)和被调用的函数(callee). 调用者需要知道被调用者函数返回值; 被调用者需要道传入的参数和返回的地址，函数调用分为以下几步:</p><ol type="1"><li>参数入栈: 将参数按照调用约定(C 是从右向左)依次压入系统栈中;</li><li>返回地址入栈: 将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行;</li><li>代码跳转: 处理器将代码区跳转到被调用函数的入口处;</li><li><p>栈帧调整:</p><ol type="1"><li>将调用者的ebp压栈处理，保存指向栈底的ebp的地址（方便函数返回之后的现场恢复），此时esp指向新的栈顶位置<font color=red>push ebp</font></li><li>将当前栈帧切换到新栈帧(将eps值装入ebp，更新栈帧底部), 这时ebp指向栈顶，而此时栈顶就是old ebp <font color=red>mov ebp, esp</font></li><li>给新栈帧分配空间 <font color=red>sub esp, XXX</font></li></ol></li></ol><h3 id="函数返回"><strong>函数返回</strong></h3><p>函数返回分为以下几步:</p><ol type="1"><li>保存被调用函数的返回值到 eax 寄存器中 <font color=red>mov eax, xxx</font></li><li>恢复 esp 同时回收局部变量空间<font color=red> mov ebp, esp</font></li><li>将上一个栈帧底部位置恢复到 <font color=red>ebp pop ebp</font></li><li>弹出当前栈顶元素,从栈中取到返回地址,并跳转到该位置 <font color=red>ret</font></li></ol><p>函数里面要用到数据,如果数据属于性线程级别的(比如函数形参--&gt;局部变量--&gt;存在栈上--&gt;每个线程都有自己的栈)，那么多线程同时调用是没关系的，因为用的都是本线程的数据；但是如果函数用到一些全局数据，比如全局变量，根据堆内存首地址去访问的堆内存(形参传入的)，同时操作一个数据结构(如对一个链表的操作)，静态局部变量，那就存在数据安全问题，必须要加锁对函数访问加锁。</p><p>因此需要互斥处理的，一般是函数中有全局变量，有动态申请的空间，有静态局部变量，有需要进程数据循环发送之类的操作需要进行互斥处理。</p><h3 id="线程安全函数和可重入函数"><strong>线程安全函数和可重入函数</strong></h3><p>线程安全的(Thread-Safe)：如果一个函数在同一时刻可以被多个线程安全地调用，就称该函数是线程安全的。线程安全函数解决多个线程调用函数时访问共享资 源的冲突问题。 可重入(Reentrant)：函数可以由多于一个线程并发使用，而不必担心数据错误。可重入函数可以在任意时刻被中断，稍后再继续运行，不会丢失数据。可重入   性解决函数运行结果的确定性和可重复性。可重入函数编写规范为：</p><blockquote><ul><li>不在函数内部使用静态或全局数据 </li><li>不返回静态或全局数据，所有数据都由函数的调用者提供。 </li><li>使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据。</li><li>如果必须访问全局变量，利用互斥机制来保护全局变量。</li><li>不调用不可重入函数。</li></ul></blockquote><p>两者之间的关系：</p><blockquote><ul><li>一个函数对于多个线程是可重入的，则这个函数是线程安全的。</li><li>一个函数是线程安全的，但并不一定是可重入的。</li><li>可重入性要强于线程安全性。</li></ul></blockquote><h2 id="python的函数传参">python的函数传参</h2><p>在讨论python的函数是如何传参之前，我们先讨论一下c/c++的函数传参方式, 对于c语言来说只有一种 call-by-value, 简单说就是实参会如实拷贝至形参，而c++会多了几种，下面请看:</p><h3 id="cc函数传参"><strong>c/c++函数传参</strong></h3><ol type="1"><li>按值传参 按值传参的概念非常好理解，就是函数接收到了传递过来的参数后，将其拷贝一份，其函数内部执行的代码操作的都是传递参数的拷贝。也就是说，按值传参最大的特点就是不会影响到传递过来的参数的值，但因为拷贝了一份副本，会更浪费资源一些。</li><li>按（左值）引用传参 简单来说形参是实参的别名</li><li>按常量引用传参，比如下面的例子 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">randomItem</span><span class="params">( <span class="type">const</span> vector&lt;string&gt; &amp; arr )</span></span>;</span><br></pre></td></tr></table></figure></li><li>按右值引用传参 C++11 全面引入移动语义： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y</span><br><span class="line">can be a copy if y is an lvalue,</span><br><span class="line">but a move if y is an rvalue.</span><br></pre></td></tr></table></figure> 调用拷贝构造函数主要有以下场景：</li></ol><ul><li>对象作为函数的参数，以值传递的方式传给函数。　</li><li>对象作为函数的返回值，以值的方式从函数返回</li><li>使用一个对象给另一个对象初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">m_ptr</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; endl;&#125; </span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a):<span class="built_in">m_ptr</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.m_ptr))&#123; cout &lt;&lt; <span class="string">&quot;copy construct&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; a) :<span class="built_in">m_ptr</span>(a.m_ptr) &#123;</span><br><span class="line">        a.m_ptr = <span class="literal">nullptr</span>; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123; <span class="keyword">delete</span> m_ptr;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span>* m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">GetA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a = <span class="built_in">GetA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">construct</span><br><span class="line">move construct</span><br><span class="line">move construct</span><br></pre></td></tr></table></figure></p><p>使用 <font color=gray> -fno-elide-constructors </font> 选项编译上述代码，可以关闭编译器的ROV优化,输出结果表明，并没有调用拷贝构造函数，只调用了move construct函数。</p><p>这就是移动语义，需要注意的一个细节是，我们提供移动构造函数的同时也会提供一个拷贝构造函数，以防止移动不成功的时候还能拷贝构造。更详细的内容参考这篇文章 - <a href="https://www.cnblogs.com/qicosmos/p/4283455.html">从4行代码看右值引用</a></p><h3 id="python的name-binding"><strong>python的name binding</strong></h3><p>python中一切皆对象, <font color=gray> a = 1 </font> 这条语句就是把名字<font color=red>a</font>绑定在<font color=red>1</font>这个对象上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">b</span>):</span><br><span class="line">    <span class="built_in">print</span>(b <span class="keyword">is</span> a)</span><br><span class="line">    b.append(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(b <span class="keyword">is</span> a)</span><br><span class="line">foo(a)    <span class="comment"># 会打印出 True  True </span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment">#  [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">c</span>):</span><br><span class="line">    <span class="built_in">print</span>(c <span class="keyword">is</span> a)</span><br><span class="line">    c = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(c <span class="keyword">is</span> a)</span><br><span class="line">bar(a)    <span class="comment"># 会打印出 True  False</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># [1,2,3,4]</span></span><br></pre></td></tr></table></figure><ul><li>刚开始执行foo(a)的时候，名字b与a绑定的的是同一个list，所以 b is a 返回True，然后执行b.append(4), 实际是对它俩绑定的那个list对象进行操作,执行完以后，它俩仍然绑定这个list对象，所以还是返回True。那么在foo函数执行完以后，通过a去引用这个list对象，它的内容就是1,2,3,4.</li><li>再看bar(a)的执行情况，刚开始名字c 和 a 都是绑定这个list对象，所以 c is a返回True. 然后执行c = [0,0,0],表明名字c 绑定到了另外一个list对象上了，而名字a 仍然绑定着原来的那个list对象。所以 c is a 返回False，bar函数执行完以后，通过名字a引用到的那个list的内容还是包含1,2,3,4.</li></ul><p>我们把python中的这种引用方式称作<strong>句柄引用</strong>, 和c++中的<strong>别名引用</strong>有一定区别</p><h2 id="python的multiprocessing">python的multiprocessing</h2><p>multiprocessing模块提供了Process能让我们通过创建进程对象并执行该进程对象的start方法来创建一个真正的进程来执行任务，该接口类似threading模块中的线程类Thread.</p><p>但是当被操作对象数目不大的时候可以使用Process动态生成多个进程，但是如果需要的进程数一旦很多的时候，手动限制进程的数量以及处理不同进程返回值会变得异常的繁琐，multiprocessing模块提供了一个进程池Pool类，负责创建进程池对象，并提供了一些方法来讲运算任务offload到不同的子进程中执行，并很方便的获取返回值。multiprocessing.pool提供以下多种方式可以用来将任务分给到各个子进程：</p><table><thead><tr class="header"><th></th><th>Multi-args</th><th>Concurrence</th><th>Blocking</th><th>Ordered-results</th></tr></thead><tbody><tr class="odd"><td>Pool.apply</td><td>No</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr class="even"><td>Pool.apply_async</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr><tr class="odd"><td>Pool.map</td><td>No</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr class="even"><td>Pool.map_async</td><td>No</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr class="odd"><td>Pool.starmap</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr class="even"><td>Pool.stamap_async</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td></tr></tbody></table><p>注意:</p><blockquote><ul><li>Pool.imap and Pool.imap_async – lazier version of map and map_async.</li><li>Pool.starmap 和Pool.map 相比可以接受多参数函数</li><li>Async methods submit all the processes at once and retrieve the results once they are finished. Use get method to obtain the results.</li><li>Pool.map(or Pool.apply)methods are very much similar to Python built-in map(or apply). They block the main process until all the processes complete and return the result.</li><li>需要说明的是，最后一列Ordered-results表示各个方法返回的结果是否是有序的, 不是表示各个函数的返回值是否是按照调用的顺序返回的</li></ul></blockquote><h3 id="chunksize影响优化效率">chunksize影响优化效率</h3><p>现在有一个需要加速的计算任务, xl是一个list of set, 我们要判断yl列表中的每一个元素是否存在set内, 两层for循环嵌套计算，具体代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    xl = [<span class="built_in">set</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">str</span>(x), np.random.randint(<span class="number">400</span>, size=<span class="number">100</span>))) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">80000</span>)]</span><br><span class="line">    yl = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">str</span>(x), np.random.randint(<span class="number">400</span>, size=<span class="number">400</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#单进程执行</span></span><br><span class="line">    local_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start pf time &quot;</span>, local_time)</span><br><span class="line">    res = [ iy <span class="keyword">in</span> ix <span class="keyword">for</span> iy <span class="keyword">in</span> yl <span class="keyword">for</span> ix <span class="keyword">in</span> xl]</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;pf during time &quot;</span>, end_time - local_time)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(res), res[<span class="number">0</span>:<span class="number">8</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multiprocessing.cpu_count() 4</span><br><span class="line">start pf time  1585446005.5070348</span><br><span class="line">pf during time  6.3575873374938965</span><br><span class="line">32000000 [False, False, False, False, False, False, True, False]</span><br></pre></td></tr></table></figure> 我们使用<font color=grey>pool.starmap</font>进行并行加速</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_task</span>(<span class="params">x, yl</span>): <span class="keyword">return</span> [y <span class="keyword">in</span> x <span class="keyword">for</span> y <span class="keyword">in</span> yl]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;multiprocessing.cpu_count()&quot;</span>, multiprocessing.cpu_count())</span><br><span class="line">    pool = multiprocessing.Pool(processes=multiprocessing.cpu_count())</span><br><span class="line">    xl = [<span class="built_in">set</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">str</span>(x), np.random.randint(<span class="number">400</span>, size=<span class="number">100</span>))) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">80000</span>)]</span><br><span class="line">    yl = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">str</span>(x), np.random.randint(<span class="number">400</span>, size=<span class="number">400</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#使用starmap</span></span><br><span class="line">    task = [(ix, yl) <span class="keyword">for</span> ix <span class="keyword">in</span> xl]</span><br><span class="line">    local_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start pf time &quot;</span>, local_time)</span><br><span class="line">    results = pool.starmap(func_task, task)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;pf during time &quot;</span>, end_time - local_time)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(results), results[<span class="number">0</span>][<span class="number">0</span>:<span class="number">8</span>])</span><br></pre></td></tr></table></figure><p>输出： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multiprocessing.cpu_count() 4</span><br><span class="line">start pf time  1585446134.5832891</span><br><span class="line">pf during time  7.450953006744385</span><br><span class="line">80000 [False, False, False, False, False, False, False, False]</span><br></pre></td></tr></table></figure> 居然变慢了，这是怎么回事? 带着这样的疑问查阅了相关资料 <a href="https://stackoverflow.com/questions/53751050/python-multiprocessing-understanding-logic-behind-chunksize">python-multiprocessing-understanding-logic-behind-chunksize</a></p><p>我的理解是合适的chunksize与具体的问题规模以及计算量相关, 不存在普适的公式，原文说：</p><blockquote><p>More chunks mean more overhead, but increased scheduling flexibility. How this answer will show, this leads to a higher worker-utilization on average, but without the guarantee of a shorter overall computation time for every case.</p></blockquote><p>更过的chunks意味着更多的资源消耗，但是会提升scheduling flexibility，这再一定程度提升了平均cpu使用, 但是不能确保整体time消耗降低</p><p>据此我尝试了chunksize分别是10，100，1000，10000的情况，结果如下:</p><table><thead><tr class="header"><th>chunksize</th><th>time consumption (seconds)</th></tr></thead><tbody><tr class="odd"><td>10</td><td>5.82</td></tr><tr class="even"><td>100</td><td>6.18</td></tr><tr class="odd"><td>1000</td><td>5.61</td></tr><tr class="even"><td>10000</td><td>9.42</td></tr></tbody></table><p>在chunksize=256时取得了4.8S的时间消耗</p><h2 id="小结">小结</h2><ul><li>函数中有全局变量，动态申请的空间，静态局部变量在同进程下的多线程需要考虑互斥</li><li>IO密集任务使用多线程 计算密集任务使用多进程</li><li>python多进程并行计算使用时需要尝试调整chunksize来优化时间消耗</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据-DataFlow编程模型</title>
      <link href="/2020/07/21/%E5%A4%A7%E6%95%B0%E6%8D%AE-DataFlow%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/07/21/%E5%A4%A7%E6%95%B0%E6%8D%AE-DataFlow%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习--线性回归/正规方程解法/梯度下降法</title>
      <link href="/2020/05/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B%E8%A7%A3%E6%B3%95-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/"/>
      <url>/2020/05/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B%E8%A7%A3%E6%B3%95-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>线性回归可以说是最基础的机器学习模型，本文将对此模型做一个分析，并介绍常见的线性回归模型的训练方法。以及由此衍生出的逻辑回归(LR)，多分类。 <span id="more"></span></p><h2 id="线性回归模型">线性回归模型</h2><p>首先提出一个小问题，如果在一个平面上给出一些点，现在让找到一条直线来拟合这些点，请问该如何寻找这条直线？最小二乘法给了我们答案。如果所有的点到这条直线的距离最小，那么我们就算是找到了这条直线了。注意我这里说的距离不是欧式几何严格意义上的点到直线距离。我们以一元线性回归为例，我们要求解的函数形式为<span class="math inline">\(h_{\theta}(x) = \theta_0 + \theta_1 x_1\)</span>，其损失函数为 <span class="math inline">\(\mathbf{J}(\theta) = \frac{1}{2m}\sum_{i=1}^{m}(h_{\theta}(x_i) - y_i)^2\)</span></p><p><span class="math display">\[\begin{equation}\label{lossfunc}\mathbf{J}(\theta) = \frac{1}{2m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)}) - y^{(i)})^2\end{equation}\]</span></p><h3 id="正规方程法">正规方程法</h3><p>在讲梯度下降法之前，我们先把上述的<span class="math inline">\(\ref{lossfunc}\)</span>写成矩阵的形式, 假设所求方程的矩阵形式为<span class="math inline">\(f(\mathbf{\theta}) = \mathbf{X}\mathbf{\theta}\)</span>，那么其损失函数如下:</p><p><span class="math display">\[\begin{equation}\label{lossfuncmatrix}J(\mathbf{\theta}) = \frac{1}{2m}(\mathbf{X}\mathbf{\theta} - \mathbf{y})^T(\mathbf{X}\mathbf{\theta} - \mathbf{y})\end{equation}\]</span></p><p>针对<span class="math inline">\(\mathbf{\theta}\)</span>求导，可以参考<a href="https://blog.csdn.net/daaikuaichuan/article/details/80620518">矩阵求导法则</a>，主要用到的性质是 <span class="math inline">\(\frac{\partial \mathbf{X}^T \mathbf{A}}{\partial \mathbf{X}} = \mathbf{A}\)</span>：</p><p><span class="math display">\[\begin{equation}\label{partialLoss}\begin{split}\frac{\partial J(\mathbf{\theta})}{\partial \mathbf{\theta}} &amp;= \frac{\partial(\mathbf{X}\mathbf{\theta} - \mathbf{y})^T}{\partial \mathbf{\theta}}(\mathbf{X}\mathbf{\theta} - \mathbf{y}) + (\mathbf{X}\mathbf{\theta}-\mathbf{y})^T \frac{\partial (\mathbf{X}\mathbf{\theta}-\mathbf{y})}{\partial \mathbf{\theta}} \\    &amp;= \frac{\partial \mathbf{\theta}^T\mathbf{X}^T}{\partial \mathbf{\theta}}(\mathbf{X}\mathbf{\theta} - \mathbf{y}) +  (\mathbf{X}\mathbf{\theta} - \mathbf{y})^T\mathbf{X} \\    &amp;= 2\mathbf{X}^T(\mathbf{X}\mathbf{\theta} - \mathbf{y})\end{split}\end{equation}\]</span></p><p>令上述<span class="math inline">\(\ref{partialLoss}\)</span>为零，得到： <span class="math display">\[\begin{equation}\mathbf{\theta} = (\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}\end{equation}\]</span> 一般当<span class="math inline">\(\mathbf{X}^T\mathbf{X}\)</span>为满秩矩阵或者正定矩阵时存在逆矩阵，所以一般情况下我们会引入正则化，以<span class="math inline">\(L_2\)</span>正则化为例， <span class="math display">\[\begin{equation}\mathbf{\theta} = (\mathbf{X}^T\mathbf{X} + \lambda\mathbf{I})^{-1}\mathbf{X}^T\mathbf{y}\end{equation}\]</span></p><h3 id="梯度下降法">梯度下降法</h3><p>在开始讲梯度下降法之前，我们先复习一下高等数学里面的一些概念 - 导数 &gt; 导数反应的变化率：一个函数在某一点的导数描述了这个函数在这一点附近的变化率。导数的本质是通过极限的概念对函数进行局部的线性逼近。</p><ul><li><p>偏导数 &gt; 偏导数反应的某个方向的变化率：一个函数在某一点的偏导数描述了这个函数在这一点某个方向附近的变化率。</p></li><li><p>方向导数 方向导数是函数沿各个方向的导数，梯度是一个向量，因此梯度本身是有方向的： &gt; 函数在梯度这个方向的方向导数是最大的，换句话说，一个函数在各个方向都有方向导数，其中梯度这个方向的导数为最大 &gt; 函数方向导数的最大值为梯度的模。</p></li><li><p>梯度 在微积分里面，对多元函数的参数求<span class="math inline">\(\partial\)</span>偏导数，把求得的各个参数的偏导数以向量的形式写出来，就是梯度。 &gt; 比如函数f(x,y), 分别对x,y求偏导数，求得的梯度向量就是(∂f/∂x, ∂f/∂y)T,简称grad f(x,y)或者▽f(x,y)。</p></li></ul><p>对于在点(x0,y0)的具体梯度向量就是(∂f/∂x0, ∂f/∂y0).或者▽f(x0,y0)，如果是3个参数的向量梯度，就是(∂f/∂x, ∂f/∂y，∂f/∂z),以此类推。</p><p>具体来说，对于函数f(x,y),在点(x0,y0)，沿着梯度向量的方向就是(∂f/∂x0, ∂f/∂y0)的方向是f(x,y)增加最快的地方。或者说，沿着梯度向量的方向，更加容易找到函数的最大值。反过来说，沿着梯度向量相反的方向，也就是 -(∂f/∂x0, ∂f/∂y0)的方向，梯度减少最快，也就是更加容易找到函数的最小值。</p><p>所以梯度下降法的迭代公式为 <span class="math display">\[\begin{equation}\mathbf{x}^{(k+1)} = \mathbf{x}^{(k)} - \alpha_k\nabla f(\mathbf{x}^{(k)})\end{equation}\]</span></p><h3 id="从一元线性回归到多元线性回归">从一元线性回归到多元线性回归</h3><p>一元线性回归损失函数如<span class="math inline">\(\ref{example}\)</span>所示, <span class="math display">\[\begin{equation}\label{example}\begin{split}\mathbf{J}(\theta) &amp;= \frac{1}{2m} \sum_{i=1}^{m}(\theta_0 + \theta_1 x^{(i)} - y^{(i)})^2 \\\mathbf{J}(\theta) &amp;= \frac{1}{2m} \sum_{i=1}^{m}(\theta_0 + \theta_1 x^{(i)} - y^{(i)})^2 + \frac{\lambda}{2}\theta_0^2 + \frac{\lambda}{2}\theta_1^2\end{split}\end{equation}\]</span></p><p>对应的梯度为 <span class="math display">\[\begin{equation}\label{grad}\begin{split}(\frac{1}{m}\sum_{i = 1}^{m} (\theta_0 + \theta_1 x^{(i)} - y^{(i)}) &amp;, \frac{1}{m}\sum_{i=1}^m (\theta_0 + \theta_1 x^{(i)} - y^{(i)})x^{(i)}) \\ (\frac{1}{m}\sum_{i = 1}^{m} (\theta_0 + \theta_1 x^{(i)} - y^{(i)}) + \lambda\theta_0 &amp;, \frac{1}{m}\sum_{i=1}^m (\theta_0 + \theta_1 x^{(i)} - y^{(i)})x^{(i)} + \lambda\theta_1)\end{split}\end{equation}\]</span></p><p>仔细观察上述梯度公式，可以改写成矩阵表达形式，其中<span class="math inline">\(\mathbf{\theta} = \begin{bmatrix} \theta_0 \\ \theta_1 \end{bmatrix}\)</span>, <span class="math inline">\(\mathbf{X} = \begin{bmatrix} 1 &amp; x^{(1)}\\ \vdots &amp; \vdots \\ 1 &amp; x^{(m)} \end{bmatrix}\)</span></p><p><span class="math display">\[\begin{equation}\begin{split} &amp; \frac{1}{m}\mathbf{X}^T(\mathbf{X}\mathbf{\theta} - \mathbf{y}) \\&amp; \frac{1}{m}\mathbf{X}^T(\mathbf{X}\mathbf{\theta} - \mathbf{y}) + \lambda\mathbf{\theta}\end{split}\end{equation}\]</span></p><p>所以最终我们会有<span class="math inline">\(\mathbf{\theta}\)</span>的更新公式</p><p><span class="math display">\[\begin{equation}\label{updatetheta}\begin{split}\hat{\mathbf{\theta}} &amp;:= \mathbf{\theta} - \alpha (\frac{1}{m}\mathbf{X}^T(\mathbf{X}\mathbf{\theta} - \mathbf{y}) ) \\\hat{\mathbf{\theta}} &amp;:= \mathbf{\theta} - \alpha (\frac{1}{m}\mathbf{X}^T(\mathbf{X}\mathbf{\theta} - \mathbf{y}) + \lambda\mathbf{\theta} )\\\end{split}\end{equation}\]</span></p><p>以上<span class="math inline">\(\ref{updatetheta}\)</span>的矩阵的梯度下降描述不仅适用一元回归，也可以拓展到多元线性回归。</p><h4 id="bgdsgd和mbgd">BGD、SGD和MBGD</h4><p>简单来说BGD(批量梯度下降法)就是每次更新参数时会用到所有的样本，而SGD(随机梯度下降)每次更新参数时只使用一个样本, MBGD(小批量梯度下降法)每次更新参数时使用m个样本。但是参数<span class="math inline">\(\mathbf{\theta}\)</span>的更新公式和上述的公式<span class="math inline">\(\ref{updatetheta}\)</span>一致。</p><h4 id="python举例">python举例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">geberate_date</span>(<span class="params">a, b, x_disturbance, y_disturbance</span>):</span><br><span class="line">    <span class="comment">#构造数据，加入噪声</span></span><br><span class="line">    x = np.random.randint(<span class="number">1</span>, high=<span class="number">100</span> , size=<span class="number">10</span>, dtype=<span class="built_in">int</span>).tolist()</span><br><span class="line">    y = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: a*x + b, x))</span><br><span class="line">    x = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x : [<span class="number">1.0</span>, x + x_disturbance * (<span class="number">0.5</span> - np.random.rand())], x))</span><br><span class="line">    y = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x + y_disturbance * ( <span class="number">0.5</span> - np.random.rand()), y))</span><br><span class="line">    <span class="keyword">return</span> np.array(x), np.array(y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gd_linear_regression</span>(<span class="params">x, y, theta, lamda=<span class="number">0.0</span>, alpha=<span class="number">0.1</span></span>):</span><br><span class="line">    <span class="comment"># BGD更新</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;theta &quot;</span>, theta)</span><br><span class="line">    theta -= alpha * ((x.T.dot((x.dot(theta) - y)))/<span class="built_in">len</span>(x) + lamda * theta)</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mse</span>(<span class="params">theta, x, y</span>):</span><br><span class="line">    <span class="comment"># mean square error</span></span><br><span class="line">    <span class="keyword">return</span> (((x.dot(theta) - y)**<span class="number">2</span>).<span class="built_in">sum</span>())/<span class="number">2</span>/<span class="built_in">len</span>(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iter_gd</span>(<span class="params">x, y, <span class="built_in">iter</span>=<span class="number">100</span></span>):</span><br><span class="line">    it = <span class="number">0</span></span><br><span class="line">    theta = np.array([<span class="number">2.3</span>, <span class="number">3.9</span>])</span><br><span class="line">    <span class="keyword">while</span>(it &lt; <span class="built_in">iter</span>):</span><br><span class="line">        theta = gd_linear_regression(x, y, theta, lamda=<span class="number">0.0</span>, alpha=<span class="number">0.001</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;mse &quot;</span>, mse(theta, x, y))</span><br><span class="line">        it += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    x, y = geberate_date(<span class="number">3.9</span>, <span class="number">7.8</span>, <span class="number">0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">    iter_gd(x, y)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调参注意事项:</p><ol type="1"><li><p>遇到梯度爆炸时，需要减少alpha学习速率，当发现损失函数在每次迭代时不减反增，需要减小alpha的值，直到观察到损失函数在减小</p></li><li><p>在完成第一个迭代后, 应该会发现mse减小的速率越来越小，此时可以将最后的theta参数作为一个初始值，将学习速率alpha调大，重新开始迭代</p></li><li><p>重复以上步骤直到mse符合预期</p></li></ol><h3 id="归一化">归一化</h3><p>特征归一化常用的方法包含如下几种：</p><ul><li>简单缩放</li><li>逐样本均值消减(也称为移除直流分量)</li><li>特征标准化(使数据集中所有特征都具有零均值和单位方差)</li></ul><p>数据归一化的好处:</p><ul><li>归一化后加快了梯度下降最优解的速度</li></ul><p>如下图所示，蓝色的圈圈图代表的是两个特征的等高线。其中左图两个特征X1和X2的区间相差非常大，X1区间是[0,2000]，X2区间是[1,5]，其所形成的等高线非常尖。当使用梯度下降法寻求最优解时，很有可能走“之字型”路线（垂直等高线走），从而导致需要迭代很多次才能收敛；</p><p><img src="normpros.png" /> 而右图对两个原始特征进行了归一化，其对应的等高线显得很圆，在梯度下降进行求解时能较快的收敛。因此如果机器学习模型使用梯度下降法求最优解时，归一化往往非常有必要，否则很难收敛甚至不能收敛。</p><ul><li>归一化有可能提高精度</li></ul><p>一些分类器需要计算样本之间的距离（如欧氏距离），例如KNN。如果一个特征值域范围非常大，那么距离计算就主要取决于这个特征，从而与实际情况相悖（比如这时实际情况是值域范围小的特征更重要）。</p><p>下面介绍一些具体的归一化方法</p><ul><li><p>简单缩放 x ＝ (x - min)/(max - min) min是样本最小值，max是样本最大值，实际环境中可以使用一个经验常量</p></li><li><p>标准差标准化 <span class="math inline">\(x = (x - \mu)/\sigma\)</span> <span class="math inline">\(\mu\)</span>是样本均值，<span class="math inline">\(\sigma\)</span>是样本标准差</p></li></ul><h2 id="线性回归与逻辑回归">线性回归与逻辑回归</h2><p>如果一定要用最简单的话来描述逻辑回归(对数几率回归)，就是找了一个单调可微的函数将分类任务的真实标记和线性回归的模型联系起来。比如这个公式<span class="math inline">\(\ln{\frac{\mathbf{y}}{1-\mathbf{y}}} = \mathbf{X}\mathbf{\theta}\)</span>，我们将<span class="math inline">\(\mathbf{y}\)</span>看做样本正例的可能性， <span class="math inline">\(1-\mathbf{y}\)</span>看做其反例的可能性，两者的比值称为“几率”，反映了<span class="math inline">\(x\)</span>作为正例的相对可能性。</p><h3 id="极大似然估计">极大似然估计</h3><p>极大似然估计(maximum likelihood estimation)，通俗理解来说，就是利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值！换句话说，极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知” 极大似然估计中采样需满足一个重要的假设，就是所有的采样都是独立同分布的。 总结起来，最大似然估计的目的就是：利用已知的样本结果，反推最有可能（最大概率）导致这样结果的参数值。 原理：极大似然估计是建立在极大似然原理的基础上的一个统计方法，是概率论在统计学中的应用。极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”。通过若干次试验，观察其结果，利用试验结果得到某个参数值能够使样本出现的概率为最大，则称为极大似然估计。</p><p>如果是<span class="math inline">\(\hat{\mathbf{\theta}}\)</span>是参数空间中能使似然函数<span class="math inline">\(l(\mathbf{\theta})\)</span>最大的<span class="math inline">\(\mathbf{\theta}\)</span>，则应该是“最可能”的参数值，那么<span class="math inline">\(\hat{\mathbf{\theta}}\)</span>就是<span class="math inline">\(\mathbf{\theta}\)</span>的极大似然估计量。</p><p>似然函数和对数似然函数: <span class="math display">\[\begin{equation}\begin{split}D &amp; = \{x^{(1)}, x^{(2)}, \cdots, x^{(N)}\}\\L(\mathbf{\theta}) &amp;= P(D|\mathbf{\theta}) =p(x^{(1)}, x^{(2)}, \cdots, x^{(N)} | \mathbf{\theta}) = \prod_{i=1}^{i=N}P(x^{(i)}|\mathbf{\theta}) \\l(\mathbf{\theta}) &amp;= \ln{L(\mathbf{\theta})} = \ln{P(D|\mathbf{\theta})} = \sum_{i=1}^{i=N}\ln{P(x^{(i)}|\mathbf{\theta})}\end{split}\end{equation}\]</span></p><p>在线性回归中，我们会用Mean Square Error作为损失函数<span class="math inline">\(J(\mathbf{\theta}) = \sum_{i=1}^{n}(\mathbf{X}\mathbf{\theta}-\mathbf{y})^2\)</span>，但是在一个二分类问题中，Mean Square Error将不会是一个凸函数，这是因为y的取值是离散的。非凸函数不利于极值求解。我们需要重新寻找损失函数。</p><p>如果我们把每一条样本都看成是一次后验概率的发生，即<span class="math inline">\(P(y|x; \theta)\)</span>，并且我们能取得的样本是在(x; )情况下最有可能(概率最大)的结果(极大似然估计思想)。</p><p><span class="math display">\[\begin{equation}\begin{split}\phi(z) &amp;= \frac{1}{1 + e^{-z}} \\z &amp;= x\theta \\P(y|x, \theta) &amp;= \phi(z)^{y}(1-\phi(z))^{(1-y)}\end{split}\end{equation}\]</span></p><p>我们在结合对数似然函数:</p><p><span class="math display">\[\begin{equation}\begin{split}l(\mathbf{\theta}) &amp;= \sum_{i=1}^{n}\ln{P(y^{(i)}|x^{(i)};\mathbf{\theta} ) } \\  &amp;= \sum_{i=1}^{n}\ln{\phi(z^{(i)})^{y^{(i)}} (1-\phi(z^{(i)})^{(1-y^{(i)})})} \\  &amp;= \sum_{i=1}^{n}{y^{(i)}\ln{\phi(z^{(i)})} + (1-y^{(i)})\ln{(1-\phi(z^{(i)})}}\end{split}\end{equation}\]</span></p><p>我们现在要求的是使得<span class="math inline">\(l(\mathbf{\theta})\)</span>最大的<span class="math inline">\(\mathbf{\theta}\)</span>。没错，我们的代价函数出现了，我们在<span class="math inline">\(l(\mathbf{\theta})\)</span>前面加个负号不就变成就最小了吗？不就变成我们代价函数了吗？</p><p><span class="math display">\[\begin{equation}\label{mlecost}\begin{split}J(\mathbf{\theta}) &amp;= -\frac{1}{N}l(\mathbf{\theta}) \\    &amp;= -\frac{1}{N}\sum_{i=1}^{n}{y^{(i)}\ln{\phi(z^{(i)})} + (1-y^{(i)})\ln{(1-\phi(z^{(i)})}} \\z^{(i)} &amp;= x^{(i)}\theta \\\phi(z^{(i)}) &amp;= \frac{1}{1 + e^{-z^{(i)}}}   \end{split}\end{equation}\]</span></p><p>为了更好地理解这个代价函数，我们不妨拿一个样本来看看</p><p><span class="math display">\[J(\phi(z), y; \theta) = -y\ln{\phi(z)} -(1-y)\ln{(1-\phi(z))}\]</span></p><p>既有: <span class="math display">\[\begin{equation}J(\phi(z), y; \theta) = \begin{cases}-ln{\phi(z)}, &amp; \text{if y = 1} \\-ln{(1-\phi(z))}, &amp;\text{if y = 0}    \end{cases}\end{equation}\]</span> <img src="logitcost.png" /></p><p>从图中不难看出，如果样本的值是1的话，估计值<span class="math inline">\(\phi(z)\)</span>越接近1付出的代价就越小，反之越大；同理，如果样本的值是0的话，估计值(z)越接近0付出的代价就越小，反之越大。</p><h3 id="散度与交叉熵">散度与交叉熵</h3><p>熵用来描述一个系统中的不确定性，在不同领域又会有不一样的解释。在信息论中，一个事件发生的概率越大，所携带的信息量越小，熵(Entropy)是信息量的期望，并且编码长度与概率之间的关系是：概率越大，需要的编码二进制位越少。p(x)的最优编码是<span class="math inline">\(\log{\frac{1}{p(x)}}\)</span></p><p><span class="math display">\[\begin{equation}\label{entropy}\begin{split}L(x) &amp;= \log{\frac{1}{p(x)}} \\H(p) &amp;= \sum_{x}p(x)\log{\frac{1}{p(x)}}\end{split}\end{equation}\]</span></p><p>如公式<span class="math inline">\(\ref{entropy}\)</span>所示，H表示概率分布p(x)的平均码长，信息量的多少与概率分布相关，概率分布越分散，不确定性越高，信息量越大。</p><p>交叉熵的定义：对于一个概率分布<span class="math inline">\(p(x)\)</span>，使用另一个概率分布<span class="math inline">\(q(x)\)</span>的最优编码，得到的平均码长<span class="math inline">\(H_q(p)\)</span>, 称为p对q的交叉熵。注意交叉熵具有不对称性，<span class="math inline">\(H_q(p) \neq H_q(p)\)</span></p><p><span class="math display">\[ H_q(p) = \sum_{x}p(x)\log{\frac{1}{q(x)}}\]</span> K-L divergence 表示交叉熵与熵的差值，表达了两个分布之间的差异程度</p><p><span class="math display">\[\begin{split}D_q(p) &amp;= H_q(p) - H(p) \\  &amp;= \sum_{x}p(x)\log{\frac{1}{q(x)}} - \sum_{x}p(x)\log{\frac{1}{p(x)}}\\&amp;=\sum_{x}p(x)\log{\frac{p(x)}{q(x)}}\end{split}\]</span> 显而易见，K-L divergence 也不具有对称性。同时，<span class="math inline">\(D_{q}(p) = H_q(p) - H(p)\)</span> 也表示在真实分布p的前提下使用q分布编码所多出来的bit数。</p><p>机器学习的过程就是希望在训练数据上模型学到的分布和真实数据分布越来越接近，但是我们无法得知真实数据的分布，只能让模型学到的分布和训练数据的分布接近。因为我们会假设训练数据都是iid采样得来的。所以我们可以利用最小化训练数据的经验误差来近似泛化误差的减小。因为<span class="math inline">\(D_{q}(p) = H_q(p) - H(p)\)</span>其中p是训练数据的分布，是一个已知分布。所以最小化散度就变成交叉熵最小。</p><p>所以逻辑思路是，为了让学到的模型越来越接近真实数据分布，我们最小化 模型分布 和 训练数据之间的KL散度，又因为训练数据的分布是固定的，所以会等价为最小化交叉熵。</p><p>现在我们从交叉熵出发<span class="math inline">\(H_q(p)=-\sum_xp(x)\log{q(x)}\)</span>，推导出逻辑回归的损失函数</p><p>输出的y的概率分布函数应该如图所示， <span class="math display">\[\begin{equation}p(y) = \begin{cases}y, &amp; \text{y = 1} \\1-y, &amp;\text{y = 0}\end{cases}\end{equation}\]</span></p><p>假定的<span class="math inline">\(q(\hat{y})\)</span>分布和<span class="math inline">\(p(y)\)</span>形式一致： <span class="math display">\[\begin{equation}q(\hat{y}) = \begin{cases}\hat{y} \\1 - \hat{y} \end{cases}\end{equation}\]</span></p><p>所以我们会有:</p><p><span class="math display">\[\begin{equation}\label{onesamplecross}\begin{split}-\sum_{x}p(x)\log{q(x)} &amp;= -\sum_{y=0, 1}p(y)\log{q(\hat{y})} \\&amp;= -(y\log{\hat{y}} + (1-y)\log{(1-\hat{y})}) \\\hat{y} &amp;= \frac{1}{1+e^{-x\theta}}\end{split}\end{equation}\]</span></p><p>注意上述公式<span class="math inline">\(\ref{onesamplecross}\)</span>是单个样本的交叉熵， 实际情况是我们会有符合iid条件的n个样本，需要对交叉熵进行求和取平均值，最终我们得到的损失函数如下:</p><p><span class="math display">\[\begin{equation}\label{crossentropycost}\begin{split}\hat{y}^{(i)} &amp;= \frac{1}{1 + e^{-x^{(i)}\theta}} \\J(\mathbf{\theta}) &amp;= -\frac{1}{N}\sum_{i=1}^{n}y^{(i)}\log{\hat{y}^{(i)}} + (1-y^{(i)})\log(1-\hat{y}^{(i)})\end{split}\end{equation}\]</span></p><p>通过交叉熵推导的损失函数公式<span class="math inline">\(\ref{crossentropycost}\)</span>与通过最大似然估计推导的损失函数公式<span class="math inline">\(\ref{mlecost}\)</span>是一致的。</p><h3 id="使用梯度下降求解逻辑回归">使用梯度下降求解逻辑回归</h3><p><span class="math display">\[\begin{equation} \begin{split}\frac{\partial J}{\partial \theta_j} &amp;= \frac{\partial J}{\partial \phi{(z)}}\frac{\partial \phi{(z)}}{\partial z}\frac{\partial z}{\partial \theta_j} \\&amp;= -\frac{1}{N}\sum_{i=1}^{n}( \frac{y^{(i)}}{\phi(z^{(i)})} - \frac{1-y^{(i)}}{1-\phi(z^{(i)})})\phi(z^{(i)})(1-\phi(z^{(i)}))x_j^{(i)}\\&amp;= -\frac{1}{N}\sum_{i=1}^{n}( y(1-\phi(z^{(i)}))-(1-y)\phi(z^{(i)}))x_j^{(i)}\\&amp;= -\frac{1}{N}\sum_{i=1}^{n}(y^{(i)}-\phi(z^{(i)}))x_j^{(i)} \\&amp;= -\frac{1}{N} (\mathbf{y} - \Phi{(z)})^T\mathbf{x}_j\end{split}\end{equation}\]</span></p><p>所以最终的梯度更新公式为</p><p><span class="math display">\[\begin{equation}\label{logitgd}\begin{split}\frac{\partial J}{\partial \mathbf{\theta}} &amp;= -\frac{1}{N} (\mathbf{y} - \frac{1}{1 + e^{-\mathbf{X\theta}}})^TX\\\hat{\mathbf{\theta}} &amp;:= \mathbf{\theta} - \alpha(\frac{1}{N}(\frac{1}{1 + e^{-\mathbf{X\theta}}}-\mathbf{y})^TX  + \lambda\mathbf{\theta} )\\\end{split}\end{equation}\]</span></p><h3 id="多分类学习">多分类学习</h3><p>现实中常常会遇到多分类学习任务，有些二分类学习方法可以直接拓展到多分类，但是在更多情况下，我们会基于一些基本的策略，利用二分类学习器来解决多分类问题。多分类学习器的基本思路是&quot;拆解法&quot;，即将多分类任务拆解为若干个二分类任务，为每一个二分类任务训练一个分类器，在测试时，对这些分类器的预测结果进行集成以获得最终的多分类结果。这里的关键是如何进行任务拆解，以及如何对多个分类器进行集成。</p><ol type="1"><li>一对一(One vs One 简称OvO)</li></ol><p>具体做法是假设训练集上共有N个类别，将这N个类别两两配对，从而产生N(N-1)/2个二分类任务。训练完成后，在测试阶段，新样本同时提交给所有分类器，于是我们会有N(N-1)/2个分类结果，可以把预测最多的类别作为最终分类结果</p><ol start="2" type="1"><li>一对其他(One vs Rest 简称OvR)</li></ol><p>OvR则是每次将一个类别作为正例、所有的其他类作为反例来训练N个分类器，在测试时如果仅有一个分类器预测为正例，则对应的类别标记作为最终分类，如果多个分类器预测为正，通常会选择置信度最大的。</p><ol start="3" type="1"><li>多对多(Many vs Many 简称 MvM)</li></ol><p>MvM是每次将若干个类作为正例，若干个其他类作为反例。MvM的正反类构造有特殊的设计，通过编码矩阵(coding matrix)指定。</p><h3 id="类别不平衡问题">类别不平衡问题</h3><p>机器学习中常常会遇到数据的类别不平衡（class imbalance），也叫数据偏斜（class skew）。以常见的二分类问题为例，我们希望预测病人是否得了某种罕见疾病。但在历史数据中，阳性的比例可能很低（如百分之0.1）。在这种情况下，学习出好的分类器是很难的，而且在这种情况下得到结论往往也是很具迷惑性的。</p><p>以上面提到的场景来说，如果我们的分类器总是预测一个人未患病，即预测为反例，那么我们依然有高达99.9%的预测准确率。然而这种结果是没有意义的。</p><ul><li>从训练模型的角度</li></ul><p>如果某类的样本数量很少，那么这个类别所提供的“信息”就太少。使用经验风险（模型在训练集上的平均损失）最小化作为模型的学习准则。设损失函数为0-1 loss（这是一种典型的均等代价的损失函数），那么优化目标就等价于错误率最小化（也就是accuracy最大化）。考虑极端情况：1000个训练样本中，正类样本999个，负类样本1个。训练过程中在某次迭代结束后，模型把所有的样本都分为正类，虽然分错了这个负类，但是所带来的损失实在微不足道，accuracy已经是99.9%，于是满足停机条件或者达到最大迭代次数之后自然没必要再优化下去，ok，到此为止，训练结束！于是这个模型没有学习到如何去判别出少数类。</p><ul><li>从模型的预测过程</li></ul><p>考虑二项Logistic回归模型。输入一个样本<span class="math inline">\(x\)</span> ，模型输出的是其属于正类的概率<span class="math inline">\(\hat{y}\)</span> 。当<span class="math inline">\(\hat{y} &gt; 0.5\)</span> 时，模型判定该样本属于正类，否则就是属于反类。 为什么是0.5呢？可以认为模型是出于最大后验概率决策的角度考虑的，选择了0.5意味着当模型估计的样本属于正类的后验概率要大于样本属于负类的后验概率时就将样本判为正类。但实际上，这个后验概率的估计值是否准确呢？</p><p>从几率（odds）的角度考虑：几率表达的是样本属于正类的可能性与属于负类的可能性的比值。模型对于样本的预测几率为<span class="math inline">\(\frac{\hat{y}}{1-\hat{y}}\)</span></p><p>模型在做出决策时，当然希望能够遵循真实样本总体的正负类样本分布：设<span class="math inline">\(y\)</span>等于正类样本数除以全部样本数，那么样本的真实几率为<span class="math inline">\(\frac{y}{1-y}\)</span> 。当观测几率大于真实几率<span class="math inline">\(\hat{y} &gt; y\)</span>，那么就判定这个样本属于正类。虽然我们无法获悉真实样本总体，但之于训练集，存在这样一个假设：<font color='red'>训练集是真实样本总体的无偏采样</font>。正是因为这个假设，所以认为训练集的观测几率就代表了真实几率。所以在这个假设下，当一个<font color='red'>样本的预测几率大于观测几率</font>时，就应该将样本判断为正类。</p><h4 id="类别不平衡的评估">类别不平衡的评估</h4><ol type="1"><li>ROC是一种常见的替代方法，全名receiver operating curve，计算ROC曲线下的面积AUC是一种主流方法</li><li>使用F1指标评价</li><li>使用precision-recall图</li></ol><h4 id="处理类别不平衡的常用方法">处理类别不平衡的常用方法</h4><ol type="1"><li>再缩放</li></ol><p>假设<span class="math inline">\(\hat{y}\)</span>是预测的正例值，<span class="math inline">\(m^+\)</span>表示正例数目，<span class="math inline">\(m^-\)</span>表示负例数目，那么我们对于预测几率进行再缩放 <span class="math inline">\(\frac{\check{y}}{1-\check{y}}=\frac{\hat{y}}{1-\hat{y}} \times \frac{m^-}{m^+}\)</span>，那么此时再和默认阈值0.5去比较。</p><p>对于二分类问题，可以通过再缩放获得理论最优解，但对于多分类问题大多数情况不存在闭式解。</p><ol start="2" type="1"><li>欠采样</li></ol><p>去除一些较多的类别，使得正反例数目接近。但是要注意随机丢弃反例可能会丢失重要信息。欠采样的代表性算法是利用集成学习机制(比如随机森林)，将反例划分为若干个集合共不同学习器使用，这样对每个学习器来说都进行了欠采样，但是从全局看不会丢失重要信息。</p><ol start="3" type="1"><li>过采样</li></ol><p>过采样会增加一些正例，但是过采样法不能简单的增加正例，这样会导致严重的过拟合。代表性算法有SMOTE，其核心思想是通过对正例进行插值来产生额外正例。</p><h3 id="softmax">softmax</h3><p>之前讨论过多分类问题可以拆解成一系列二分类问题，那有没有直接可以用于多分类的模型呢? 答案就是softmax，它可以直接对多类别进行分类。 softmax函数的本质是将一个K维的任意实数向量压缩（映射）成另一个K维的实数向量，其中向量中的每个元素取值都介于（0,1）之间，而且所有元素之和为1。 <span class="math display">\[S(z_j) = \frac{e^{z_j}}{\sum_{i=1}^{n}e^{z_i}}\]</span></p><p>我们需要损失函数返回预测结果与真实结果之间的差距，并进行梯度下降进行参数更新。实际上，softmax回归更多地是用在神经网络输出层的后面，得到损失函数后进行反向传播更新，当然也可以直接套用一个线性模型。</p><p>下面我们用梯度下降法推导出softmax的参数更新公式，其损失函数形式依然是从交叉熵出发, 先来看单个样本的损失函数<span class="math inline">\(J&#39;\)</span>，并且假设类别个数为k</p><p><span class="math display">\[\begin{equation}\begin{split}J&#39; &amp;= -\sum p(x)\log{q(x)} \\ &amp;= -\sum_{i = 1}^{k}y_i\log{(\hat{y}_i)}\\\hat{y}_i &amp;= \frac{e^{z_i}}{\sum_{i=1}^{k}e^{z_i}}\\\frac{\partial J&#39;}{\partial \hat{y}} &amp;= -\sum_{i=1}^{k} y_i \frac{1}{\hat{y}_i}\\\frac{\partial \hat{y}_i} {\partial z_j} = \frac{\partial \frac{e^{z_i}}{\sum_{k=1}^k e^{z_k}}}{\partial z_j} &amp;= \begin{cases}\frac{e^{z_i}\sum - e^{z_i}e^{z_j}}{\sum^2}=\frac{e^{z_i}}{\sum}(1-\frac{e^{z_i}}{\sum}) = \hat{y}_i(1- \hat{y}_i) &amp; i = j \\-e^{z_i}\frac{e^{z_j}}{\sum^2} = -\hat{y}_i\hat{y}_j &amp; i \neq j\end{cases} \\\frac{\partial J&#39;}{\partial z_j} &amp;= -(\sum^k y_i \frac{1}{\hat{y}_i})\frac{\partial \hat{y}_i}{\partial z_j}\\&amp;= -\frac{y_i}{\hat{y}_i}\hat{y}_i(1 - \hat{y}_i) + \sum^k_{i \neq j}\frac{y_i}{\hat{y}_j}\hat{y}_i\hat{y}_j\\&amp;=-y_i + y_i\hat{y}_i + \sum_{i \neq j}^ky_i\hat{y}_i \\&amp;= -y_i + \sum_{j=1}^k y_j\hat{y}_i = -y_i + \hat{y}_i\sum_{j=1}^k y_j = \hat{y}_i - y_i\end{split}\end{equation}\]</span></p><p>我们把单个样本损失函数用矩阵形式表示 <span class="math display">\[\begin{equation}\begin{split}\mathbf{\theta} &amp;= \begin{bmatrix} \theta_1^T \\ \theta_2^T \\ \vdots \\ \theta_k ^T \end{bmatrix} \\z &amp;= \begin{bmatrix} \theta_1^Tx &amp; \theta_2^Tx &amp; \cdots &amp; \theta_k^Tx \end{bmatrix}^T = \mathbf{\theta}x \\\frac{\partial J&#39;}{\partial \mathbf{\theta}} &amp;= \frac{\partial J&#39;}{\partial z} \frac{\partial z}{\partial \mathbf{\theta}} \\&amp;= (\hat{y}-y)^Tx\end{split}\end{equation}\]</span></p><p>最后我们需要考虑所有样本的损失函数均值最小，即把上面的式子进行求和取平均，假设我们的样本总数为N</p><p><span class="math display">\[\begin{equation}\begin{split}\frac{\partial J}{\partial \mathbf{\theta}} &amp;= \frac{1}{N}\begin{bmatrix} \hat{y}^{(1)}-y^{(1)} &amp; \hat{y}^{(2)}-y^{(2)} &amp; \cdots &amp; \hat{y}^{(n)}-y^{(n)} \end{bmatrix} \begin{bmatrix} x^{(1)} \\ x^{(2)} \\ \cdots \\ x^{(n)} \end{bmatrix} \\&amp;=\frac{1}{N} (\mathbf{\hat{Y}} - \mathbf{Y})^T\mathbf{X} \\\mathbf{\hat{\theta}} &amp;:=  \mathbf{\theta} - \alpha(\frac{1}{N}(\mathbf{\hat{Y}} - \mathbf{Y})^T\mathbf{X} + \lambda \mathbf{\theta})\end{split}\end{equation}\]</span></p><p>事实上对于一个线性模型，它的梯度下降法参数更新公式都可以统一到下面这个公式</p><p><span class="math display">\[\begin{equation}\label{linearunity}\begin{split}\mathbf{\hat{\theta}} := \mathbf{\theta} - \alpha(\frac{1}{N} (\mathbf{\hat{Y}} - \mathbf{Y})^T\mathbf{X} + \lambda \mathbf{\theta})\end{split}\end{equation}\]</span></p><h3 id="python-softmax实现">python softmax实现</h3><p>拓扑结构如下图所示： <img src="cross_entropy_topology.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    exp_value = np.exp(<span class="built_in">input</span>)  <span class="comment"># 首先计算指数</span></span><br><span class="line">    output = exp_value / np.<span class="built_in">sum</span>(exp_value, axis=<span class="number">1</span>)[:, np.newaxis]  <span class="comment"># 然后按行标准化</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CrossEntropyLossLayer</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span>, labels</span>):</span><br><span class="line">        <span class="comment"># 做一些防止误用的措施，输入数据必须是二维的，且标签和数据必须维度一致</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(<span class="built_in">input</span>.shape) == <span class="number">2</span>, <span class="string">&#x27;输入的数据必须是一个二维矩阵&#x27;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(labels.shape) == <span class="number">2</span>, <span class="string">&#x27;输入的标签必须是独热编码&#x27;</span></span><br><span class="line">        <span class="keyword">assert</span> labels.shape == <span class="built_in">input</span>.shape, <span class="string">&#x27;数据和标签数量必须一致&#x27;</span></span><br><span class="line">        self.data = <span class="built_in">input</span></span><br><span class="line">        self.labels = labels</span><br><span class="line">        self.prob = np.clip(softmax(<span class="built_in">input</span>), <span class="number">1e-9</span>, <span class="number">1.0</span>)  <span class="comment"># 在取对数时不能为 0，所以用极小数代替 0</span></span><br><span class="line">        loss = -np.<span class="built_in">sum</span>(np.multiply(self.labels, np.log(self.prob))) / self.labels.shape[<span class="number">0</span>] <span class="comment">#根据交叉熵定义</span></span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self</span>):</span><br><span class="line">        self.grad = (self.prob - self.labels) / self.labels.shape[<span class="number">0</span>]  <span class="comment"># 根据公式计算梯度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>():</span><br><span class="line">    mnist = tf.keras.datasets.mnist</span><br><span class="line">    i = np.eye(<span class="number">10</span>, dtype=np.uint8)</span><br><span class="line">    (x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line">    <span class="built_in">print</span>(x_train.shape, y_train.shape, x_test.shape, y_test.shape)</span><br><span class="line">    x_train = np.c_[np.ones(x_train.shape[<span class="number">0</span>]),np.reshape(x_train, (<span class="number">60000</span>, -<span class="number">1</span>)) / <span class="number">255</span>]</span><br><span class="line">    x_test = np.c_[np.ones(x_test.shape[<span class="number">0</span>]), np.reshape(x_test, (<span class="number">10000</span>, -<span class="number">1</span>)) / <span class="number">255</span>]</span><br><span class="line">    y_train = np.array(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: i[x], y_train.tolist())))</span><br><span class="line">    y_test = np.array(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: i[x], y_test.tolist())))</span><br><span class="line">    <span class="built_in">print</span>(x_train.shape, y_train.shape, x_test.shape, y_test.shape)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x_train, y_train, x_test, y_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    x_train, y_train, x_test, y_test = get_data()</span><br><span class="line">    alpha = <span class="number">0.01</span></span><br><span class="line">    lambd = <span class="number">0.000</span></span><br><span class="line">    theta = np.random.randn(x_train.shape[<span class="number">1</span>], y_train.shape[<span class="number">1</span>]) * <span class="number">0.01</span>  <span class="comment"># 高斯初始化，均值为 0，标准差 0.01</span></span><br><span class="line"></span><br><span class="line">    cross_entropy_layer = CrossEntropyLossLayer()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>): <span class="comment">#每次迭代计算准确率</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># train</span></span><br><span class="line">        loss = cross_entropy_layer.forward(np.matmul(x_train, theta), y_train)</span><br><span class="line">        cross_entropy_layer.backward()</span><br><span class="line">        theta -= alpha * ( np.matmul(x_train.T, cross_entropy_layer.grad) + lambd * theta)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># test</span></span><br><span class="line">        test_pred = np.matmul(x_test, theta)</span><br><span class="line">        pred_labels = np.argmax(test_pred, axis=<span class="number">1</span>)</span><br><span class="line">        real_labels = np.argmax(y_test, axis=<span class="number">1</span>)</span><br><span class="line">        acc = np.mean(pred_labels == real_labels) <span class="comment"># python false is 0 while true is 1</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;epoch &quot;</span>, epoch, <span class="string">&quot;loss &quot;</span>, loss, <span class="string">&quot;acc &quot;</span>, acc)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小结">小结</h2><ol type="1"><li><p>对于线性模型的L2损失函数，如果采用梯度下降法，可以归纳到这个式子<span class="math inline">\(\mathbf{\hat{\theta}} := \mathbf{\theta} - \alpha(\frac{1}{N} (\mathbf{\hat{Y}} - \mathbf{Y})^T\mathbf{X} + \lambda \mathbf{\theta})\)</span></p></li><li><p>我们用交叉熵来解释分类问题的损失函数，让学到的模型越来越接近真实数据分布，我们最小化<font color='red'>模型分布</font>和<font color='red'>训练数据</font> 之间的KL散度，又因为训练数据的分布是固定的，所以会等价为最小化交叉熵。</p></li><li><p>在调参过程中，出现梯度爆炸需要先减小学习速率<span class="math inline">\(\alpha\)</span>，对于训练数据的归一化可以加快梯度下降最优解的速度</p></li><li><p>处理类别不平衡问题的常用方法有再缩放，欠采样，过采样。</p></li></ol><p>参考:</p><ol type="1"><li><p><a href="https://zhuanlan.zhihu.com/p/36691384" class="uri">https://zhuanlan.zhihu.com/p/36691384</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/27223959" class="uri">https://zhuanlan.zhihu.com/p/27223959</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习--spark基于opencv做图片分类</title>
      <link href="/2020/05/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-spark%E5%9F%BA%E4%BA%8Eopencv%E5%81%9A%E5%9B%BE%E7%89%87%E5%88%86%E7%B1%BB/"/>
      <url>/2020/05/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-spark%E5%9F%BA%E4%BA%8Eopencv%E5%81%9A%E5%9B%BE%E7%89%87%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>spark擅长分布式处理海量数据，opencv又是进行图像处理的利器，在面对海量图片的时候，我们是否可以考虑结合二者的优势? 本文将展示如何在spark下使用opencv，并训练一个简单的二分类模型。</p><span id="more"></span><h2 id="环境准备">环境准备</h2><ol type="1"><li>我们首先在单机上测试，先下载<a href="https://github.com/opencv/opencv">opencv源码</a>，安装opencv可以参考<a href="https://docs.opencv.org/trunk/d7/d9f/tutorial_linux_install.html">这篇</a></li><li>在编译好的文件夹下 有命名为opencv_xxx.jar的java接口, 这个需要添加到项目依赖，同时要添加jvm运行时的option。以IDEA为例，Run-&gt;EditConfiguration, vm option 添加 -Djava.library.path=&quot;/Users/mluo/Documents/opencv/build/lib&quot;</li><li>在开始运行时添加 System.loadLibrary(Core.NATIVE_LIBRARY_NAME)，确保能够Load the native library <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rootLogger = <span class="type">Logger</span>.getRootLogger()</span><br><span class="line">    rootLogger.setLevel(<span class="type">Level</span>.<span class="type">WARN</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the native library.</span></span><br><span class="line">    <span class="type">System</span>.loadLibrary(<span class="type">Core</span>.<span class="type">NATIVE_LIBRARY_NAME</span>)</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 完成以上的步骤，就可以保证在spark中正常调用opencv</li></ol><h2 id="图片的特征处理">图片的特征处理</h2><p>常用的图像特征有颜色特征、纹理特征、形状特征、空间关系特征</p><ul><li><strong>什么是颜色通道</strong></li></ul><ol type="1"><li><p>单通道图 俗称灰度图，每个像素点只能有有一个值表示颜色，它的像素值在0到255之间，0是黑色，255是白色，中间值是一些不同等级的灰色。（也有3通道的灰度图，3通道灰度图只有一个通道有值，其他两个通道的值都是零）。</p></li><li><p>三通道图 每个像素点都有3个值表示 ，所以就是3通道。也有4通道的图。例如RGB图片即为三通道图片，RGB色彩模式是工业界的一种颜色标准，是通过对红(R)、绿(G)、蓝(B)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。总之，每一个点由三个值表示。还会有其他的描述通道 比如 CMYK（四个分量）、Lab（三个）、HSV（三个）等等</p></li></ol><ul><li><p><strong>图片为什么要灰度化</strong> 识别物体，最关键的因素是梯度（SIFT/HOG），梯度意味着边缘，这是最本质的部分，而计算梯度，自然就用到灰度图像了，可以把灰度理解为图像的强度。颜色，易受光照影响，难以提供关键信息，故将图像进行灰度化，同时也可以加快特征提取的速度。</p></li><li><p><strong>什么是仿射不变形</strong> 平面上任意两条线，经过仿射变换后，仍保持原来的状态（比如平行的线还是平行，相交的线夹角不变等）</p></li><li><p><strong>什么是局部特征 局部特征有哪些特点</strong> 局部特征从总体上说是图像或在视觉领域中一些有别于其周围的地方；局部特征通常是描述一块区域，使其能具有高可区分度；局部特征的好坏直接会决定着后面分类、识别是否会得到一个好的结果。局部特征应该具有的特点： 可重复性、可区分性、准确性、有效性（特征的数量、特征提取的效率）、鲁棒性（稳定性、不变性）</p></li></ul><h3 id="sift尺度不变特征变换特征提取">SIFT(尺度不变特征变换)特征提取</h3><p>实质是在不同的尺度空间上查找关键点(特征点)，并计算出关键点的方向。SIFT所查找到的关键点是一些十分突出、不会因光照、仿射变换和噪音等因素而变化的点，如角点、边缘点、暗区的亮点及亮区的暗点等。主要步骤如下:</p><ol type="1"><li><p>构建DOG尺度空间： 模拟图像数据的多尺度特征，大尺度抓住概貌特征，小尺度注重细节特征。通过构建高斯金字塔（每一层用不同的参数σ做高斯模糊（加权）），保证图像在任何尺度都能有对应的特征点，即保证尺度不变性。</p></li><li><p>关键点搜索和定位： 确定是否为关键点，需要将该点与同尺度空间不同σ值的图像中的相邻点比较，如果该点为max或min，则为一个特征点。找到所有特征点后，要去除低对比度和不稳定的边缘效应的点，留下具有代表性的关键点（比如，正方形旋转后变为菱形，如果用边缘做识别，4条边就完全不一样，就会错误；如果用角点识别，则稳定一些）。去除这些点的好处是增强匹配的抗噪能力和稳定性。最后，对离散的点做曲线拟合，得到精确的关键点的位置和尺度信息。</p></li><li><p>方向赋值： 为了实现旋转不变性，需要根据检测到的关键点的局部图像结构为特征点赋值。具体做法是用梯度方向直方图。在计算直方图时，每个加入直方图的采样点都使用圆形高斯函数进行加权处理，也就是进行高斯平滑。这主要是因为SIFT算法只考虑了尺度和旋转不变形，没有考虑仿射不变性。通过高斯平滑，可以使关键点附近的梯度幅值有较大权重，从而部分弥补没考虑仿射不变形产生的特征点不稳定。注意，一个关键点可能具有多个关键方向，这有利于增强图像匹配的鲁棒性。</p></li><li><p>关键点描述子的生成： 关键点描述子不但包括关键点，还包括关键点周围对其有贡献的像素点。这样可使关键点有更多的不变特性，提高目标匹配效率。在描述子采样区域时，需要考虑旋转后进行双线性插值，防止因旋转图像出现白点。同时，为了保证旋转不变性，要以特征点为中心，在附近领域内旋转θ角，然后计算采样区域的梯度直方图，形成n维SIFT特征矢量（如128-SIFT）。最后，为了去除光照变化的影响，需要对特征矢量进行归一化处理。</p></li></ol><ul><li><strong>SIFT特征提取的优点</strong><ol type="1"><li>SIFT特征是图像的局部特征，其对旋转、尺度缩放、亮度变化保持不变性，对视角变化、仿射变换、噪声也保持一定程度的稳定性；</li><li>独特性（Distinctiveness）好，信息量丰富，适用于在海量特征数据库中进行快速、准确的匹配；</li><li>多量性，即使少数的几个物体也可以产生大量的SIFT特征向量；</li><li>高速性，经优化的SIFT匹配算法甚至可以达到实时的要求；</li><li>可扩展性，可以很方便的与其他形式的特征向量进行联合；需要较少的经验主义知识，易于开发。</li></ol></li><li><strong>SIFT特征提取的缺点</strong><ol type="1"><li>实时性不高，因为要不断地要进行下采样和插值等操作；</li><li>有时特征点较少（比如模糊图像）；</li><li>对边缘光滑的目标无法准确提取特征（比如边缘平滑的图像，检测出的特征点过少，对圆更是无能为力）。</li></ol></li><li><strong>SIFT特征提取可以解决的问题</strong> 目标的自身状态、场景所处的环境和成像器材的成像特性等因素影响图像配准/目标识别跟踪的性能。而SIFT算法在一定程度上可解决：<ul><li>目标的旋转、缩放、平移（RST）</li><li>图像仿射/投影变换（视点viewpoint）</li><li>光照影响（illumination）</li><li>目标遮挡（occlusion）</li><li>杂物场景（clutter）</li><li>噪声</li></ul></li></ul><h3 id="颜色特征">颜色特征</h3><h3 id="颜色直方图">颜色直方图</h3><p>颜色直方图用以反映图像颜色的组成分布，即各种颜色出现的概率。Swain和Ballard最先提出了应用颜色直方图进行图像特征提取的方法，首先利用颜色空间三个分量的剥离得到颜色直方图，之后通过观察实验数据发现将图像进行旋转变换、缩放变换、模糊变换后图像的颜色直方图改变不大，即图像直方图对图像的物理变换是不敏感的。因此常提取颜色特征并用颜色直方图应用于衡量和比较两幅图像的全局差。另外，如果图像可以分为多个区域，并且前景与背景颜色分布具有明显差异，则颜色直方图呈现双峰形。</p><p>颜色直方图也有其缺点：由于颜色直方图是全局颜色统计的结果，因此丢失了像素点间的位置特征。可能有几幅图像具有相同或相近的颜色直方图，但其图像像素位置分布完全不同。因此，图像与颜色直方图得多对一关系使得颜色直方图在识别前景物体上不能获得很好的效果。</p><p>考虑到颜色直方图的以上问题，主色调直方图便产生了。所谓主色调直方图基于假设少数几个像素的值能够表示图像中的绝大部分像素，即出现频率最高的几个像素被选为主色，仅用主色构成的主色调直方图描述一幅图像。这样的描述子并不会降低通过颜色特征进行匹配的效果，因为从某种角度将，频度出现很小的像素点可以被视为噪声。</p><h3 id="颜色矩">颜色矩</h3><p>颜色矩是一种有效的颜色特征，由Stricker和Orengo提出.该方法利用线性代数中矩的概念，将图像中的颜色分布用其矩表示。利用颜色一阶矩（平均值Average）、颜色二阶矩（方差Variance）和颜色三阶矩（偏斜度Skewness）来描述颜色分布。与颜色直方图不同，利用颜色矩进行图像描述无需量化图像特征。由于每个像素具有颜色空间的三个颜色通道，因此图像的颜色矩有9个分量来描述。由于颜色矩的维度较少，因此常将颜色矩与其他图像特征综合使用。</p><h2 id="利用图像特征训练svm分类模型">利用图像特征训练SVM分类模型</h2><p>上面介绍了提取图像特征的主要方法，这里我们利用opencv计算每一张图片的颜色矩,</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算颜色矩 总共9个分量 返回tuple</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calColorMoment</span></span>(channel: <span class="type">Mat</span>*) = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> bch = channel(<span class="number">0</span>) <span class="comment">//blue channel</span></span><br><span class="line">    <span class="keyword">val</span> gch = channel(<span class="number">1</span>) <span class="comment">//green channel</span></span><br><span class="line">    <span class="keyword">val</span> rch = channel(<span class="number">2</span>) <span class="comment">//red channel</span></span><br><span class="line"></span><br><span class="line">    bch.convertTo(bch, <span class="type">CvType</span>.<span class="type">CV_64FC1</span>)</span><br><span class="line">    gch.convertTo(gch, <span class="type">CvType</span>.<span class="type">CV_64FC1</span>)</span><br><span class="line">    rch.convertTo(rch, <span class="type">CvType</span>.<span class="type">CV_64FC1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mean = <span class="keyword">new</span> <span class="type">MatOfDouble</span>()</span><br><span class="line">    <span class="keyword">val</span> std = <span class="keyword">new</span> <span class="type">MatOfDouble</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">Core</span>.meanStdDev(bch, mean, std)</span><br><span class="line">    <span class="keyword">val</span> bchArray: <span class="type">Array</span>[<span class="type">Double</span>] = <span class="type">Array</span>(mean.toList.asScala.head, std.toList.asScala.head, cal3rdmoment(bch))</span><br><span class="line"></span><br><span class="line">    <span class="type">Core</span>.meanStdDev(gch, mean, std)</span><br><span class="line">    <span class="keyword">val</span> gchArray: <span class="type">Array</span>[<span class="type">Double</span>] = <span class="type">Array</span>(mean.toList.asScala.head, std.toList.asScala.head, cal3rdmoment(gch))</span><br><span class="line"></span><br><span class="line">    <span class="type">Core</span>.meanStdDev(rch, mean, std)</span><br><span class="line">    <span class="keyword">val</span> rchArray: <span class="type">Array</span>[<span class="type">Double</span>] = <span class="type">Array</span>(mean.toList.asScala.head, std.toList.asScala.head, cal3rdmoment(rch))</span><br><span class="line"></span><br><span class="line">    mean.release()</span><br><span class="line">    std.release()</span><br><span class="line">    bchArray ++ gchArray ++ rchArray</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>随后分别给训练图片打标，然后使用SVM训练并测试 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run training algorithm to build the model</span></span><br><span class="line">    <span class="keyword">val</span> numIterations = <span class="number">100</span></span><br><span class="line">    <span class="keyword">val</span> model = <span class="type">SVMWithSGD</span>.train(training, numIterations)</span><br><span class="line">    <span class="comment">// Clear the default threshold.</span></span><br><span class="line">    model.clearThreshold()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this is a binary classification</span></span><br><span class="line">    <span class="comment">// Compute raw scores on the test set.</span></span><br><span class="line">    <span class="keyword">val</span> scoreAndLabels = test.map &#123; point =&gt;</span><br><span class="line">      <span class="keyword">val</span> score = model.predict(point.features)</span><br><span class="line">      (score, point.label)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get evaluation metrics.</span></span><br><span class="line">    <span class="keyword">val</span> metrics = <span class="keyword">new</span> <span class="type">BinaryClassificationMetrics</span>(scoreAndLabels)</span><br><span class="line">    <span class="keyword">val</span> auROC = metrics.areaUnderROC()</span><br><span class="line">    println(<span class="string">&quot;Area under ROC = &quot;</span> + auROC)</span><br></pre></td></tr></table></figure> 最终结果如下图 <img src="opencvspark.png" /> 2W张图片训练, 5k张图片测试总共耗时12min，作为一个单机spark运行来说，速度是ok的</p><h2 id="小结">小结</h2><ol type="1"><li>opencv功能强大，提供了多种提取图像特征的方法，如果在spark集群环境下使用opencv，需要在每个节点上都安装opencv</li><li>在scala或者java中使用opencv要注意主动调用release函数释放资源，否则会有内存泄露的问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统-使用ALS求解LFM模型</title>
      <link href="/2020/05/20/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E4%BD%BF%E7%94%A8ALS%E6%B1%82%E8%A7%A3LFM%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/05/20/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E4%BD%BF%E7%94%A8ALS%E6%B1%82%E8%A7%A3LFM%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>在之前的文章中我曾写到, 用户和物品的交互关系可以是一个稀疏矩阵, 我们把这个矩阵称作评分矩阵<span class="math inline">\(R_{m,n}\)</span>, 比如下面的例子, ? 表示缺失</p><table><thead><tr class="header"><th>user/item</th><th>item_0</th><th>item_1</th><th>item_2</th><th>item_3</th><th>item_4</th></tr></thead><tbody><tr class="odd"><td>user_0</td><td>?</td><td>2</td><td>1</td><td>2</td><td>?</td></tr><tr class="even"><td>user_1</td><td>2</td><td>?</td><td>?</td><td>1</td><td>2</td></tr><tr class="odd"><td>user_2</td><td>?</td><td>1</td><td>1</td><td>2</td><td>?</td></tr><tr class="even"><td>user_3</td><td>1</td><td>?</td><td>?</td><td>1</td><td>3</td></tr></tbody></table><span id="more"></span><p>所以我们有评分矩阵:</p><p><span class="math display">\[ R_{m,n} = \begin{bmatrix}? &amp; 1 &amp; 1 &amp; 2\\2 &amp; ? &amp; ? &amp; 1 \\? &amp; 1 &amp; 1 &amp; 2\end{bmatrix} \]</span></p><h2 id="分解评分矩阵">分解评分矩阵</h2><p>如果对评分矩阵<span class="math inline">\(R\)</span>做低秩矩阵分解（Low Rank Matrix Factorization), 既有<span class="math inline">\(R_{m, n} = P_{m, f} * Q_{n, f}^T\)</span>, 这就引申到LFM (Latent Factor Model) 隐因子模型，其中隐因子可以理解为一个用户喜欢一个商品的隐形原因，比如电影里面有他喜欢的romantic和action元素，还有他喜欢的某个演员或者导演编剧。如果另外一个电影有类似的元素跟演员，那么他很有可能会也喜欢这部电影。LFM的核心思路就是求出用户矩阵<span class="math inline">\(P\)</span>和商品矩阵<span class="math inline">\(Q\)</span>。</p><p>在协同过滤中我们使用item相似度做推荐的核心思想可以用下列公式表达 <span class="math display">\[\begin{equation}\hat{r}_{u,i} = \frac{\sum_{j \in S^k(i,u)} s_{i,j} r_{u, i}}{ \sum_{j \in S^k(i, u)} s_{i, j}} \end{equation}\]</span></p><p>其中<span class="math inline">\(s^k(i, u)\)</span> 代表和物品i最相似的, 并且被用户u交互过k个商品，也就是<span class="math inline">\(N(u) \bigcap S(i, k)\)</span>，如果从LFM的角度考虑, 从评分矩阵求得对应的用户矩阵和商品矩阵, 使得<span class="math inline">\(\sum\limits_{r_{u, i}\ is\ knwon}(r_{ui} - p_u^Tq_i)^2\)</span> 最小, 那么我们就可以用<span class="math inline">\(P*Q\)</span> 来代替评分矩阵从而填充了那些缺失的评分值。</p><h2 id="als交替最小二乘法">ALS交替最小二乘法</h2><p><span class="math display">\[\begin{equation}\min \limits_{p*, q*} \sum\limits_{r_{u, i}\ is\ knwon}(r_{ui} -p_u^Tq_i)^2 + \lambda(||p_u||^2 + ||q_i||^2)\end{equation}\]</span></p><p>下面就是对上述公式求解使用ALS算法求解<span class="math inline">\(P,Q\)</span>矩阵。查阅了一些网上的教程，可以直接化简为一般性的线性回归问题，对于<span class="math inline">\(\mathbf{X}\theta-\mathbf{Y}\)</span>, <span class="math inline">\(\theta\)</span>的解析解为 <span class="math inline">\(\theta=(\mathbf{X}^T\mathbf{X}+\lambda\mathbf{I})^{-1}\mathbf{X}^TY\)</span>, 同理对于<span class="math inline">\(\mathbf{R}-\mathbf{X}^T\mathbf{Y}\)</span>, 当固定<span class="math inline">\(\mathbf{X}\)</span>时, <span class="math inline">\(\mathbf{Y}=(\mathbf{X}\mathbf{X}^T+\lambda\mathbf{I})*\mathbf{X}*\mathbf{R}\)</span>, 当固定<span class="math inline">\(\mathbf{Y}\)</span>时，<span class="math inline">\(\mathbf{X}=(\mathbf{Y}\mathbf{Y}^T+\lambda\mathbf{I})*\mathbf{Y}*\mathbf{R}^T\)</span></p><p>但是，我对以上做法持保留意见，在迭代过程中并没有发现RMSE随迭代减小。随后我阅读了原始的<a href="https://endymecy.gitbooks.io/spark-ml-source-analysis/content/%E6%8E%A8%E8%8D%90/papers/Large-scale%20Parallel%20Collaborative%20Filtering%20the%20Netflix%20Prize.pdf">文献</a>, 我觉得对于缺失的评分值不应该加入运算,，只会考虑有评分值得情况所对应的线性回归问题。</p><p>假设现在有一个稀疏矩阵<span class="math inline">\(R\)</span>,以及对应的<span class="math inline">\(M\)</span>, <span class="math inline">\(N\)</span>，稀疏矩阵每次按列计算，并且只计算对应值得矩阵, 如公式<span class="math inline">\(\ref{eq3}\)</span>所示，稀疏矩阵<span class="math inline">\(R\)</span>第<span class="math inline">\(0\)</span>列只在<span class="math inline">\(0\)</span>行和<span class="math inline">\(2\)</span>行有值, 那么我们取矩阵<span class="math inline">\(M\)</span>的<span class="math inline">\(0\)</span>和<span class="math inline">\(2\)</span>行，计算线性回归<span class="math inline">\(M_{0,2}\theta_0 - R^{0}\)</span>，可以利用正规方程法或者梯度下降法求解<span class="math inline">\(\theta_0\)</span>，也就是<span class="math inline">\(N\)</span>矩阵的第<span class="math inline">\(0\)</span>行, 直到求出所有的矩阵<span class="math inline">\(N\)</span>的向量。然后再将<span class="math inline">\(N\)</span>固定，此时注意维度的统一需要将<span class="math inline">\(R\)</span>转置, 求得<span class="math inline">\(M\)</span>, 如此循环往复。</p><p><span class="math display">\[\begin{equation}\label{eq3}\begin{split}  R &amp;= \begin{array}{cc}   &amp; \begin{matrix} 0&amp;1&amp;2&amp;3&amp;4\end{matrix}\\  \begin{matrix}  0\\  1 \\  2 \\  3  \end{matrix} &amp; \begin{bmatrix}X&amp; &amp; X &amp; &amp;X \\  &amp; X&amp; X&amp; X&amp;\\  X&amp; X&amp; &amp; X&amp; \\  &amp; &amp; X&amp; X&amp; \end{bmatrix}  \end{array}\\\\M &amp;= \begin{matrix}&amp; k \\m &amp; \begin{bmatrix} ---\\---\\---\\---\\\end{bmatrix}\end{matrix} \\\\N &amp;= \begin{matrix}&amp; k \\n &amp; \begin{bmatrix} ---\\---\\---\\---\\---\\\end{bmatrix}\end{matrix}\end{split}\end{equation}\]</span></p><h2 id="使用python实现als">使用python实现ALS</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rmse</span>(<span class="params">M, N, R</span>):</span><br><span class="line">    a = np.matmul(M, N.T)</span><br><span class="line">    idx = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], x[<span class="number">1</span>]), R))</span><br><span class="line">    aa = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:a[x[<span class="number">0</span>]][x[<span class="number">1</span>]], idx))</span><br><span class="line">    r = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="number">2</span>], R))</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(((np.array(aa) - np.array(r))**<span class="number">2</span>).<span class="built_in">sum</span>()/<span class="built_in">len</span>(R))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sparse_matrix</span>():</span><br><span class="line">    r = [(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">         (<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>),</span><br><span class="line">         (<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>, <span class="number">5</span>, r</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sparse_matrix_transpos</span>(<span class="params">l, r, mat</span>):</span><br><span class="line">    m = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: (x[<span class="number">1</span>], x[<span class="number">0</span>], x[<span class="number">2</span>]), mat))</span><br><span class="line">    <span class="keyword">return</span> r, l, m</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initial</span>(<span class="params">m, n, k</span>):</span><br><span class="line">    <span class="keyword">return</span> np.random.rand(m, k), np.random.rand(n, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">als</span>(<span class="params">M, N, l, r, R, lam=<span class="number">0.01</span></span>):</span><br><span class="line">    res =[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r):</span><br><span class="line">        mat = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x[<span class="number">1</span>] == i, R))</span><br><span class="line">        y = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="number">2</span>], mat))</span><br><span class="line">        idx = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="number">0</span>], mat))</span><br><span class="line">        x = np.array(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: M[x], idx)))</span><br><span class="line">        theta = np.matmul(np.matmul(np.linalg.inv(np.matmul(x.T, x) + lam*np.eye(M.shape[<span class="number">1</span>])), x.T), y)</span><br><span class="line">        res.append(theta)</span><br><span class="line"></span><br><span class="line">    NN = np.array(res)</span><br><span class="line">    RR = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: (x[<span class="number">1</span>], x[<span class="number">0</span>], x[<span class="number">2</span>]), R))</span><br><span class="line">    Res = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">        mat = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x[<span class="number">1</span>] == j, RR))</span><br><span class="line">        y = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="number">2</span>], mat))</span><br><span class="line">        idx = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="number">0</span>], mat))</span><br><span class="line">        x = np.array(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: NN[x], idx)))</span><br><span class="line">        theta = np.matmul(np.matmul(np.linalg.inv(np.matmul(x.T, x) + lam * np.eye(NN.shape[<span class="number">1</span>])), x.T), y)</span><br><span class="line">        Res.append(theta)</span><br><span class="line">    MM = np.array(Res)</span><br><span class="line">    <span class="keyword">return</span> MM, NN</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterALS</span>(<span class="params">R, <span class="built_in">iter</span>=<span class="number">10</span></span>):</span><br><span class="line">    it = <span class="number">0</span></span><br><span class="line">    M, N = initial(<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">    rmse_res = []</span><br><span class="line">    <span class="keyword">while</span>(it &lt; <span class="built_in">iter</span>):</span><br><span class="line">        M, N = als(M, N, <span class="number">4</span>, <span class="number">5</span>, R) <span class="comment"># als(M, N, l, r, R, lam=0.1)</span></span><br><span class="line">        rmse_val = rmse(M, N, R)</span><br><span class="line">        rmse_res.append(rmse_val)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;iter = %d&quot;</span>%it, <span class="string">&quot;RMSE = %f&quot;</span>%rmse_val)</span><br><span class="line">        it += <span class="number">1</span></span><br><span class="line">    plot_acc_loss(rmse_res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_acc_loss</span>(<span class="params">loss</span>):</span><br><span class="line">    plt.figure(<span class="string">&quot;rmse&quot;</span>)</span><br><span class="line">    plt.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(loss)), loss, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    m, n, mat = get_sparse_matrix()</span><br><span class="line">    iterALS(mat, <span class="built_in">iter</span>=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>RMSE如下图: <img src="rmse.png" /></p><h2 id="利用spark计算als">利用spark计算ALS</h2><p>鉴于评分矩阵的稀疏性, 我们同样可以借助spark来计算，具体代码如下 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.&#123;<span class="type">Level</span>, <span class="type">Logger</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"><span class="keyword">import</span> breeze.linalg._</span><br><span class="line"><span class="keyword">import</span> breeze.numerics._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Als</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> spark: <span class="type">SparkSession</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> conf: <span class="type">SparkConf</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> sc: <span class="type">SparkContext</span> = _</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 随机初始化 M， N</span></span><br><span class="line"><span class="comment">    * @param m</span></span><br><span class="line"><span class="comment">    * @param n</span></span><br><span class="line"><span class="comment">    * @param k</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initial</span></span>(m:<span class="type">Int</span>, n:<span class="type">Int</span>, k:<span class="type">Int</span>) =&#123;</span><br><span class="line">      <span class="keyword">val</span> <span class="type">M</span> = sc.parallelize((<span class="number">0</span> until m ).map(x =&gt; (x, <span class="type">DenseVector</span>.rand(k))))</span><br><span class="line">      <span class="keyword">val</span> <span class="type">N</span> = sc.parallelize((<span class="number">0</span> until n ).map(x =&gt; (x, <span class="type">DenseVector</span>.rand(k))))</span><br><span class="line">    (<span class="type">M</span>, <span class="type">N</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getRatingMatrix</span></span>() =&#123;</span><br><span class="line">    <span class="keyword">val</span> mR = sc.parallelize(<span class="type">List</span>((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>),</span><br><span class="line">    (<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>)).map(x =&gt; (x._1, x._2, x._3.toDouble)))</span><br><span class="line">    <span class="keyword">val</span> nR = mR.map(t =&gt; (t._2, t._1, t._3))</span><br><span class="line">    (mR.cache(), nR.cache())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计算稀疏矩阵的rmse</span></span><br><span class="line"><span class="comment">    * @param M</span></span><br><span class="line"><span class="comment">    * @param N</span></span><br><span class="line"><span class="comment">    * @param mR</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">rmse</span></span>(<span class="type">M</span>:<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">DenseVector</span>[<span class="type">Double</span>])], <span class="type">N</span>:<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">DenseVector</span>[<span class="type">Double</span>])], mR:<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Double</span>)])=&#123;</span><br><span class="line">     <span class="keyword">val</span> errRDD = mR.map(x =&gt; (x._1, (x._2, x._3))).aggregateByKey(<span class="type">List</span>.empty[(<span class="type">Int</span>, <span class="type">Double</span>)])(_:+_, _++_)</span><br><span class="line">      .join(<span class="type">M</span>).map(x =&gt; (x._2._1, x._2._2)).flatMap(t =&gt; t._1.map(x =&gt; (x._1, (t._2, x._2))))</span><br><span class="line">      .join(<span class="type">N</span>).map(x =&gt; (x._2._1._1, x._2._2, x._2._1._2)) <span class="comment">// mVect, nVec, r</span></span><br><span class="line"></span><br><span class="line">    sqrt(errRDD.map(x =&gt; x._1.t * x._2 - x._3).map( x =&gt; pow(x, <span class="number">2</span>)).sum() / errRDD.count())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 规定维度约束 M * N.t = mR 或者 N * M.t= nR</span></span><br><span class="line"><span class="comment">    * @param M</span></span><br><span class="line"><span class="comment">    * @param N</span></span><br><span class="line"><span class="comment">    * @param mR</span></span><br><span class="line"><span class="comment">    * @param nR</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">als</span></span>(<span class="type">M</span>:<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">DenseVector</span>[<span class="type">Double</span>])], <span class="type">N</span>:<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">DenseVector</span>[<span class="type">Double</span>])],</span><br><span class="line">          mR:<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Double</span>)], nR:<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Double</span>)]) =&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> <span class="type">NN</span> = mR.map(x =&gt; (x._1, (x._2, x._3))).join(<span class="type">M</span>).map(x =&gt; (x._2._1, x._2._2))</span><br><span class="line">      .map(x =&gt; (x._1._1, (x._2, x._1._2)))</span><br><span class="line">      .aggregateByKey(<span class="type">List</span>.empty[(<span class="type">DenseVector</span>[<span class="type">Double</span>], <span class="type">Double</span>)])(_:+_, _++_)</span><br><span class="line">      .map&#123;x =&gt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> matrixX = <span class="keyword">new</span> <span class="type">DenseMatrix</span>[<span class="type">Double</span>](x._2.length, x._2.head._1.length)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> matX = x._2.foldLeft((matrixX, <span class="number">0</span>))(  (z, t) =&gt; &#123; z._1(z._2,:: ):=t._1.t</span><br><span class="line">          (z._1, z._2+<span class="number">1</span>)&#125;)._1</span><br><span class="line">         <span class="keyword">val</span> vecY = <span class="keyword">new</span> <span class="type">DenseVector</span>(x._2.map(_._2).toArray)</span><br><span class="line">        (x._1, inv(matX.t * matX + <span class="number">0.01</span>) * matX.t * vecY)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> <span class="type">MM</span> = nR.map(x =&gt; (x._1, (x._2, x._3))).join(<span class="type">NN</span>).map(x =&gt; (x._2._1, x._2._2))</span><br><span class="line">      .map(x =&gt; (x._1._1, (x._2, x._1._2)))</span><br><span class="line">      .aggregateByKey(<span class="type">List</span>.empty[(<span class="type">DenseVector</span>[<span class="type">Double</span>], <span class="type">Double</span>)])(_:+_, _++_)</span><br><span class="line">      .map&#123;x =&gt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> matrixX = <span class="keyword">new</span> <span class="type">DenseMatrix</span>[<span class="type">Double</span>](x._2.length, x._2.head._1.length)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> matX = x._2.foldLeft((matrixX, <span class="number">0</span>))(  (z, t) =&gt; &#123; z._1(z._2,:: ):=t._1.t</span><br><span class="line">          (z._1, z._2+<span class="number">1</span>)&#125;)._1</span><br><span class="line">        <span class="keyword">val</span> vecY = <span class="keyword">new</span> <span class="type">DenseVector</span>(x._2.map(_._2).toArray)</span><br><span class="line">        (x._1, inv(matX.t * matX + <span class="number">0.1</span>) * matX.t * vecY)</span><br><span class="line">      &#125;</span><br><span class="line">    (<span class="type">MM</span>, <span class="type">NN</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">iterALS</span></span>(<span class="type">M</span>:<span class="type">RDD</span>[(<span class="type">Int</span>,<span class="type">DenseVector</span>[<span class="type">Double</span>])], <span class="type">N</span>:<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">DenseVector</span>[<span class="type">Double</span>])],</span><br><span class="line">              mR:<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Double</span>)], nR:<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Double</span>)], iter:<span class="type">Int</span> = <span class="number">10</span>)=&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rmse_list =<span class="type">ArrayBuffer</span>.empty[(<span class="type">Int</span>, <span class="type">Double</span>)]</span><br><span class="line">    <span class="keyword">val</span> res = (<span class="number">0</span> until iter).foldLeft( (<span class="type">M</span>, <span class="type">N</span>, mR, nR))( (z, b) =&gt;&#123;</span><br><span class="line">      <span class="keyword">val</span> res = als(z._1, z._2, z._3, z._4)</span><br><span class="line">      <span class="keyword">val</span> rmseVal = rmse(res._1, res._2, mR)</span><br><span class="line">      rmse_list.append((b, rmseVal))</span><br><span class="line">      (res._1, res._2, mR, nR)</span><br><span class="line">    &#125;)</span><br><span class="line">    rmse_list.foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rootLogger = <span class="type">Logger</span>.getRootLogger()</span><br><span class="line">    rootLogger.setLevel(<span class="type">Level</span>.<span class="type">ERROR</span>)</span><br><span class="line"></span><br><span class="line">    conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[4]&quot;</span>).setAppName(<span class="string">&quot;demo&quot;</span>)</span><br><span class="line">    spark = <span class="type">SparkSession</span>.builder().config(conf)</span><br><span class="line">      .config(<span class="string">&quot;spark.some.config.option&quot;</span>, <span class="string">&quot;some-value&quot;</span>)</span><br><span class="line">      .config(<span class="string">&quot;spark.sql.broadcastTimeout&quot;</span>, <span class="string">&quot;20000&quot;</span>)</span><br><span class="line">      .config(<span class="string">&quot;spark.driver.maxResultSize&quot;</span>, <span class="string">&quot;25g&quot;</span>)</span><br><span class="line">      .config(<span class="string">&quot;spark.sql.shuffle.partitions&quot;</span>, <span class="string">&quot;600&quot;</span>)</span><br><span class="line">      .config(<span class="string">&quot;spark.serializer&quot;</span>, <span class="string">&quot;org.apache.spark.serializer.KryoSerializer&quot;</span>)</span><br><span class="line">      .config(<span class="string">&quot;spark.shuffle.file.buffer.kb&quot;</span>, <span class="string">&quot;10240&quot;</span>)</span><br><span class="line">      .config(<span class="string">&quot;spark.storage.memoryFraction&quot;</span>, <span class="string">&quot;0.2&quot;</span>)</span><br><span class="line">      .config(<span class="string">&quot;spark.shuffle.memoryFraction&quot;</span>, <span class="string">&quot;0.6&quot;</span>)</span><br><span class="line">      .config(<span class="string">&quot;spark.sql.crossJoin.enabled&quot;</span>, <span class="string">&quot;true&quot;</span>).getOrCreate()</span><br><span class="line"></span><br><span class="line">    spark.sparkContext.setLogLevel(<span class="string">&quot;ERROR&quot;</span>)</span><br><span class="line">    sc = spark.sparkContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> initMatrix = initial(<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> <span class="type">M</span> = initMatrix._1</span><br><span class="line">    <span class="keyword">val</span> <span class="type">N</span> = initMatrix._2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> <span class="type">R</span>= getRatingMatrix()</span><br><span class="line">    <span class="keyword">val</span> mR = <span class="type">R</span>._1</span><br><span class="line">    <span class="keyword">val</span> nR = <span class="type">R</span>._2</span><br><span class="line"></span><br><span class="line">    iterALS(<span class="type">M</span>, <span class="type">N</span>, mR, nR)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 需要计算的向量会join在一起, 如果两个分解的矩阵不大的话，还可以作为广播变量进一步提高效率。其中的线性回归部分借助breeze包，方法依然是正规方程法。可以替换用梯度下降法。每次迭代的RMSE如下:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(iter:0,rmse = 0.376204)</span><br><span class="line">(iter:1,rmse = 0.126822)</span><br><span class="line">(iter:2,rmse = 0.061821)</span><br><span class="line">(iter:3,rmse = 0.047608)</span><br><span class="line">(iter:4,rmse = 0.042685)</span><br><span class="line">(iter:5,rmse = 0.039862)</span><br><span class="line">(iter:6,rmse = 0.037896)</span><br><span class="line">(iter:7,rmse = 0.036419)</span><br><span class="line">(iter:8,rmse = 0.035267)</span><br><span class="line">(iter:9,rmse = 0.034347)</span><br></pre></td></tr></table></figure><h2 id="小结">小结</h2><ol type="1"><li>ALS算法本质上也就是线性回归，但是要注意因为稀疏矩阵的存在导致参与计算的只有部分向量。</li><li>单机可以处理的情况推荐使用正规方程法，对于更大规模的数据可以使用梯度下降法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据--spark-streaming开发总结</title>
      <link href="/2020/05/16/%E5%A4%A7%E6%95%B0%E6%8D%AE-spark-streaming%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/16/%E5%A4%A7%E6%95%B0%E6%8D%AE-spark-streaming%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>spark streaming 和 Apache Storm、Apache Flink同属于大数据实时处理框架 spark streaming的流式处理是一种基于micro-batch的想法， 这篇文章会讲解 Spark Streaming 两种计算模型，无状态和状态计算模型以及该两种模型的注意事项，最后将小结一下Spark Streaming 的优缺点。</p><h2 id="概述">概述</h2><p>根据其官方文档介绍，Spark Streaming 有高扩展性、高吞吐量和容错能力强的特点。Spark Streaming 支持的数据输入源很多，例如：Kafka、Flume、Twitter、ZeroMQ 和简单的 TCP 套接字等等。原生支持常用的spark transform操作如：map、reduce、join、window 等进行运算。而结果有多种方式sink。并且可以和已有的spark MLlib完美衔接。其优秀的特点使用于多种业务场景，比如监控，网页点击、实时推荐等 <span id="more"></span> <img src="skeleton.jpeg" /></p><h2 id="应用场景">应用场景</h2><p>基于micro-batch思想的流式处理, 处理数据的单位是一批而不是单条，而数据采集却是逐条进行的，因此 Spark Streaming 系统需要设置间隔使得数据汇总到一定的量后再一并操作，这个间隔就是批处理间隔。批处理间隔是 Spark Streaming 的核心概念和关键参数，它决定了 Spark Streaming 提交作业的频率和数据处理的延迟，同时也影响着数据处理的吞吐量和性能。 <img src="process_skeleton.jpeg" /></p><p>spark streaming有两种获取数据的模式</p><ol type="1"><li><strong>基于Receiver的方式</strong></li></ol><p>这种方式使用Receiver来获取数据。Receiver是使用Kafka的高层次Consumer API来实现的。receiver从Kafka中获取的数据都是存储在Spark Executor的内存中的，然后Spark Streaming启动的job会去处理那些数据。在默认的配置下，这种方式可能会因为底层的失败而丢失数据。如果要启用高可靠机制，让数据零丢失，就必须启用Spark Streaming的预写日志机制（Write Ahead Log，WAL。该机制会同步地将接收到的Kafka数据写入分布式文件系统（比如HDFS）上的预写日志中。所以，即使底层节点出现了失败，也可以使用预写日志中的数据进行恢复。需要注意的要点 &gt; - Kafka中的topic的partition，与Spark中的RDD的partition是没有关系的。所以，在KafkaUtils.createStream()中，提高partition的数量，只会增加一个Receiver中，读取partition的线程的数量。不会增加Spark处理数据的并行度。</p><blockquote><ul><li>可以创建多个Kafka输入DStream，使用不同的consumer group和topic，来通过多个receiver并行接收数据。</li></ul></blockquote><blockquote><ul><li>如果基于容错的文件系统，比如HDFS，启用了预写日志机制，接收到的数据都会被复制一份到预写日志中。因此，在KafkaUtils.createStream()中，设置的持久化级别是StorageLevel.MEMORY_AND_DISK_SER。</li></ul></blockquote><ol start="2" type="1"><li><strong>基于Direct的方式</strong></li></ol><p>这种新的不基于Receiver的直接方式，是在Spark 1.3中引入的，从而能够确保更加健壮的机制。替代掉使用Receiver来接收数据后，这种方式会周期性地查询Kafka，来获得每个topic+partition的最新的offset，从而定义每个batch的offset的范围。当处理数据的job启动时，就会使用Kafka的简单consumer api来获取Kafka指定offset范围的数据。Direct方式的优点:</p><blockquote><ul><li>简化并行读取：如果要读取多个partition，不需要创建多个输入DStream然后对它们进行union操作。 Spark会创建跟Kafka partition一样多的RDD partition，并且会并行从Kafka中读取数据。所以在Kafka partition和RDD partition之间，有一个一对一的映射关系。</li></ul></blockquote><blockquote><ul><li>高性能：如果要保证零数据丢失，在基于receiver的方式中，需要开启WAL机制。这种方式其实效率低下， 因为数据实际上被复制了两份，Kafka自己本身就有高可靠的机制，会对数据复制一份，而这里又会复制一份到WAL中。而基于direct的方式，不依赖Receiver，不需要开启WAL机制，只要Kafka中作了数据的复制，那么就可以通过Kafka的副本进行恢复。</li></ul></blockquote><blockquote><ul><li>一次且仅一次的事务机制： 基于receiver的方式，是使用Kafka的高阶API来在ZooKeeper中保存消费过的offset的。这是消费Kafka数据的传统方式。 这种方式配合着WAL机制可以保证数据零丢失的高可靠性，但是却无法保证数据被处理一次且仅一次，可能会处理两次。因为Spark和ZooKeeper之间可能是不同步的。</li></ul></blockquote><blockquote><ul><li>降低资源。  Direct不需要Receivers，其申请的Executors全部参与到计算任务中；而Receiver-based则需要专门的Receivers来读取Kafka数据且不参与计算。因此相同的资源申请，Direct 能够支持更大的业务。</li></ul></blockquote><blockquote><ul><li>降低内存。  Receiver-based的Receiver与其他Exectuor是异步的，并持续不断接收数据，对于小业务量的场景还好，如果遇到大业务量时，需要提高Receiver的内存，但是参与计算的Executor并无需那么多的内存。 而Direct 因为没有Receiver，而是在计算时读取数据，然后直接计算，所以对内存的要求很低。实际应用中我们可以把原先的10G降至现在的2-4G左右。</li></ul></blockquote><blockquote><ul><li>鲁棒性更好。  Receiver-based方法需要Receivers来异步持续不断的读取数据，因此遇到网络、存储负载等因素，导致实时任务出现堆积，但Receivers却还在持续读取数据，此种情况很容易导致计算崩溃。 Direct 则没有这种顾虑，其Driver在触发batch 计算任务时，才会读取数据并计算。队列出现堆积并不会引起程序的失败。 基于direct的方式，使用kafka的简单api，Spark Streaming自己就负责追踪消费的offset，并保存在checkpoint中。Spark自己一定是同步的，因此可以保证数据是消费一次且仅消费一次。</li></ul></blockquote><h3 id="无状态模型">无状态模型</h3><p>无状态模型只关注当前新生成的 DStream 数据，所以的计算逻辑均基于该批次的数据进行处理。无状态模型能够很好地适应一些应用场景，比如网站点击实时排行榜、指定 batch 时间段的用户访问以及点击情况等。该模型由于没有状态，并不需要考虑有状态的情况，只需要根据业务场景保证数据不丢就行。此种情况一般采用 Direct 方式读取 Kafka 数据，并采用监听器方式持久化 Offsets 即可。具体流程如下 <img src="unstateful.jpeg" /> 包括如下几个步骤 - 读取数据 - Transformation 和 Action操作 - sink操作(数据持久化) 无状态模型下如果程序出现长时间失败，根据业务具体要求选择从之前Kafka offset处消费或者从kafka largest处消费</p><h3 id="状态模型">状态模型</h3><p>状态模型是指 DStreams 在指定的时间范围内有依赖关系，具体的时间范围由业务场景来指定，可以是 2 个及以上的多个 batch time RDD 组成。Spark Streaming 提供了 updateStateByKey 方法来满足此类的业务场景。因涉及状态的问题，所以在实际的计算过程中需要保存计算的状态，Spark Streaming通过 checkpoint 来保存计算的元数据以及计算的进度。在有状态流式处理下，满足以下任意一个条件需要开启checkpoingting - 使用了stateful转换 如果 application 中使用了updateStateByKey或reduceByKeyAndWindow等 stateful 操作，必须提供checkpoint目录来允许定时的RDD checkpoint - 希望能从意外中恢复 driver 如果 streaming app 没有 stateful 操作，也允许 driver 挂掉后再次重启的进度丢失，就没有启用 checkpoint的必要了。 需要注意的是，随着 streaming application 的持续运行，checkpoint 数据占用的存储空间会不断变大。因此，需要小心设置checkpoint 的时间间隔。设置得越小，checkpoint 次数会越多，占用空间会越大；如果设置越大，会导致恢复时丢失的数据和进度越多。一般推荐设置为 batch duration 的5~10倍。</p><h3 id="checkpoint">checkpoint</h3><ul><li><p><strong>checkpoint的形式</strong> 最终 checkpoint 的形式是将类 Checkpoint的实例序列化后写入外部存储，值得一提的是，有专门的一条线程来做将序列化后的 checkpoint 写入外部存储。类 Checkpoint 包含以下数据 <img src="checkpoint.png" /></p></li><li><p><strong>Checkpoint 的局限</strong> Spark Streaming 的 checkpoint 机制看起来很美好，却有一个硬伤。上文提到最终刷到外部存储的是类 Checkpoint 对象序列化后的数据。那么在 Spark Streaming application 重新编译后，再去反序列化 checkpoint 数据就会失败。这个时候就必须新建 StreamingContext。</p></li></ul><p>针对这种情况，在我们结合 Spark Streaming + kafka 的应用中，我们自行维护了消费的 offsets，这样一来即使重新编译 application，还是可以从需要的 offsets 来消费数据，这种方法应该是比较好的方法</p><h2 id="spark反压机制详解">spark反压机制详解</h2><h3 id="背景">背景</h3><p>对于基于Receiver 形式，我们可以通过配置 spark.streaming.receiver.maxRate 参数来限制每个 receiver 每秒最大可以接收的记录的数据；对于 Direct Approach 的数据接收，我们可以通过配置 spark.streaming.kafka.maxRatePerPartition 参数来限制每次作业中每个 Kafka 分区最多读取的记录条数。</p><p>默认情况下，Spark Streaming通过Receiver以生产者生产数据的速率接收数据，计算过程中会出现batch processing time &gt; batch interval的情况，其中batch processing time 为实际计算一个批次花费时间， batch interval为Streaming应用设置的批处理间隔。这意味着Spark Streaming的数据接收速率高于Spark从队列中移除数据的速率，也就是数据处理能力低，在设置间隔内不能完全处理当前接收速率接收的数据。如果这种情况持续过长的时间，会造成数据在内存中堆积，导致Receiver所在Executor内存溢出等问题（如果设置StorageLevel包含disk, 则内存存放不下的数据会溢写至disk, 加大延迟）。Spark 1.5以前版本，用户如果要限制Receiver的数据接收速率，可以通过设置静态配制参数“spark.streaming.receiver.maxRate”的值来实现，此举虽然可以通过限制接收速率，来适配当前的处理能力，防止内存溢出，但也会引入其它问题。比如：producer数据生产高于maxRate，当前集群处理能力也高于maxRate，这就会造成资源利用率下降等问题。为了更好的协调数据接收速率与资源处理能力，Spark Streaming 从v1.5开始引入反压机制（back-pressure）,通过动态控制数据接收速率来适配集群数据处理能力。</p><p>当Spark Streaming与Kafka使用Direct API集群时，我们可以很方便的去控制最大数据摄入量--通过一个被称作spark.streaming.kafka.maxRatePerPartition的参数。根据文档描述，他的含义是：Direct API读取每一个Kafka partition数据的最大速率（每秒读取的消息量）。 配置项spark.streaming.kafka.maxRatePerPartition，对防止流式应用在下边两种情况下出现流量过载时尤其重要：</p><ol type="1"><li><p>Kafka Topic中有大量未处理的消息，并且我们设置是Kafka auto.offset.reset参数值为smallest，他可以防止第一个批次出现数据流量过载情况。</p></li><li><p>当Kafka 生产者突然飙升流量的时候，他可以防止批次处理出现数据流量过载情况。</p></li></ol><p>但是，配置Kafka每个partition每批次最大的摄入量是个静态值，也算是个缺点。随着时间的变化，在生产环境运行了一段时间的Spark Streaming应用，每批次每个Kafka partition摄入数据最大量的最优值也是变化的。有时候，是因为消息的大小会变，导致数据处理时间变化。有时候，是因为流计算所使用的多租户集群会变得非常繁忙，比如在白天时候，一些其他的数据应用（例如Impala/Hive/MR作业）竞争共享的系统资源时（CPU/内存/网络/磁盘IO）。</p><p>这种限速的弊端很明显，比如假如我们后端处理能力超过了这个最大的限制，会导致资源浪费。需要对每个spark Streaming任务进行压测预估。成本比较高。为了Spark Streaming应用能在生产中稳定、有效的执行，每批次数据处理时间（批处理时间）必须非常接近批次调度的时间间隔（批调度间隔），并且要一直低于批调度间隔。如果批处理时间一直高于批调度间隔，调度延迟就会一直增长并且不会恢复。最终，Spark Streaming应用会变得不再稳定。另一方面，如果批处理时间长时间远小于批调度间隔，就会浪费集群资源。</p><p>由此，从1.5开始引入了back pressure，这种机制呢实际上是基于自动控制理论的pid这个概念。我们就简单讲一下其中思路：为了实现自动调节数据的传输速率，在原有的架构上新增了一个名为 RateController 的组件，这个组件继承自 StreamingListener，其监听所有作业的 onBatchCompleted 事件，并且基于 processingDelay 、schedulingDelay 、当前 Batch 处理的记录条数以及处理完成事件来估算出一个速率；这个速率主要用于更新流每秒能够处理的最大记录的条数。这样就可以实现处理能力好的话就会有一个较大的最大值，处理能力下降了就会生成一个较小的最大值。来保证Spark Streaming流畅运行。</p><h3 id="背压机制">背压机制</h3><p>为了开启背压机制，需要设置sparkConf.set(&quot;spark.streaming.backpressure.enabled&quot;,”true”)</p><ol type="1"><li>设置一个batch RDD中的一个分区的最大消息数, 这个数值可以是最优估计值的1.5到2倍</li><li>开启背压 会自动调节读取的message数 所以需要我们对于一个最优的估计值要有认识(基于现有逻辑以及kafka峰值)</li></ol><p>spark streamning的处理能力受到两方面因素影响</p><ol type="1"><li>kafka的生产消息能力</li><li>在一个batch time之间的处理数据的能力 所以中间需要一个背压机制(本质是一个PID控制器)来调节 确保RDD在一个batch time内全部执行完 不产生积压(通过少读取kafka消息来实现)</li></ol><p>那应用启动后的第一个批次流量怎么控制呢？因为他没有前面批次的数据处理时间，所以没有参考的数据去评估这一批次最优的摄入量。在Spark官方文档中有个被称作spark.streaming.backpressure.initialRate的配置，看起来是控制开启背压机制时初始化的摄入量。其实不然，该参数只对receiver模式起作用，并不适用于direct模式。推荐的方法是使用spark.streaming.kafka.maxRatePerPartition控制背压机制起作用前的第一批次数据的最大摄入量。我通常建议设置spark.streaming.kafka.maxRatePerPartition的值为最优估计值的1.5到2倍，让背压机制的算法去调整后续的值。请注意，spark.streaming.kafka.maxRatePerPartition的值会一直控制最大的摄入量，所以背压机制的算法值不会超过他。   另一个需要注意的是，在第一个批次处理完成前，紧接着的批次都将使用spark.streaming.kafka.maxRatePerPartition的值作为摄入量。我们通过Spark UI可以看到，批次间隔为5s，当批次调度延迟31秒时候，前7个批次的摄入量是20条记录。直到第八个批次，背压机制起作用时，摄入量变为5条记录。</p><h2 id="spark-streaming-小结">Spark Streaming 小结</h2><p>Spark-Streaming获取kafka数据的两种方式-Receiver与Direct的方式，可以从代码中简单理解成Receiver方式是通过zookeeper来连接kafka队列，Direct方式是直接连接到kafka的节点上获取数据了。</p><ul><li><strong>优点</strong></li></ul><ol type="1"><li><p>Spark Streaming 基于 Spark Core API，因此其能够与 Spark 中的其他模块保持良好的兼容性，为编程提供了良好的可扩展性;</p></li><li><p>Spark Streaming 是粗粒度的准实时处理框架，一次读取完或异步读完之后处理数据，且其计算可基于大内存进行，因而具有较高的吞吐量;</p></li><li><p>Spark Streaming 采用统一的 DAG 调度以及 RDD，因此能够利用其lineage 机制，对实时计算有很好的容错支持;</p></li><li><p>Spark Streaming 的 DStream 是基于 RDD 的在流式数据处理方面的抽象，其 transformations 以及 actions 有较大的相似性，这在一定程度上降低了用户的使用门槛，在熟悉 Spark 之后，能够快速上手 Spark Streaming。</p></li></ol><ul><li><strong>不足</strong></li></ul><ol type="1"><li>Spark Streaming 是准实时的数据处理框架，采用粗粒度的处理方式，当 batch time 到时才会触发计算，这并非像 Storm 那样是纯流式的数据处理方式。此种方式不可避免会出现相应的计算延迟。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据--spark应用性能优化常见错误处理</title>
      <link href="/2020/05/08/%E5%A4%A7%E6%95%B0%E6%8D%AE-spark%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
      <url>/2020/05/08/%E5%A4%A7%E6%95%B0%E6%8D%AE-spark%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>本篇文章会讲述spark应用的性能调优, 针对常见的数据倾斜问题提出了一些解决方案, 以及如何避免Task Not SerializableException错误 <span id="more"></span> ## spark基本结构和原理 Spark架构采用了分布式计算中的Master-Slave模型。Master是对应集群中的含有Master进程的节（ClusterManager），Slave是集群中含有Worker进程的节点。Master作为整个集群的控制器，负责整个集群的正常运行；Worker相当于是计算节点，接收主节点命令与进行状态汇报；Executor负责任务的执行；Client作为用户的客户端负责提交应用，Driver负责控制一个应用的执行 <img src="spark框架.png" /></p><ul><li><p><strong>job</strong> 所谓⼀个job，就是由⼀个 rdd 的 action 触发的动作，可以简 单的理解为，当你需要执⾏行⼀个 rdd 的 action 的时候，会⽣生成⼀个 job。</p></li><li><p><strong>stage</strong> stage 是⼀个 job 的组成单位，就是说，⼀个 job 会被切分成 1 个或 1 个以上的 stage，然后各个 stage 会按照执⾏行顺序依次执行。在⼀个 job 中划分 stage 的⼀个重要依据是是否有 shuflle 发 ⽣ ，也就是是否会发生数据的重组(重新组织数据)。</p></li><li><p><strong>task</strong> 即 stage 下的⼀个任务执⾏行单元，⼀般来说，⼀个 rdd 有多少 个 partition，就会有多少个 task，因为每⼀个 task 只是处理⼀个 partition 上的数据。</p></li></ul><h2 id="数据倾斜">数据倾斜</h2><p>何谓数据倾斜?数据倾斜指的是，并⾏处理的数据集中，某⼀部分(如 Spark 或 Kafka 的⼀个 Partition)的数据显著多于其它部分，从⽽使得该部分的处理速度成为整个数据集处理的瓶颈。 对分布式系统而言，理想情况下，随着系统规模(节点数量)的增加，应用整体耗时线性下降。如果⼀台机器处理⼀批⼤量数据需要120分钟，当机器数量增加到三时，理想的耗时为 120 / 3 = 40 分钟。但是发生数据倾斜时, 任务的执行速度由数据最大的那个任务决定</p><h3 id="如何判断数据倾斜">如何判断数据倾斜</h3><p>下面举了一些常见数据倾斜的现象 1. 绝⼤多数 task 执行得都非常快，但个别 task 执⾏极慢。比如， 总共有 1000 个 task，997 个 task 都在 1 分钟之内执行完了，但是剩余两三个task却要⼀两个小时。这种情况很常见。 2. 原本能够正常执⾏的 Spark 作业，某天突然报出 OOM(内存溢出)异常，观察异常栈，是我们写的业务代码造成的。</p><h3 id="发生数据倾斜的原因">发生数据倾斜的原因</h3><p>数据倾斜的原理很简单:在进⾏ shuffle 的时候，必须将各个节点上相同的 key 拉取到某个节点上的⼀个 task 来进行处理，比如按照 key 进行聚合或 join 等操作。此时如果某个 key 对应的数据量特别大的话，就会发⽣数据倾斜。比如大部分 key 对应10条数据，但是个别 key 却对应了 100 万条数据，那么大部分 task 可能就只会分配到 10 条数据，然后 1 秒钟就运⾏完了。但是个别 task 可能分配到了 100 万数据，要运⾏一两个小时。因此，整个 Spark 作业的运行进度 是由运行时间最长的那个task决定的。</p><h3 id="如何定位数据倾斜">如何定位数据倾斜</h3><p>数据倾斜只会发⽣在 shuffle 过程中。这里给⼤家罗列⼀些常用的并且可能会触发 shuffle 操作的算子:distinct、groupByKey、reduceByKey、aggregateByKey、 join、cogroup、repartition 等。出现数据倾斜时，可能就是你的代码中使用了这些算⼦中的某⼀个所导致的。</p><h2 id="处理数据倾斜的一般方法">处理数据倾斜的一般方法</h2><ol type="1"><li><p>自定义partitioner Spark 在做 Shuffle 时，默认使用 HashPartitioner 对数据进⾏分区，可以使用自定义的 Partitioner，将原本被分配到同⼀个 Task 的不同 Key 分配到不同 Task。</p></li><li><p>聚合类操作使用reducedByKey, 或者先局部聚合 使用reduceBYkey会首先在分区中计算，这样可减少部分shuffle <img src="reducebykey.png" /> 或者通过添加随机数的方式, 先聚合，然后删掉随机数，再次聚合，这样尽可能保证shuffle后的每个分区内的数据不会过多</p></li><li><p>join操作可以使用广播变量或者增容 在做join关联时，如果其中一个RDD较小，那么建议直接做为广播变量使用, 如果两个RDD都很大, 并且存在数据倾斜(Key分布不均)，可以对其中一个RDD中的key添加随机数0~n，另一个RDD扩容n倍(每个key都对应了n个)，用空间换时间, 减少大规模的shuffle</p></li></ol><h2 id="正确使用spark广播变量">正确使用spark广播变量</h2><p>对于广播变量，尽量避免使用容器嵌套的形式，非常容易导致内存异常，可以先转成字符串(或者其他序列化方式)，再进行传输。</p><p>这里有个按列:</p><p>RDD结构RDD[cookieid, list[obj]] 大小为百万记录, 和另一个RDD[cookieid]需要做关联, 决定采用 广播RDD[cookieid]的方式 过程中分别出现以下问题 1. spark.kryoserializer.buffer.max 设置过小, 广播时需要的buffer 根据实际系列化的对象大小 适当调大 2. Total size of serialized results of 1 tasks (1499.7 MB) is bigger than spark.driver.maxResultSize (1024.0 MB) 由于广播变量是由driver端分发的, 确保driver端的内存设置合适。 3. 由于spark内部采用的kryo版本存在bug 在序列化的列表对象长度超过10亿时会产生 serializing large (&gt; 1 billion) objects may result in a java.lang.NegativeArraySizeException 解决办法是 临时设置 spark.kryo.refferenceTrackingEnabled=false</p><h2 id="spark序列化问题">spark序列化问题</h2><p>spark新手会遇到Task NotSerializableException异常，我也曾被这个报错折磨许久，所以我深入研究了一下导致这个问题的来龙去脉。在谈这个问题之前我们先讨论一个小话题: 什么叫闭包 ### 闭包 借用某位程序员的说法, 闭包就是: 1. 闭包是一个有状态（不消失的私有数据）的函数。 2. 闭包是一个有记忆的函数。 3. 闭包相当于一个只有一个方法的紧凑对象（a compact object) 4. 面这三句话是等价的，而其中第 3 句最精妙，可以指导何时、如何用好闭包，后面我会详细分析。 首先闭包是一种函数, 普通函数如果只有局部变量那么就不会和自由变量有关系, 自由变量就是不受我函数内部控制的 贴一段经典java闭包技术: Java最常用的闭包实现办法:内部类实现通用接口，然后将内部类对象向上转型为接口类型。（内部类+接口） <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;纯牛奶&quot;</span>;<span class="comment">//名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">16</span>;<span class="comment">//数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Milk</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(name+<span class="string">&quot;：16/每箱&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 闭包</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回一个喝牛奶的动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Active <span class="title function_">HaveMeals</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Active</span>()&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;木有了，都被你丫喝完了.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">num--;</span><br><span class="line">System.out.println(<span class="string">&quot;喝掉一瓶牛奶&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取剩余数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">currentNum</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(name+<span class="string">&quot;剩余：&quot;</span>+num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Active</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//买一箱牛奶</span></span><br><span class="line"><span class="type">Milk</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Milk</span>();</span><br><span class="line"><span class="type">Active</span> <span class="variable">haveMeals</span> <span class="operator">=</span> m.HaveMeals();</span><br><span class="line"><span class="comment">//没事喝一瓶</span></span><br><span class="line">haveMeals.drink();</span><br><span class="line"><span class="comment">//有事喝一瓶</span></span><br><span class="line">haveMeals.drink();</span><br><span class="line"><span class="comment">//看看还剩多少？</span></span><br><span class="line">m.currentNum();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 看着还是比较清楚的, 下面我们再来看看scala的闭包实现 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factor = <span class="number">3</span>  </span><br><span class="line"><span class="keyword">val</span> multiplier = (i:<span class="type">Int</span>) =&gt; i * factor  </span><br></pre></td></tr></table></figure> 一个函数对象需要引用到外部变量</p><h3 id="为什么会task-not-serializable">为什么会task not serializable</h3><p>让我来引用databricks官方文档 &gt;org.apache.spark.SparkException: Job aborted due to stage failure: Task not serializable: java.io.NotSerializableException: ...</p><blockquote><p>The above error can be triggered when you intialize a variable on the driver (master), but then try to use it on one of the workers. In that case, Spark Streaming will try to serialize the object to send it over to the worker, and fail if the object is not serializable. Consider the following code snippet: 简单来说, 如果我在worker端使用了driver初始化的变量，需要保证这个对象序列化成功 比如下面的例子: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NotSerializable</span> <span class="variable">notSerializable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotSerializable</span>();</span><br><span class="line">JavaRDD&lt;String&gt; rdd = sc.textFile(<span class="string">&quot;/tmp/myfile&quot;</span>);</span><br><span class="line"></span><br><span class="line">rdd.map(s -&gt; notSerializable.doSomething(s)).collect();</span><br></pre></td></tr></table></figure></p></blockquote><p>官方给出的处理这个错误的方法有以下几种 - Serializable the class  将引用的类做成可序列化的。 - Declare the instance only within the lambda function passed in map. 将依赖的变量放到map、filter等的参数内部定义。这样就可以使用不支持序列化的类； - Make the NotSerializable object as a static and create it once per machine. 将依赖的变量放到静态对象 这样会在每一个jvm中生成一次 - Call rdd.forEachPartition and create the NotSerializable object in there like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rdd.forEachPartition(iter -&gt; &#123;</span><br><span class="line">  <span class="type">NotSerializable</span> <span class="variable">notSerializable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotSerializable</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...Now process iter</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于Spark是分布式执行引擎，其核心抽象是弹性分布式数据集RDD，其代表了分布在不同节点的数据。Spark的计算是在executor上分布式执行的，故用户开发的关于RDD的map，flatMap，reduceByKey等transformation 操作（闭包）有如下执行过程： 1. 代码中对象在driver本地序列化 2. 对象序列化后传输到远程executor节点 3. 远程executor节点反序列化对象 4. 最终远程节点执行 故对象在执行中需要序列化通过网络传输，则必须经过序列化过程。</p><p>我们的解决方法也很直接, 要么类可以序列化, 要么写成成员函数 先看一个<font color=red>错误</font>例子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">NOTworking</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> testing().doIT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//adding extends Serializable wont help</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testing</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)  </span><br><span class="line">  <span class="keyword">val</span> rddList = <span class="type">Spark</span>.ctx.parallelize(list)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">doIT</span> </span>=  &#123;</span><br><span class="line">    <span class="comment">//again calling the fucntion someFunc </span></span><br><span class="line">    <span class="keyword">val</span> after = rddList.map(someFunc(_))</span><br><span class="line">    <span class="comment">//this will crash (spark lazy)</span></span><br><span class="line">    after.collect().map(println(_))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">someFunc</span></span>(a:<span class="type">Int</span>) = a+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以让这个类继承Serializable接口 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkContext</span>,<span class="type">SparkConf</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> ctx = <span class="keyword">new</span> <span class="type">SparkContext</span>(<span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;test&quot;</span>).setMaster(<span class="string">&quot;local[*]&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">NOTworking</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="type">Test</span>().doIT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> rddList = <span class="type">Spark</span>.ctx.parallelize(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">doIT</span></span>() =  &#123;</span><br><span class="line">    <span class="keyword">val</span> after = rddList.map(someFunc)</span><br><span class="line">    after.collect().foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">someFunc</span></span>(a: <span class="type">Int</span>) = a + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 或者</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkContext</span>,<span class="type">SparkConf</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> ctx = <span class="keyword">new</span> <span class="type">SparkContext</span>(<span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;test&quot;</span>).setMaster(<span class="string">&quot;local[*]&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">NOTworking</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="type">Test</span>().doIT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> rddList = <span class="type">Spark</span>.ctx.parallelize(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">doIT</span></span>() =  &#123;</span><br><span class="line">    <span class="keyword">val</span> after = rddList.map(someFunc)</span><br><span class="line">    after.collect().foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> someFunc = (a: <span class="type">Int</span>) =&gt; a + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体可以参考<a href="https://stackoverflow.com/questions/22592811/task-not-serializable-java-io-notserializableexception-when-calling-function-ou">Stack Overflow</a>上的回答。</p><p>下面再举一个例子说明可能会出现Task Not Serializable 依据上述分析的原因，由于依赖了当前类的成员变量，所以导致当前类全部需要序列化，由于当前类某些字段未做好序列化，导致出错。 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span>(<span class="params">conf:<span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> list = <span class="type">List</span>(<span class="string">&quot;a.com&quot;</span>, <span class="string">&quot;www.b.com&quot;</span>, <span class="string">&quot;a.cn&quot;</span>, <span class="string">&quot;a.com.cn&quot;</span>, <span class="string">&quot;a.org&quot;</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;AppName&quot;</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf);</span><br><span class="line">  <span class="keyword">val</span> rdd = sc.parallelize(list);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> rootDomain = conf</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getResult</span></span>(): <span class="type">Array</span>[(<span class="type">String</span>)] = &#123;</span><br><span class="line">    <span class="keyword">val</span> result = rdd.filter(item =&gt; item.contains(rootDomain))</span><br><span class="line">    result.take(result.count().toInt)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如果我们将上述代码改成如下形式 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span>(<span class="params">conf:<span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> list = <span class="type">List</span>(<span class="string">&quot;a.com&quot;</span>, <span class="string">&quot;www.b.com&quot;</span>, <span class="string">&quot;a.cn&quot;</span>, <span class="string">&quot;a.com.cn&quot;</span>, <span class="string">&quot;a.org&quot;</span>);</span><br><span class="line">  <span class="meta">@transient</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;AppName&quot;</span>);</span><br><span class="line">  <span class="meta">@transient</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf);</span><br><span class="line">  <span class="keyword">val</span> rdd = sc.parallelize(list);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> rootDomain = conf</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getResult</span></span>(): <span class="type">Array</span>[(<span class="type">String</span>)] = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = rdd.filter(item =&gt; item.contains(rootDomain))</span><br><span class="line">    result.take(result.count().toInt)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 对类中那些不支持序列化的成员变量标注后，使得整个类能够正常序列化，最终消除Task未序列化问题。</p><h3 id="如何避免task-not-serializable">如何避免task not serializable</h3><p>出现“task not serializable&quot;这个错误，一般是因为在map、filter等的参数使用了外部的变量，但是这个变量不能序列化。特别是当引用了某个类（经常是当前类）的成员函数或变量时，会导致这个类的所有成员（整个类）都需要支持序列化。解决这个问题最常用的方法有： 1. 如果可以，将依赖的变量放到map、filter等的参数内部定义。这样就可以使用不支持序列化的类； 2. 如果可以，将依赖的变量独立放到一个小的class中，让这个class支持序列化；这样做可以减少网络传输量，提高效率； 3. 如果可以，将被依赖的类中不能序列化的部分使用transient关键字修饰，告诉编译器它不需要序列化。 4. 将引用的类做成可序列化的。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统--基于spark graphX的pageRank算法计算冷启动商品</title>
      <link href="/2020/04/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E4%BA%8Espark-graphX%E7%9A%84pageRank%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%86%B7%E5%90%AF%E5%8A%A8%E5%95%86%E5%93%81/"/>
      <url>/2020/04/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E4%BA%8Espark-graphX%E7%9A%84pageRank%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%86%B7%E5%90%AF%E5%8A%A8%E5%95%86%E5%93%81/</url>
      
        <content type="html"><![CDATA[<p>推荐系统需要根据用户的历史行为和兴趣来预测用户将来的行为和兴趣，然而对于很多在开始阶段就希望有个性化推荐应用的网站来说，如何在没有大量用户数据的情况下设计个性化推荐系统并且让用户对网站内容从而愿意继续使用推荐系统就是冷启动问题。 <span id="more"></span></p><h2 id="冷启动问题">冷启动问题</h2><p>冷启动问题可以分为以下三类:</p><ul><li><p><strong>用户冷启动</strong> 用户冷启动主要解决如何给新用户做个性化推荐</p></li><li><p><strong>物品冷启动</strong> 物品冷启动主要解决如何将新物品推荐给可能对其感兴趣的用户</p></li><li><p><strong>系统冷启动</strong> 系统冷启动主要解决在一个新开发的网站上(没有用户，也没有用户行为)设计个性化推荐系统，从而在网站发布时就让用户体验到个性化服务。</p></li></ul><p>针对每一类问题可以有不同的处理方式，比如利用用户注册信息(已知的用户特征)，预测具有某种特征的用户是否喜欢某个商品。但是在实际的应用中，获取的用户注册信息比较少，从用户体验角度出发，一般不会强制用户填写较多的注册信息。这种信息的获取可以依靠第三方的合作来解决，比如facebook广告等。利用商品的内容信息对新物品做有效的个性化推荐。常见的模型有话题模型LDA(Latent Dirichlet Allocation)。</p><h2 id="pagerank算法背景">PageRank算法背景</h2><p>PageRank,即网页排名，又称网页级别、Google左侧排名或佩奇排名。是Google创始人拉里·佩奇和谢尔盖·布林于1997年构建早期的搜索系统原型时提出的链接分析算法，自从Google在商业上获得空前的成功后，该算法也成为其他搜索引擎和学术界十分关注的计算模型。目前很多重要的链接分析算法都是在PageRank算法基础上衍生出来的。PageRank是Google用于用来标识网页的等级/重要性的一种方法，是Google用来衡量一个网站的好坏的唯一标准。在揉合了诸如Title标识和Keywords标识等所有其它因素之后，Google通过PageRank来调整结果，使那些更具“等级/重要性”的网页在搜索结果中另网站排名获得提升，从而提高搜索结果的相关性和质量。其级别从0到10级，10级为满分。PR值越高说明该网页越受欢迎（越重要）。例如：一个PR值为1的网站表明这个网站不太具有流行度，而PR值为7到10则表明这个网站非常受欢迎(或者说极其重要)。</p><h2 id="基于pagerank的图模型">基于PageRank的图模型</h2><p>用户的行为可以用一个二分图模型<span class="math inline">\(G(V,E)\)</span>来表示，其中顶点<span class="math inline">\(V=V_U \cup V_I\)</span> 是由用户顶点和物品顶点组成, 图中的每一条边<span class="math inline">\(e(v_u, v_i)\)</span> 代表了用户u对商品i产生了行为。对于pageRank算法来说，越是重要的顶点，其PR值越高。在用户行为二分图中，给用户u推荐物品的任务可以转化为度量用户顶点和物品顶点在图上的相关性。相关性越高的物品在推荐列表中权重越大。</p><p>度量图中两个顶点之间的相关性有很多方法，但一般来说图中顶点的相关性主要取决于以下三个方面：</p><ul><li>两个顶点之间的路径数</li><li>两个顶点之间的路径长度</li><li>两个顶点之间的路径经过的顶点</li></ul><p>而相关性高的的一对顶点具有如下性质：</p><ul><li>两个定点之间有很多路径相连</li><li>连接两个顶点之间的路径长度都比较短</li><li>连接两个顶点之间的路径不会经过出度比较大的顶点</li></ul><p>基于pagerank的思想，我们会确定一个概率<span class="math inline">\(\alpha\)</span>决定会继续游走, 即以<span class="math inline">\(1-\alpha\)</span>的概率留在当前节点。经过很多次的随机游走，每个顶点的PR值会收敛到一个数。所以我们会得到下面的公式</p><p><span class="math display">\[PR(v) = \begin{cases}\alpha\sum_{v‘ \in in(v)} \frac{PR(v&#39;)}{\left| out(v&#39;) \right|},  &amp; \text{v notEqual v&#39;} \\[2ex](1 - \alpha) + \alpha\sum_{v&#39; \in in(v)}\frac{PR(v&#39;)}{\left| out(v&#39;) \right|}, &amp; \text{ (v = v&#39;) }\end{cases}\]</span></p><p><img src="pagerankexample.png" /></p><p>我们以图中的例子来说明，用户<span class="math inline">\(A, B, C\)</span>和商品<span class="math inline">\(a, b, c, d\)</span> 分别编号<span class="math inline">\(0,1,2,3,4,5,6\)</span> 执行代码如下</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * personal rank algo from book recommend system book, it it for specific node, known as root</span></span><br><span class="line"><span class="comment">    * NOT AVAILABLE in large scale data</span></span><br><span class="line"><span class="comment">    * @param G </span></span><br><span class="line"><span class="comment">    * @param root</span></span><br><span class="line"><span class="comment">    * @param steps</span></span><br><span class="line"><span class="comment">    * @param alpha</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">personalRankAlgo</span></span>(<span class="type">G</span>:<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">Int</span>]], root:<span class="type">Int</span>, steps:<span class="type">Int</span>, alpha:<span class="type">Double</span>) =&#123;</span><br><span class="line">    <span class="keyword">var</span> rank = collection.mutable.<span class="type">Map</span>( <span class="type">G</span>.map( x =&gt; <span class="keyword">if</span> (x._1 == root) (x._1,<span class="number">1.0</span>) <span class="keyword">else</span>(x._1, <span class="number">0.0</span>)).toSeq: _*)</span><br><span class="line">    <span class="keyword">for</span>(step &lt;- (<span class="number">0</span> until steps).toList)&#123;</span><br><span class="line">      <span class="keyword">val</span> tmp = collection.mutable.<span class="type">Map</span>( <span class="type">G</span>.mapValues(_ =&gt; <span class="number">0.0</span>).toSeq:_*)</span><br><span class="line">      <span class="keyword">for</span>( (k, v) &lt;- <span class="type">G</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(c &lt;- v)&#123;</span><br><span class="line">          <span class="keyword">if</span>( !tmp.contains(c))</span><br><span class="line">            tmp.put(c, <span class="number">0.0</span>)</span><br><span class="line">          <span class="keyword">val</span> ori = tmp.get(c).get</span><br><span class="line">          tmp.put(c, ori + alpha * rank(k) / v.length)</span><br><span class="line">          <span class="keyword">if</span> (c == root)</span><br><span class="line">            tmp.put(c, ori + <span class="number">1.0</span> - alpha) <span class="comment">// because of root vertex</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      rank = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    rank</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testPageRank</span></span>: <span class="type">Unit</span> =&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> <span class="type">G</span> = <span class="type">Map</span>(<span class="number">0</span> -&gt; <span class="type">List</span>(<span class="number">3</span>,<span class="number">5</span>), <span class="number">1</span> -&gt; <span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>), <span class="number">2</span> -&gt; <span class="type">List</span>(<span class="number">5</span>,<span class="number">6</span>), <span class="number">3</span>-&gt;<span class="type">List</span>(<span class="number">0</span>,<span class="number">1</span>), <span class="number">4</span>-&gt;<span class="type">List</span>(<span class="number">1</span>), <span class="number">5</span> -&gt; <span class="type">List</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>), <span class="number">6</span> -&gt; <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">val</span> alpha = <span class="number">0.5</span></span><br><span class="line">    <span class="keyword">val</span> steps = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    personalRankAlgo(<span class="type">G</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0.5</span>).foreach(println)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后输出结果 <img src="pagerankOutput.png" /></p><p>用户a没有和物品b和d有过联系，但是b的PR值小于d, 所以针对A的推荐结果应该是{d, b}, 注意以上代码仅是从某个特定点出发。</p><h2 id="graphx的pagerank">GraphX的pagerank</h2><p>图本身是递归数据结构，顶点的属性依赖于它们邻居的属性，这些邻居的属性又依赖于自己邻居的属性。所以许多重要的图算法都是迭代的重新计算每个顶点的属性，直到满足某个确定的条件。 一系列的graph-parallel抽象已经被提出来用来表达这些迭代算法。GraphX公开了一个类似Pregel的操作，它是广泛使用的Pregel和GraphLab抽象的一个融合。</p><p>在GraphX中，更高级的Pregel操作是一个约束到图拓扑的批量同步（bulk-synchronous）并行消息抽象。Pregel操作者执行一系列的超级步骤（super steps），在这些步骤中，顶点从 之前的超级步骤中接收进入(inbound)消息的总和，为顶点属性计算一个新的值，然后在以后的超级步骤中发送消息到邻居顶点。不像Pregel而更像GraphLab，消息作为一个边三元组的函数被并行 计算，消息计算既访问了源顶点特征也访问了目的顶点特征。在超级步中，没有收到消息的顶点被跳过。当没有消息遗留时，Pregel操作停止迭代并返回最终的图。</p><p>GraphX已经内置了pageRank算法 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> graph = <span class="type">GraphLoader</span>.edgeListFile(spark.sparkContext, <span class="type">GRAPH_EDGE</span>)</span><br><span class="line"><span class="keyword">val</span> ranks = graph.pageRank(<span class="number">0.1</span>).vertices.map(x =&gt; x._1.toString + <span class="string">&quot;,&quot;</span> + x._2.toString)</span><br></pre></td></tr></table></figure> 仅两行代码便可调用pagerank算法，在集群资源16 executors * 4cores *10G 下 耗时 40min vertices 大约170W</p><h2 id="小结">小结</h2><ol type="1"><li>基于pageRank算法可以针对用户进行个性化推荐，也可以利用物品PR值排序结果作为冷启动推荐结果</li></ol>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+next制作博客</title>
      <link href="/2020/03/09/hexo-next%E5%88%B6%E4%BD%9C%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/03/09/hexo-next%E5%88%B6%E4%BD%9C%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>本篇博客主要记录了如何使用github的pages以及Hexo搭建博客, 方便读者快速实现个人博客梦想</p><h2 id="什么是github-pages">什么是Github Pages</h2><p>首先得知道Github pages的规则: &gt; 每个Github账号下面只能建立一个Pages，且命名必须符合这样的规则：&quot;username.github.io&quot; &gt; 创建成功后，username.github.io就是你的域名（当然你可以通过别名解析绑定自己的域名） <span id="more"></span></p><h2 id="搭建步骤">搭建步骤</h2><ol type="1"><li>在Github建立一个新的Repository：命名为：<font>username.github.io</font></li><li>本地clone仓库 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/username/username.github.io</span><br></pre></td></tr></table></figure></li><li>使用Hexo管理博客<ol type="1"><li>进入clone下来的仓库目录 创建hexo分支 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hexo</span><br></pre></td></tr></table></figure></li><li>安装hexo，以及相关扩展依赖 并初始化(需要首先安装nodejs, MacOS平台执行 brew install node) <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init [your hexo <span class="built_in">dir</span>] // 初始化</span><br></pre></td></tr></table></figure> <strong>完成初始化后将[your hexo dir]再移入仓库目录</strong> <strong>在仓库根目录下执行 npm install</strong></li></ol></li><li><p>hexo主题 推荐next主题, 常用功能直接配置 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add git@github.com:matt90luo/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure></p></li><li><p>hexo 插件安装 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pandoc  --save  // 渲染Mathjax数学公式需要(pandoc本身功能强大)</span><br><span class="line">npm install hexo-generator-search --save  //本地搜索功能需要</span><br><span class="line">npm install hexo-deployer-git --save  //git发布</span><br><span class="line">npm install hexo-filter-mermaid-diagrams --save //mermaid流程图</span><br><span class="line">npm install hexo-tag-plantuml --save  //绘制UML图  </span><br><span class="line">npm install hexo-symbols-count-<span class="built_in">time</span> --save // 博客文章字数统计</span><br></pre></td></tr></table></figure></p></li><li><p>配置说明 需要关注两个配置文件<font color=red>_config.yml</font> 和 <font color=green>themes/next/_config.yml</font>, 分别记作 <font color=red>站点配置文件</font> 和 <font color=green> 主题配置文件</font> 以下是<font color=red>站点配置文件</font>主要配置: <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-math</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line"><span class="attr">engine:</span> <span class="string">&#x27;mathjax&#x27;</span> <span class="comment"># or &#x27;katex&#x27;</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">    <span class="comment">#src: custom_mathjax_source</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">    <span class="comment"># MathJax config</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line">    <span class="comment">#css: custom_css_source</span></span><br><span class="line">    <span class="comment">#js: custom_js_source # not used</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">    <span class="comment"># KaTeX config</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># search</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">./public/search.xml</span></span><br><span class="line"><span class="attr">field:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">limit:</span> <span class="number">10000</span></span><br><span class="line"><span class="comment"># deploy</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repo:</span> <span class="string">https://github.com/yourname/yourname.github.io.git</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></p></li></ol><p>以下是<font color=green> 主题配置文件</font> 主要配置: <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">github_id:</span> <span class="string">yourname</span> <span class="comment"># GitHub repo owner</span></span><br><span class="line"><span class="attr">repo:</span> <span class="string">yourname.github.io</span> <span class="comment"># Repository name to store issues</span></span><br><span class="line"><span class="attr">client_id:</span> <span class="string">XXXXXXXXXXXXXX</span> <span class="comment"># GitHub Application Client ID</span></span><br><span class="line"><span class="attr">client_secret:</span> <span class="string">XXXXXXXXXX</span> <span class="comment"># GitHub Application Client Secret</span></span><br><span class="line"><span class="attr">admin_user:</span> <span class="string">matt90luo</span> <span class="comment"># GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span></span><br><span class="line"><span class="attr">distraction_free_mode:</span> <span class="literal">true</span> <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line"><span class="comment"># Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span></span><br><span class="line"><span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line"><span class="comment"># Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span></span><br><span class="line"><span class="attr">language:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically Excerpt. Not recommend.</span></span><br><span class="line"><span class="comment"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">length:</span> <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line"><span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line"><span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line"><span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Math Formulas Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line"><span class="comment"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class="line"><span class="comment"># That is it only render those page which has `mathjax: true` in Front-matter.</span></span><br><span class="line"><span class="comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">cdn:</span> <span class="string">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line">    <span class="attr">mhchem:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure> 其中 clientID clientSecret 需要去<a href="https://github.com/settings/applications/new">github</a>申请 可以查看此连接 <a href="https://iochen.com/2018/01/06/use-gitalk-in-hexo/">Hexo中Gitalk配置使用教程-可能是目前最详细的教程</a> 以及 <a href="https://www.tiexo.cn/gitalk/">服务体验更棒的Gitalk评论系统</a> 获取详细信息</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统-协同过滤</title>
      <link href="/2020/03/08/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/"/>
      <url>/2020/03/08/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>协同过滤在整个推荐系统的发展历史上具有重要地位 本文介绍了在分布式环境下如何利用协同过滤的思想进行推荐, 协同思想在推荐系统中会反复使用, 工程上实现简单, 业务可解释性强。协同过滤大体上分为基于用户(user-based)的协同过滤算法和基于商品(item-based)的协同过滤算法。 两种算法在具体实现上没有过多区别。 <span id="more"></span></p><p>user-based算法主要步骤:</p><ol type="1"><li>找到和目标用户相似的用户集合</li><li>找到这个集合中的用户喜欢的, 并且目标用户没有听说过的物品推荐给目标用户</li></ol><p>item-based算法主要步骤:</p><ol type="1"><li>计算物品之间的相似度</li><li>根据物品的相似度和目标用户的历史行为生成推荐列表</li></ol><h2 id="稀疏矩阵表示用户商品交互">稀疏矩阵表示用户商品交互</h2><p>如果用户对于商品的交互信息用一个矩阵来表示, 毫无疑问这是一个稀疏矩阵, 在实际业务场景中会存在大量的缺失值, 如何猜出这些缺失值并且有效推荐给用户? 我们采用隐式反馈模型来考量, 某个用户对某一商品有交互有偏好, 那么值为1否则为0。在预测用户行为（隐式反馈）时，大部分只有用户正向选择行为的记录（正样本），这类问题即为One Class 问题，即单类问题。例如我们用0-1矩阵来表示这类问题，1的解释即为用户喜欢该物品，但是0却有两种原因来解释：一是用户没有看到该物品，但是用户喜欢；二是用户已经浏览过了但是不感兴趣。当我们使用协同过滤算法时, 解决0的办法就是通过相似性.</p><table><thead><tr class="header"><th></th><th>隐式反馈</th><th>显示反馈</th></tr></thead><tbody><tr class="odd"><td>准确度</td><td>低</td><td>高</td></tr><tr class="even"><td>丰富度</td><td>高</td><td>低</td></tr><tr class="odd"><td>获取难度</td><td>容易</td><td>困难</td></tr><tr class="even"><td>数据噪音</td><td>较难识别</td><td>较易识别</td></tr><tr class="odd"><td>上下文敏感</td><td>是</td><td>是</td></tr><tr class="even"><td>用户偏好的表达能力</td><td>只有正样本</td><td>包含正负样本</td></tr><tr class="odd"><td>评估比较标准</td><td>相对比较</td><td>绝对比较</td></tr></tbody></table><h2 id="计算相似度">计算相似度</h2><p>我们以item-based为例 两个物品的相似度可以表v示为 <span class="math display">\[w_{i,j} = \frac{\left| N(i) \bigcap N(j) \right| }{\sqrt{\left|N(i)\right|\left|N(j)\right|}} \tag{1}\]</span></p><p><span class="math inline">\(N(i)\)</span>是喜欢物品i的用户数在协同过滤中两个物品产生相似度是因为它们共同被喜欢，每一个用户都通过历史兴趣列表给物品”贡献“ 相似度。这其中蕴含着一种假设，每一个用户的兴趣都局限在某几个方面，因此如果两个物品属于一个用户的兴趣列表，那么这两个物品可能就属于有限的几个领域，而如果两个物品属于很多用户的兴趣列表，那么他们可能属于同一个领域, 因而有很大的相似度</p><p>上面的相似度公式在实际使用中还有改进的地方, 上文中说到每个用户的兴趣列表都对物品的相似度产生贡献, 但是不是每一个用户的贡献都相同。对于特别活跃的用户(比如某用户的兴趣列表长达几十万), 这类用户对于物品之间的贡献度应该小, 即活跃用户对物品的相似度贡献应该小于不活跃的用户, 使用一个IUF(Inverse User Frequence)参数来修正公式</p><p><span class="math display">\[  w_{ij}= \frac{\sum_{u\in N(i) \bigcap N(j)}\frac{1}{\log{(1 + \left| N(u) \right|)}} }{\sqrt{\left| N(i) \right| \left| N(j) \right|}}  \tag{2}\]</span></p><p>我们看到分子相比较上面的公式, 不再是简单的相加而是带有了一个iuf的系数, 我们还可以进一步将时间上下文考虑进去。我们有一个假设用户在相隔很短的时间内喜欢的物品具有更高的相似度, 如果用户对物品i和物品j产生行为的时间越远物品和物品j的相似度就不大, 据此我们得到如下的相似度公式 <span class="math display">\[ w_{ij}= \frac{\sum_{u\in N(i) \bigcap N(j)}\frac{1}{\log{(1 + \left| N(u) \right|)}} \frac{1}{1 + \alpha \left| t_{ui} - t_{uj} \right|} }{\sqrt{\left| N(i) \right| \left| N(j) \right|}} \tag{3} \]</span></p><p>其中<span class="math inline">\(\alpha\)</span>是时间衰减参数, 如果一个系统用户兴趣变化很快, 取较大的<span class="math inline">\(\alpha\)</span>，反之取较小的<span class="math inline">\(\alpha\)</span></p><h3 id="利用spark计算item相似度">利用spark计算item相似度</h3><p>可以利用spark计算两个稀疏矩阵的乘法具体的原理见<a href="http://hejunhao.me/archives/1503">文章</a>,以下是核心代码: <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param spark: sparkSession</span></span><br><span class="line"><span class="comment">    * @param user_item: userID,itemID,(Interaction, interactionTime)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">itemCF</span></span>(spark: <span class="type">SparkSession</span>, user_item: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">Int</span>, (<span class="type">Double</span>, <span class="type">Double</span>))]) = &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> item_user = user_item.map(x =&gt; (x._2, x._1, x._3))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> useriuf = user_item.map(x =&gt; (x._1, x._2)).aggregateByKey(<span class="number">0</span>)((z, b) =&gt; z + <span class="number">1</span>, _ + _) <span class="comment">// userIDx, list(itemIdx)</span></span><br><span class="line">      .map(x =&gt; (x._1, <span class="number">1</span> / <span class="type">Math</span>.log(<span class="number">1</span> + x._2))) <span class="comment">// user对应的IUF系数</span></span><br><span class="line">      .collectAsMap()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;useriuf size &quot;</span>, useriuf.size)</span><br><span class="line">    <span class="keyword">val</span> bruseriuf = spark.sparkContext.broadcast(useriuf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> lm = item_user.map(x =&gt; (x._2, (x._1, x._2, x._3))).partitionBy(<span class="keyword">new</span> <span class="type">HashPartitioner</span>(<span class="number">500</span>)) <span class="comment">//&quot;l_row&quot;, &quot;l_column&quot;, &quot;l_val&quot;</span></span><br><span class="line">    <span class="keyword">val</span> rm = user_item.map(x =&gt; (x._1, (x._1, x._2, x._3))).partitionBy(<span class="keyword">new</span> <span class="type">HashPartitioner</span>(<span class="number">500</span>)) <span class="comment">//&quot;r_row&quot;, &quot;r_column&quot;, &quot;r_val&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> numerator = lm.join(rm)</span><br><span class="line">      .map(x =&gt; ((x._2._1._1, x._2._2._2), x._1, <span class="number">1</span>/(<span class="number">1</span> + <span class="type">TIME_DECAY_ALPHA</span> * math.abs(x._2._1._3._2 - x._2._2._3._2)/<span class="type">HOURSECONDS</span>)))  <span class="comment">// 这里拿到用户 以及用户访问两个item的时间差</span></span><br><span class="line">      .map(x =&gt; (x._1, bruseriuf.value.getOrElse(x._2, <span class="number">0.0</span>) * x._3))</span><br><span class="line">      .partitionBy(<span class="keyword">new</span> <span class="type">HashPartitioner</span>(<span class="number">500</span>))</span><br><span class="line">      .aggregateByKey(<span class="number">0.0</span>)(_ + _, _ + _)</span><br><span class="line">      .filter(x =&gt; x._1._1 &gt;= x._1._2) <span class="comment">//Gram矩阵 主对角线对称 取下对角</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> itemMatrix = sparseMatrixMultiple(spark, item_user.map(x=&gt;(x._1,x._2, x._3._1)), user_item.map(x=&gt;(x._1, x._2, x._3._1))).map(x =&gt; (x._1._1, x._1._2, x._2)).cache()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> diagonal = itemMatrix.filter(x =&gt; x._1 == x._2).map(x =&gt; (x._1, x._3)).collectAsMap()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> brdiagonal = spark.sparkContext.broadcast(diagonal) <span class="comment">//每个商品对应的交互用户</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rs = itemMatrix.filter(x =&gt; x._1 &gt;= x._2).map(x =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> i = brdiagonal.value(x._1)</span><br><span class="line">      <span class="keyword">val</span> j = brdiagonal.value(x._2)</span><br><span class="line">      ((x._1, x._2), <span class="type">Math</span>.sqrt(i * j))</span><br><span class="line">    &#125;)</span><br><span class="line">      .partitionBy(<span class="keyword">new</span> <span class="type">HashPartitioner</span>(<span class="number">500</span>))</span><br><span class="line">      .join(numerator)</span><br><span class="line"></span><br><span class="line">    itemMatrix.unpersist()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> res = rs.map(x =&gt; (x._1._1, x._1._2, x._2._2 / x._2._1))</span><br><span class="line">      .flatMap(x =&gt; <span class="keyword">if</span> (x._1 != x._2) <span class="type">Array</span>((x._1, x._2, x._3), (x._2, x._1, x._3)) <span class="keyword">else</span> <span class="type">Array</span>((x._1, x._2, x._3)))<span class="comment">//需要把矩阵展开</span></span><br><span class="line">    res</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * rdd 稀疏矩阵相乘</span></span><br><span class="line"><span class="comment">    * @param spark sparkSession</span></span><br><span class="line"><span class="comment">    * @param l 左矩阵</span></span><br><span class="line"><span class="comment">    * @param r 右矩阵</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sparseMatrixMultiple</span></span>(spark: <span class="type">SparkSession</span>, l: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Double</span>)], r: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Double</span>)]) = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> lm = l.map(x =&gt; (x._2, (x._1, x._2, x._3))).partitionBy(<span class="keyword">new</span> <span class="type">HashPartitioner</span>(<span class="number">500</span>)) <span class="comment">//&quot;l_row&quot;, &quot;l_column&quot;, &quot;l_val&quot;</span></span><br><span class="line">    <span class="keyword">val</span> rm = r.map(x =&gt; (x._1, (x._1, x._2, x._3))).partitionBy(<span class="keyword">new</span> <span class="type">HashPartitioner</span>(<span class="number">500</span>)) <span class="comment">//&quot;r_row&quot;, &quot;r_column&quot;, &quot;r_val&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> f = lm.join(rm) <span class="comment">// l_column = r_row</span></span><br><span class="line">      .map(x =&gt; ((x._2._1._1, x._2._2._2), x._2._1._3 * x._2._2._3))</span><br><span class="line">      .partitionBy(<span class="keyword">new</span> <span class="type">HashPartitioner</span>(<span class="number">500</span>))</span><br><span class="line">      .aggregateByKey(<span class="number">0.0</span>)(_ + _, _ + _)</span><br><span class="line">    f</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>使用隐式反馈模型, 用户商品交互数据用一个稀疏矩阵表示</p></li><li><p>如何计算每个item有多少user交互以及item两两之间有多少相同user交互? 对于这部分计算是可以等价成两个矩阵相乘, 假设矩阵X是用坐标表示的稀疏矩阵(i, j, v) i是item对应id， j是user对应id, 那么<span class="math inline">\(XX^T\)</span>中, 主对角线的每个元素就是对应item所有交互的user数, 其它元素是两两item之间共同的交互用户数</p></li><li><p><span class="math inline">\(XX^T\)</span> 是一个Gram对称矩阵, 可以适当减少计算量加快计算速度</p></li></ul><h2 id="使用item相似度">使用item相似度</h2><p>我们需要取item相似的前topK数据 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> itemSimRDD = itemSim.filter(x =&gt; x._1 != x._2)</span><br><span class="line">                  .map(x =&gt; (x._1, (x._2, x._3)))</span><br><span class="line">                  .topByKey(<span class="number">500</span>)(<span class="type">Ordering</span>.by[(<span class="type">Int</span>, <span class="type">Double</span>), <span class="type">Double</span>](_._2))</span><br><span class="line">                  <span class="comment">//进行归一化操作</span></span><br><span class="line">                  .map(x =&gt; &#123;</span><br><span class="line">                    <span class="keyword">val</span> max = x._2.head</span><br><span class="line">                        (x._1, x._2.map(t =&gt; (t._1, t._2 / max._2)))</span><br><span class="line">                  &#125;)</span><br></pre></td></tr></table></figure></p><ul><li>计算item相似度的topK可以使用spark提供的topByKey功能, 然后做归一化操作, 归一化以后可以增加推荐的准确度和推荐的覆盖度</li></ul><h2 id="根据item相似度推荐">根据item相似度推荐</h2><p>一般来说用户现在的行为和用户最近的行为关系更大</p><p><span class="math display">\[p(u, i) = \sum_{j \in N(u) \bigcap S(i, k)} sim(i, j)\frac{1}{1 + \beta\left| t_0 - t_{uj} \right|} \tag{4} \]</span> 这里<span class="math inline">\(N(u)\)</span>是用户交互的物品集合, <span class="math inline">\(S(i, k)\)</span> 是和物品i最相似的topK物品, <span class="math inline">\(sim(i, j)\)</span>是物品i和j的相似度</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param spark: sparkSession</span></span><br><span class="line"><span class="comment">    * @param interactRDD:  user, item, timeStamp</span></span><br><span class="line"><span class="comment">    * @param simItem: item-&gt;Array(item, simscore)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">prediction</span></span>(spark:<span class="type">SparkSession</span>, interactRDD:<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>, <span class="type">Double</span>)],</span><br><span class="line">                 simItem: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Double</span>)]]) =&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> brsimItem = spark.sparkContext.broadcast(simItem)</span><br><span class="line">    <span class="keyword">val</span> currentSec = (<span class="type">System</span>.currentTimeMillis()/<span class="number">1000</span>).toDouble</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> pred = interactRDD.map(x =&gt; (x._1, (x._2, x._3)))</span><br><span class="line">      .aggregateByKey(<span class="type">Array</span>.empty[(<span class="type">String</span>, <span class="type">Double</span>)])(_:+_, _++_)</span><br><span class="line">      .map(x=&gt; (x._1, x._2.toMap))</span><br><span class="line">      .map&#123;x =&gt;</span><br><span class="line">       <span class="keyword">val</span> predItem =  brsimItem.value.mapValues&#123; y =&gt;</span><br><span class="line">          y.map&#123;t =&gt;</span><br><span class="line">            <span class="keyword">if</span>(x._2.isDefinedAt(t._1))</span><br><span class="line">              <span class="number">1</span>/(<span class="number">1</span> + <span class="type">TIME_DECAY_BETA</span> * math.abs(currentSec - x._2.get(t._1).get) / <span class="type">HOURSECONDS</span>) * t._2</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              <span class="number">0.0</span></span><br><span class="line">          &#125;.sum</span><br><span class="line">        &#125;.toList.sortBy(_._2)(<span class="type">Ordering</span>.<span class="type">Double</span>.reverse).take(<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">        (x._1, predItem)</span><br><span class="line">      &#125;</span><br><span class="line">    pred</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>物品相似度矩阵存储每个item最相思的topK商品, 使用这个相似度矩阵的核心思想是: 和用户历史上感兴趣的物品越相似的物品，, 越有可能在用户的推荐列表中获得比较高的排名</li><li>在spark中计算如果广播量太大可以切分成较小的部分, 分批计算</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param spark  sparkSession</span></span><br><span class="line"><span class="comment">    * @param interactRDD  user, item, timeStamp</span></span><br><span class="line"><span class="comment">    * @param simItem  item-&gt;Array(item, simscore)</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">prediction2</span></span>(spark:<span class="type">SparkSession</span>, interactRDD:<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>, <span class="type">Double</span>)],</span><br><span class="line">                  simItem: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Double</span>)])]) =&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> currentSec = (<span class="type">System</span>.currentTimeMillis()/<span class="number">1000</span>).toDouble</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> simItemAsIterator = simItem.repartition(<span class="number">10</span>).mapPartitions&#123;it =&gt;</span><br><span class="line">      <span class="type">Iterator</span>.single(it.toMap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interactRDD.cache()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> prediction = (<span class="keyword">for</span>( itemSim &lt;- simItemAsIterator.toLocalIterator) <span class="keyword">yield</span> &#123;</span><br><span class="line">       <span class="keyword">val</span> brsimItem = spark.sparkContext.broadcast(itemSim)</span><br><span class="line">       <span class="keyword">val</span> pred = interactRDD.map(x =&gt; (x._1, (x._2, x._3)))</span><br><span class="line">         .aggregateByKey(<span class="type">Array</span>.empty[(<span class="type">String</span>, <span class="type">Double</span>)])(_:+_, _++_)</span><br><span class="line">         .map(x=&gt; (x._1, x._2.toMap))</span><br><span class="line">         .map&#123;x =&gt;</span><br><span class="line">           <span class="keyword">val</span> predItem =  brsimItem.value.mapValues&#123; y =&gt;</span><br><span class="line">             y.map&#123;t =&gt;</span><br><span class="line">               <span class="keyword">if</span>(x._2.isDefinedAt(t._1))</span><br><span class="line">                 <span class="number">1</span>/(<span class="number">1</span> + <span class="type">TIME_DECAY_BETA</span> * math.abs(currentSec - x._2.get(t._1).get) / <span class="type">HOURSECONDS</span>) * t._2</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                 <span class="number">0.0</span></span><br><span class="line">             &#125;.sum</span><br><span class="line">           &#125;.toList.sortBy(_._2)(<span class="type">Ordering</span>.<span class="type">Double</span>.reverse).take(<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">           (x._1, predItem)</span><br><span class="line">         &#125;</span><br><span class="line">       pred</span><br><span class="line">     &#125;).reduce(_ ++ _).reduceByKey(_ ++ _)</span><br><span class="line">      .map(x=&gt;(x._1, x._2.sortBy(_._2)(<span class="type">Ordering</span>.<span class="type">Double</span>.reverse).take(<span class="number">500</span>)))</span><br><span class="line">    interactRDD.unpersist()</span><br><span class="line">    prediction</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="usercf和itemcf对比">userCF和itemCF对比</h2><p>摘自<a href="http://www.xwood.net/_site_domain_/_root/5870/5930/5932/t_c264767.html">推荐系统与实战</a></p><table><thead><tr class="header"><th></th><th>userCF</th><th>itemCF</th></tr></thead><tbody><tr class="odd"><td>性能</td><td>适用用户较少场景, 用户较大场景下计算用户相似度矩阵代价较大</td><td>适用用户数明显小于用户数的场景</td></tr><tr class="even"><td>领域</td><td>适用时效性强, 用户个性化兴趣不太明显的领域</td><td>长尾物品丰富，用户个性化需求强烈的领域</td></tr><tr class="odd"><td>实时性</td><td>在用户有新行为是, userCF不会造成推荐结果的立即变化</td><td>用户有新行为 itemCF一定会导致推荐结果的实时变化</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
